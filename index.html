<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adjustable Gantt Chart</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root {
      --color-general-primary: #171717;
      --color-general-primary-hover: #262626;
      --color-general-primary-active: #0a0a0a;
      --bg-body: #fafafa;
      --bg-surface: #fff;
      --bg-hover: #f5f5f5;
      --row-bg-default: #f0f0f0;
      --row-bg-hover: #e5e5e5;
      --row-bg-selected: #e0e0e0;
      --text-primary: #171717;
      --text-secondary: #525252;
      --text-tertiary: #737373;
      --border-default: #ebebeb;
      --border-strong: #e5e5e5;
      --border-subtle: #f0f0f0;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.15);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --color-general-primary: #fafafa;
        --color-general-primary-hover: #f5f5f5;
        --color-general-primary-active: #ffffff;
        --bg-body: #121212;
        --bg-surface: #1a1a1a;
        --bg-hover: #262626;
        --row-bg-default: #171717;
        --row-bg-hover: #1f1f1f;
        --row-bg-selected: #262626;
        --bg-subtle: #0d0d0d;
        --text-primary: #fafafa;
        --text-secondary: #737373;
        --text-tertiary: #525252;
        --border-default: #1f1f1f;
        --border-strong: #2e2e2e;
        --border-subtle: #1a1a1a;
        --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
        --shadow-md: 0 4px 12px rgba(0,0,0,0.5);
      }
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 24px;
      background: var(--bg-body);
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 400;
      line-height: 1.5;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    h1 {
      font-size: 24px;
      font-weight: 700;
      line-height: 1.3;
      letter-spacing: -0.02em;
      margin: 0 0 4px 0;
    }
    .subtitle {
      font-size: 14px;
      font-weight: 400;
      color: var(--text-secondary);
      margin: 0;
    }
    .gantt-wrapper {
      position: relative;
      background: var(--bg-surface);
      border-radius: 8px;
      box-shadow: var(--shadow-sm);
      overflow: auto;
      flex: 1;
      min-height: 0;
      container-type: inline-size;
      container-name: gantt;
    }
    .gantt-grid {
      display: flex;
      flex-direction: column;
    }
    .gantt-cell {
      padding: 10px 8px;
      border-bottom: 1px solid var(--border-default);
      border-right: 1px solid var(--border-default);
      min-height: 36px;
      color: var(--text-primary);
    }
    .gantt-cell:last-child { border-right: none; }
    .gantt-row:not(.gantt-header) .gantt-cell {
      background: var(--row-bg-default);
    }
    .gantt-row .gantt-cell:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 10002;
      background: inherit;
    }
    .gantt-row:not(.gantt-header) .gantt-cell:nth-child(1) {
      background: var(--row-bg-default);
    }
    .gantt-header .gantt-cell:nth-child(1) { background: var(--bg-subtle); }
    .phase-header-row > .phase-header-cell:first-child {
      position: sticky;
      left: 0;
      z-index: 10002;
      background: transparent;
    }
    .gantt-header {
      background: var(--bg-subtle);
      color: var(--text-secondary);
      font-weight: 600;
      font-size: 12px;
      letter-spacing: -0.01em;
      text-transform: none;
    }
    .gantt-header .gantt-cell {
      border-color: var(--border-subtle);
    }
    .gantt-header .gantt-cell:nth-child(2),
    .gantt-header .gantt-cell:nth-child(3),
    .gantt-header .gantt-cell:nth-child(4) {
      text-align: center;
    }
    /* Week divider lines only in table body, not in date header */
    .gantt-header .gantt-cell:nth-child(n+5) { border-right: none; }
    .gantt-row {
      display: grid;
      grid-template-columns: 200px 140px 120px 88px repeat(var(--gantt-weeks, 8), var(--gantt-week-width, 1fr));
      width: 100%;
      min-height: 36px;
      flex-shrink: 0;
      position: relative;
    }
    .gantt-wrapper[data-row-appearance="compact"] .gantt-row:not(.gantt-header) {
      min-height: 36px;
    }
    .gantt-wrapper[data-row-appearance="compact"] .gantt-task-cell .task-name-wrap {
      align-items: flex-start;
      min-height: 0;
    }
    .gantt-wrapper[data-row-appearance="compact"] .gantt-task-cell .task-text {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.3;
      word-break: break-word;
    }
    .gantt-wrapper[data-row-appearance="default"] .gantt-row:not(.gantt-header) {
      min-height: 84px;
    }
    .gantt-wrapper[data-row-appearance="default"] .gantt-row:not(.gantt-header) .gantt-timeline-cell .gantt-bar {
      height: 40px;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-grid {
      min-height: 100%;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) {
      flex: 1 1 0;
      min-height: 120px;
      align-items: stretch;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-cell {
      padding-top: 16px;
      padding-bottom: 16px;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-task-cell {
      align-items: stretch;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-task-cell .task-name-wrap {
      align-items: center;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-task-cell .task-chevron,
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-task-cell .task-actions {
      align-self: center;
      flex-shrink: 0;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-phase-cell,
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-party-cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-phase-cell .gantt-phase-dropdown,
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-party-cell .gantt-party-dropdown {
      flex: 1;
      min-height: 0;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-date-cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-date-cell .gantt-date-input-wrap {
      flex: 1;
      min-height: 0;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-row:not(.gantt-header) .gantt-timeline-cell .gantt-bar {
      top: 16px;
      bottom: 16px;
      height: auto;
      transform: none;
      min-height: 24px;
    }
    .gantt-row[draggable="true"] { cursor: grab; }
    .gantt-row:not(.gantt-header):hover .gantt-cell {
      background: var(--row-bg-hover);
    }
    .gantt-row.selected .gantt-cell {
      background: var(--row-bg-selected);
    }
    .gantt-row.selected:hover .gantt-cell {
      background: var(--row-bg-selected);
    }
    .gantt-row.dragging { opacity: 0.5; cursor: grabbing; }
    .task-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
      padding: 0;
      margin-left: 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .gantt-delete-btn,
    .gantt-duplicate-btn {
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .gantt-delete-btn:hover {
      color: #dc2626;
    }
    .gantt-duplicate-btn:hover {
      color: var(--text-primary);
    }
    .gantt-header-delete-cell {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 96px;
      background: inherit;
      z-index: 4;
      grid-column: 1 / -1;
    }
    .gantt-header .gantt-header-delete-cell { background: transparent; }
    .gantt-task-cell { font-weight: 500; font-size: 14px; cursor: pointer; }
    .gantt-task-cell .star { color: #f59e0b; margin-right: 4px; }
    .gantt-task-cell:focus-within { cursor: text; }
    .gantt-task-cell {
      display: flex;
      align-items: center;
    }
    .gantt-task-cell .task-name-wrap { flex: 1; min-width: 0; display: flex; align-items: center; gap: 4px; }
    .gantt-task-cell .task-text { flex: 1; min-width: 0; }
    .task-dependency-icon {
      flex-shrink: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      color: #737373;
      cursor: help;
      position: relative;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .gantt-row:hover .task-dependency-icon { opacity: 1; }
    .task-dependency-tooltip {
      position: fixed;
      z-index: 9999;
      padding: 8px 12px;
      background: #171717;
      color: #fafafa;
      font-size: 12px;
      line-height: 1.4;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      white-space: nowrap;
    }
    .task-dependency-tooltip.visible { opacity: 1; }
    .detach-confirm-popup {
      position: fixed;
      z-index: 10000;
      padding: 12px 16px;
      background: #171717;
      color: #fafafa;
      font-size: 13px;
      line-height: 1.5;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      max-width: 280px;
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s, visibility 0.15s;
    }
    .detach-confirm-popup.visible { opacity: 1; visibility: visible; }
    .detach-confirm-popup .detach-confirm-msg { margin-bottom: 12px; }
    .detach-confirm-hint {
      font-size: 11px;
      color: var(--text-tertiary);
      margin: 0 0 12px 0;
      line-height: 1.35;
      max-width: 260px;
    }
    .detach-confirm-hint.hidden { display: none; }
    .phase-confirm-hint {
      font-size: 11px;
      color: var(--text-tertiary);
      margin: 0 0 12px 0;
      line-height: 1.35;
      max-width: 260px;
    }
    .detach-confirm-popup .detach-confirm-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    .detach-confirm-popup button {
      padding: 6px 14px;
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-family: inherit;
    }
    .detach-confirm-popup .detach-confirm-cancel {
      background: #404040;
      color: #fafafa;
    }
    .detach-confirm-popup .detach-confirm-cancel:hover { background: #525252; }
    .detach-confirm-popup .detach-confirm-detach {
      background: var(--color-general-primary);
      color: #fff;
    }
    .detach-confirm-popup .detach-confirm-detach:hover { background: var(--color-general-primary-hover); }
    .phase-confirm-popup .phase-confirm-keep {
      background: #404040;
      color: #fafafa;
    }
    .phase-confirm-popup .phase-confirm-keep:hover { background: #525252; }
    .phase-confirm-popup .phase-confirm-move {
      background: var(--color-general-primary);
      color: #fff;
    }
    .phase-confirm-popup .phase-confirm-move:hover { background: var(--color-general-primary-hover); }
    @media (prefers-color-scheme: dark) {
      .phase-confirm-popup .phase-confirm-move,
      .detach-confirm-popup .detach-confirm-detach {
        color: #171717;
      }
      .phase-confirm-popup .phase-confirm-move:hover,
      .detach-confirm-popup .detach-confirm-detach:hover {
        color: #171717;
      }
    }
    .delete-confirm-cancel { background: #404040; color: #fafafa; }
    .delete-confirm-cancel:hover { background: #525252; }
    .delete-confirm-delete { background: #dc2626; color: #fff; }
    .delete-confirm-delete:hover { background: #b91c1c; }
    .phase-select-menu {
      position: fixed;
      z-index: 10000;
      padding: 8px 0;
      background: #171717;
      color: #fafafa;
      font-size: 13px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      min-width: 160px;
      max-width: 240px;
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s, visibility 0.15s;
    }
    .phase-select-menu.visible { opacity: 1; visibility: visible; }
    .phase-select-menu-title {
      padding: 8px 14px 6px;
      font-weight: 600;
      font-size: 12px;
      color: #a3a3a3;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .phase-select-menu-list { display: flex; flex-direction: column; gap: 2px; }
    .phase-select-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #fafafa;
      font-size: 13px;
      font-family: inherit;
      text-align: left;
      width: 100%;
    }
    .phase-select-menu-item:hover { background: #404040; }
    .phase-select-menu-item .phase-swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }
    .gantt-dependency-line {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .gantt-dependency-line.visible { opacity: 1; z-index: 100001; }
    .gantt-dependency-line path {
      pointer-events: none;
      cursor: pointer;
      transition: opacity 0.15s;
    }
    .gantt-dependency-line path:hover { opacity: 1; }
    .gantt-dependency-line .connector-dot {
      pointer-events: none;
      cursor: grab;
      opacity: 0.9;
      transition: fill 0.15s, stroke 0.15s, opacity 0.15s;
    }
    .gantt-dependency-line .connector-dot {
      visibility: hidden;
      pointer-events: none !important;
    }
    .gantt-dependency-line .connector-dot:hover {
      opacity: 1;
      stroke: #171717;
    }
    .gantt-dependency-line .connector-dot.connector-dot-dragging {
      opacity: 1;
      cursor: grabbing;
    }
    .gantt-all-dependency-lines .connector-path:hover { opacity: 1; }
    .gantt-dependency-unlink-btn {
      position: fixed;
      width: 6px;
      height: 6px;
      min-width: 6px;
      min-height: 6px;
      padding: 0;
      box-sizing: border-box;
      border-radius: 50%;
      background: #a3a3a3;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 9999;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: width 0.2s ease, height 0.2s ease, opacity 0.2s, visibility 0.2s, background 0.2s, border 0.2s, transform 0.2s ease;
      overflow: hidden;
    }
    .gantt-dependency-unlink-btn.visible {
      opacity: 1;
      visibility: visible;
      z-index: 100002;
    }
    body.shift-mode .gantt-dependency-unlink-btn.connector-unlink-always-visible {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    .gantt-dependency-unlink-btn:hover {
      width: 20px;
      height: 20px;
      background: white !important;
      border: 1.5px solid #d4d4d4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      transform: translate(-50%, -50%);
    }
    .gantt-dependency-unlink-btn:active {
      transform: translate(-50%, -50%) scale(0.95);
    }
    .gantt-dependency-unlink-btn svg {
      transition: opacity 0.2s ease, stroke 0.15s;
      width: 10px;
      height: 10px;
      stroke: #262626;
      opacity: 0;
      flex-shrink: 0;
    }
    .gantt-dependency-unlink-btn:hover svg {
      opacity: 1;
      stroke: #dc2626;
    }
    .gantt-connector-count-badge {
      position: fixed;
      z-index: 9999;
      transform: translate(-50%, -50%);
      width: 18px;
      height: 18px;
      min-width: 18px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      color: #fff;
      pointer-events: none;
      border: 1px solid rgba(255, 255, 255, 0.5);
      box-sizing: border-box;
    }
    @media (prefers-color-scheme: dark) {
      .gantt-dependency-unlink-btn:hover {
        background: white !important;
        border-color: #404040;
      }
      .gantt-dependency-unlink-btn:hover svg {
        stroke: #262626;
      }
    }
    .gantt-toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      padding: 10px 16px;
      background: #2e2e2e;
      color: #fafafa;
      font-size: 13px;
      font-weight: 500;
      border-radius: 8px;
      border: 1px solid #404040;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, transform 0.2s, visibility 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .gantt-toast svg {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }
    .gantt-toast.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }
    .gantt-toast.error {
      background: #3d2a2a;
      border-color: #5c4040;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .gantt-toast-undo {
      margin-left: 4px;
      padding: 2px 8px;
      background: rgba(255,255,255,0.12);
      border: none;
      border-radius: 4px;
      color: #fafafa;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
    }
    .gantt-toast-undo:hover {
      background: rgba(255,255,255,0.2);
    }
    .gantt-drag-guide {
      position: fixed;
      left: 0;
      top: 0;
      width: 2px;
      height: 0;
      background: #525252;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }
    .gantt-drag-guide.visible { display: block !important; }
    .gantt-drag-guide.snap-zone {
      background: #737373;
      width: 2px;
    }
    .gantt-bar-snap-indicator {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      opacity: 0;
      pointer-events: none;
      z-index: 3;
      transition: opacity 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .gantt-bar-snap-indicator.visible { opacity: 1; }
    .gantt-bar-snap-indicator svg {
      width: 12px;
      height: 12px;
      color: inherit;
    }
    .gantt-all-dependency-lines { pointer-events: none; }
    .gantt-all-dependency-lines.visible { pointer-events: auto; }
    #ganttChildConnectorsContainer { pointer-events: none; }
    body.shift-mode .gantt-all-dependency-lines.visible { z-index: 50; }
    .gantt-all-dependency-lines .connector-path { opacity: 0.5; stroke-dasharray: 4 3; }
    .gantt-all-dependency-lines .connector-path-wrap:hover .connector-path { opacity: 1; }
    .gantt-all-dependency-lines .connector-path-hit { cursor: pointer; }
    .gantt-all-dependency-lines .connector-path.connector-dragging { opacity: 1; }
    .gantt-all-dependency-lines .connector-dot {
      cursor: grab;
      opacity: 0.5;
      transition: fill 0.15s, stroke 0.15s, opacity 0.15s;
    }
    .gantt-all-dependency-lines .connector-dot:hover {
      opacity: 1;
      stroke: #171717;
      stroke-width: 1px;
    }
    .gantt-all-dependency-lines .connector-dot.connector-dot-dragging {
      opacity: 1;
      fill: var(--color-general-primary);
      stroke: #171717;
      stroke-width: 1px;
      cursor: grabbing;
    }
    .task-rename-btn {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .gantt-task-cell:hover .task-actions { opacity: 1; }
    .gantt-task-cell:focus-within .task-actions { display: none; }
    .task-rename-btn:hover { color: var(--text-primary); }
    .gantt-date-cell {
      color: var(--text-secondary);
      font-size: 13px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .gantt-date-input-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0;
    }
    .gantt-date-input-wrap input[type="text"] {
      flex: 1;
      min-width: 0;
      max-width: 36px;
      border: none;
      background: transparent;
      font-size: 13px;
      font-family: inherit;
      color: var(--text-secondary);
    }
    .gantt-date-input-wrap input[type="text"]:focus { outline: none; }
    .gantt-date-input-wrap .gantt-date-sep {
      flex-shrink: 0;
      color: var(--text-tertiary);
      font-size: 12px;
      user-select: none;
    }
    .gantt-party-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      color: var(--text-primary);
    }
    /* Legacy party select styles - now using custom dropdown */
    .gantt-party-input {
      width: 100%;
      min-width: 0;
      padding: 4px 8px;
      border: 1px solid var(--border-strong);
      border-radius: 4px;
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
    }
    .gantt-party-input:focus { outline: none; border-color: var(--color-general-primary); }
    .gantt-timeline-cell {
      position: relative;
      padding: 4px;
      background: inherit;
    }
    .gantt-bar {
      position: absolute;
      height: 24px;
      top: 50%;
      transform: translateY(-50%);
      border-radius: 4px;
      cursor: grab;
      user-select: none;
      transition: opacity 0.2s ease, box-shadow 0.15s;
      min-width: 8px;
      container-type: size;
      z-index: 9999;
    }
    .gantt-bar-stroke {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      z-index: 0;
    }
    .gantt-bar-inner {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      z-index: 1;
    }
    .gantt-bar:focus { outline: none; }
    .gantt-bar:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .gantt-bar.dragging { cursor: grabbing; opacity: 1; z-index: 5; }
    .gantt-wrapper:has(.gantt-bar.dragging) .gantt-bar:not(.dragging),
    .gantt-wrapper:has(.gantt-bar.resizing) .gantt-bar:not(.resizing) { opacity: 0.75; }
    .gantt-bar.resizing { cursor: ew-resize; }
    .gantt-bar.selected { box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 4; }
    .gantt-bar.selected:focus { outline: none; }
    .gantt-wrapper:has(.gantt-bar.selected) .gantt-bar:not(.bar-family):not(.dragging):not(.resizing) {
      opacity: 0.16;
      transition: opacity 0.2s ease;
    }
    .gantt-wrapper:has(.gantt-bar.selected) .gantt-row:not(.gantt-header):not(:has(.gantt-bar.bar-family)) .gantt-cell > * {
      opacity: 0.16;
      transition: opacity 0.2s ease;
    }
    .gantt-bar .resize-handle {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: clamp(8px, 33cqh, 24px);
      cursor: ew-resize;
      background: transparent;
    }
    .gantt-bar .resize-handle-left {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: clamp(8px, 33cqh, 24px);
      min-width: 8px;
      cursor: ew-resize;
      background: transparent;
    }
    .gantt-bar .resize-handle:hover,
    .gantt-bar .resize-handle-left:hover { background: rgba(0,0,0,0.15); }
    .gantt-bar.resizing .resize-handle,
    .gantt-bar.resizing .resize-handle-left { background: rgba(0,0,0,0.25); }
    .gantt-bar-duration-hint {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      font-weight: 600;
      color: inherit;
      pointer-events: none;
      white-space: nowrap;
      z-index: 1;
    }
    .gantt-bar-duration-hint-hover {
      opacity: 0;
      transition: opacity 0.15s;
    }
    .gantt-bar:not(.dragging):not(.resizing):hover .gantt-bar-duration-hint-hover {
      opacity: 1;
    }
    .gantt-bar.selected .gantt-bar-duration-hint-hover,
    .gantt-bar.selected:hover .gantt-bar-duration-hint-hover {
      opacity: 0 !important;
      pointer-events: none;
    }
    body.shift-mode .gantt-bar,
    body.shift-mode .gantt-bar .resize-handle,
    body.shift-mode .gantt-bar .resize-handle-left { cursor: default; pointer-events: none; }
    body.shift-mode .gantt-bar-duration-hint-hover {
      opacity: 1 !important;
    }
    .gantt-wrapper[data-show-duration-on-bar="true"] .gantt-bar-duration-hint-hover {
      opacity: 1;
    }
    .gantt-wrapper[data-show-duration-on-bar="true"] .gantt-bar.selected .gantt-bar-duration-hint-hover {
      opacity: 0 !important;
    }
    .gantt-bar-tooltip {
      position: fixed;
      z-index: 100000;
      min-width: 200px;
      max-width: 240px;
      padding: 10px 12px;
      background: rgba(23, 23, 23, 0.96);
      color: #fafafa;
      font-size: 13px;
      line-height: 1.4;
      border-radius: 6px;
      border: 1px solid transparent;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .gantt-bar-tooltip.visible { opacity: 1; visibility: visible; }
    .gantt-bar-tooltip.has-actions { pointer-events: auto; }
    .gantt-bar-tooltip-actions { margin-top: 8px; padding-top: 8px; border-top: 1px solid #404040; display: flex; flex-direction: column; gap: 6px; }
    .gantt-bar-tooltip-move-label { font-size: 11px; font-weight: 600; color: #a3a3a3; text-transform: uppercase; letter-spacing: 0.04em; }
    .gantt-bar-tooltip-title { font-weight: 600; margin-bottom: 4px; }
    .gantt-bar-tooltip-row {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      color: #a3a3a3;
      font-size: 12px;
      margin-top: 4px;
    }
    .gantt-bar-tooltip-row .gantt-bar-tooltip-icon {
      flex-shrink: 0;
      width: 14px;
      height: 14px;
      margin-top: 1px;
      opacity: 0.8;
    }
    .gantt-bar-tooltip-row .gantt-bar-tooltip-text { flex: 1; min-width: 0; }
    .gantt-bar-tooltip-dep-unlink-wrap { margin-left: 6px; }
    .gantt-bar-tooltip-dep-unlink {
      background: none; border: none; padding: 2px; font-size: 0; cursor: pointer;
      color: var(--color-general-primary); text-decoration: none;
      display: inline-flex; align-items: center; justify-content: center;
    }
    .gantt-bar-tooltip-dep-unlink svg { flex-shrink: 0; }
    .gantt-bar-tooltip-dep-unlink:hover { opacity: 0.85; }
    .gantt-bar-tooltip-desc .gantt-bar-tooltip-text { max-height: 120px; overflow-y: auto; }
    .gantt-cell[contenteditable] {
      outline: none;
      cursor: text;
    }
    .gantt-cell[contenteditable]:focus,
    .gantt-task-cell:focus-within {
      background: var(--row-bg-default);
      box-shadow: inset 0 0 0 2px var(--color-general-primary);
    }
    .add-task-fab {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      font-size: 24px;
      font-weight: 300;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, box-shadow 0.2s, transform 0.2s, color 0.2s;
      z-index: 1000;
      background: var(--color-general-primary);
      color: var(--bg-body);
    }
    .add-task-fab:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }
    .add-task-fab:active {
      transform: scale(0.98);
    }
    .fab-phase-menu {
      position: fixed;
      z-index: 10001;
      padding: 8px 0;
      background: #171717;
      color: #fafafa;
      font-size: 13px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      min-width: 160px;
      max-width: 240px;
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s, visibility 0.15s;
    }
    .fab-phase-menu.visible { opacity: 1; visibility: visible; }
    .fab-phase-menu-title {
      padding: 8px 14px 6px;
      font-weight: 600;
      font-size: 12px;
      color: #a3a3a3;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .fab-phase-menu-list { display: flex; flex-direction: column; gap: 2px; }
    .fab-phase-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #fafafa;
      font-size: 13px;
      font-family: inherit;
      text-align: left;
      width: 100%;
    }
    .fab-phase-menu-item:hover { background: #404040; }
    .fab-phase-menu-item .phase-swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }
    @media (prefers-color-scheme: dark) {
      .add-task-fab {
        background: #ffffff;
        color: #171717;
      }
      .add-task-fab:hover {
        background: #f0f0f0;
      }
    }
    .home-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .home-new-project-btn {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 600;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-family: inherit;
      background: var(--color-general-primary);
      color: var(--bg-body);
      transition: opacity 0.2s;
    }
    .home-new-project-btn:hover {
      opacity: 0.9;
    }
    @media (prefers-color-scheme: dark) {
      .home-new-project-btn {
        background: #ffffff;
        color: #171717;
      }
    }
    .week-label { 
      font-weight: 500;
      color: var(--text-secondary);
    }
    .gantt-phase-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      color: var(--text-primary);
    }
    .gantt-phase-cell select {
      flex: 1;
      min-width: 0;
      border: none;
      background: transparent;
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      padding: 2px 0;
      color: inherit;
    }
    .gantt-phase-cell select:focus { outline: none; }
    .gantt-phase-dropdown {
      flex: 1;
      min-width: 0;
      position: relative;
    }
    .gantt-phase-dropdown-trigger {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      width: 100%;
      padding: 2px 0;
      border: none;
      background: transparent;
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      color: inherit;
      text-align: center;
    }
    .gantt-phase-dropdown-trigger:focus { outline: none; }
    .gantt-phase-dropdown-trigger .phase-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .gantt-phase-dropdown-trigger .phase-chevron {
      margin-left: auto;
      opacity: 0;
      font-size: 10px;
      flex-shrink: 0;
      color: var(--text-tertiary);
      transition: opacity 0.15s ease;
    }
    .gantt-phase-cell:hover .gantt-phase-dropdown-trigger .phase-chevron,
    .gantt-phase-dropdown.open .gantt-phase-dropdown-trigger .phase-chevron {
      opacity: 0.6;
    }
    .gantt-phase-dropdown-list {
      position: fixed;
      top: 0;
      left: 0;
      min-width: 120px;
      margin-top: 0;
      background: var(--bg-surface);
      border: 1px solid var(--border-strong);
      border-top: none;
      border-radius: 0 0 6px 6px;
      box-shadow: var(--shadow-md);
      z-index: 10001;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
    .gantt-phase-dropdown.open .gantt-phase-dropdown-list { display: block; }
    .gantt-phase-dropdown-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      border: none;
      background: transparent;
      color: var(--text-primary);
      text-align: left;
      width: 100%;
      white-space: nowrap;
    }
    .gantt-phase-dropdown-option:hover { background: var(--bg-hover); }
    .gantt-phase-dropdown-option.selected { font-weight: 600; }
    .gantt-phase-dropdown-option.phase-secondary::after {
      content: " 2nd";
      font-size: 11px;
      font-weight: 400;
      color: var(--text-tertiary);
      margin-left: 4px;
    }
    .gantt-phase-dropdown-option .phase-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .gantt-bar-tooltip-phase-dropdown { width: 100%; }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-trigger {
      color: #fafafa;
      width: 100%;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-trigger .phase-chevron {
      color: #a3a3a3;
      opacity: 0;
      transition: opacity 0.15s ease;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-trigger:hover .phase-chevron,
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown.open .gantt-phase-dropdown-trigger .phase-chevron {
      opacity: 1;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-list,
    .gantt-phase-dropdown-list.gantt-bar-tooltip-phase-dropdown-list {
      z-index: 100001;
      background: #171717 !important;
      border: 1px solid #404040 !important;
      border-top: 1px solid #404040 !important;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-option {
      color: #fafafa !important;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-option:hover {
      background: #262626 !important;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-option.selected {
      font-weight: 600;
      color: #fafafa !important;
    }
    .gantt-bar-tooltip-phase-dropdown .gantt-phase-dropdown-option.phase-secondary::after {
      content: " 2nd";
      font-size: 11px;
      font-weight: 400;
      color: #a3a3a3;
      margin-left: 4px;
    }
    .gantt-party-dropdown {
      flex: 1;
      min-width: 0;
      position: relative;
    }
    .gantt-party-dropdown-trigger {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      width: 100%;
      padding: 2px 0;
      border: none;
      background: transparent;
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      color: inherit;
      text-align: center;
    }
    .gantt-party-dropdown-trigger:focus { outline: none; }
    .gantt-party-dropdown-trigger .party-chevron {
      margin-left: auto;
      opacity: 0;
      font-size: 10px;
      flex-shrink: 0;
      color: var(--text-tertiary);
      transition: opacity 0.15s ease;
    }
    .gantt-party-cell:hover .gantt-party-dropdown-trigger .party-chevron,
    .gantt-party-dropdown.open .gantt-party-dropdown-trigger .party-chevron {
      opacity: 0.6;
    }
    .gantt-party-dropdown-list {
      position: fixed;
      top: 0;
      left: 0;
      min-width: 120px;
      margin-top: 0;
      background: var(--bg-surface);
      border: 1px solid var(--border-strong);
      border-top: none;
      border-radius: 0 0 6px 6px;
      box-shadow: var(--shadow-md);
      z-index: 10001;
      max-height: 200px;
      overflow-y: auto;
      display: none;
    }
    .gantt-party-dropdown.open .gantt-party-dropdown-list { display: block; }
    .gantt-party-dropdown-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      border: none;
      background: transparent;
      color: var(--text-primary);
      text-align: left;
      width: 100%;
      white-space: nowrap;
    }
    .gantt-party-dropdown-option:hover { background: var(--bg-hover); }
    .gantt-party-dropdown-option.selected { font-weight: 600; }
    .gantt-party-dropdown-option.gantt-party-add-new {
      border-top: 1px solid var(--border-default);
      color: var(--text-tertiary);
    }
    .page-header {
      position: relative;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 24px;
      gap: 24px;
      flex-shrink: 0;
    }
    .page-header-title-wrap { flex: 1; min-width: 0; }
    .page-header-title-wrap h1,
    .page-header-title-wrap .subtitle {
      cursor: text;
      border-radius: 4px;
      padding: 2px 4px;
      margin: -2px -4px;
    }
    .page-header-title-wrap h1:focus,
    .page-header-title-wrap .subtitle:focus {
      outline: none;
      box-shadow: inset 0 0 0 2px var(--color-general-primary);
    }
    .settings-btn {
      width: 36px;
      height: 36px;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      border-radius: 8px;
      color: #737373;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .settings-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
    .settings-btn svg { width: 20px; height: 20px; }
    .settings-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.3);
      z-index: 100010;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }
    .settings-overlay.open {
      opacity: 1;
      visibility: visible;
    }
    .settings-drawer {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 400px;
      max-width: 100%;
      height: 100%;
      max-height: 100vh;
      background: var(--bg-surface);
      box-shadow: -4px 0 24px rgba(0,0,0,0.3);
      z-index: 100011;
      display: flex;
      flex-direction: column;
      min-height: 0;
      transform: translateX(100%);
      transition: transform 0.25s ease;
    }
    .settings-overlay.open .settings-drawer {
      transform: translateX(0);
    }
    .settings-drawer-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-default);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }
    .settings-drawer-header h2 { margin: 0; font-size: 18px; font-weight: 600; color: var(--text-primary); }
    .settings-drawer-close {
      width: 36px;
      height: 36px;
      padding: 0;
      border: none;
      background: transparent;
      border-radius: 8px;
      color: var(--text-tertiary);
      cursor: pointer;
      font-size: 22px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .settings-drawer-close:hover { background: var(--bg-subtle); color: var(--text-primary); }
    .settings-tabs {
      display: flex;
      gap: 0;
      padding: 0 24px;
      border-bottom: 1px solid var(--border-default);
      flex-shrink: 0;
    }
    .settings-tab {
      padding: 12px 20px;
      border: none;
      background: transparent;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-tertiary);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
    }
    .settings-tab:hover { color: var(--text-primary); }
    .settings-tab.active {
      color: var(--color-general-primary);
      border-bottom-color: var(--color-general-primary);
      background: var(--bg-surface);
    }
    .settings-tab-panel { display: none; }
    .settings-tab-panel.active { display: block; }
    .settings-drawer-body {
      padding: 24px;
      flex: 1 1 0;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }
    .settings-section { margin-bottom: 24px; }
    .settings-section:last-child { margin-bottom: 0; }
    .settings-section label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    .settings-section input[type="text"],
    .settings-section input[type="date"],
    .settings-section textarea,
    .settings-section select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-primary);
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
    }
    .settings-section input[type="date"]::-webkit-calendar-picker-indicator {
      opacity: 0.8;
      cursor: pointer;
    }
    @media (prefers-color-scheme: dark) {
      .settings-section input[type="date"]::-webkit-calendar-picker-indicator {
        filter: invert(1);
        opacity: 0.9;
      }
    }
    .settings-section select {
      padding-right: 40px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23737373' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 12px;
    }
    .settings-section textarea { min-height: 80px; resize: vertical; }
    .settings-checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-weight: 500;
      line-height: 1.2;
      min-height: 18px;
    }
    .settings-checkbox-label input[type="checkbox"] {
      width: 18px;
      height: 18px;
      min-width: 18px;
      margin: 0;
      cursor: pointer;
      flex-shrink: 0;
    }
    .settings-segmented {
      display: flex;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      overflow: hidden;
      width: 100%;
    }
    .settings-segmented-option {
      flex: 1;
      padding: 8px 14px;
      border: none;
      background: var(--bg-surface);
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    .settings-segmented-option:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    .settings-segmented-option.selected {
      background: var(--text-primary);
      color: var(--bg-body);
    }
    .settings-hint { display: block; margin-top: 6px; font-size: 12px; color: var(--text-tertiary); }
    .settings-section input:focus,
    .settings-section textarea:focus,
    .settings-section select:focus { outline: none; border-color: var(--color-general-primary); }
    .settings-phase-list { display: flex; flex-direction: column; gap: 8px; }
    .settings-phase-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .settings-phase-item.dragging { opacity: 0.5; }
    .settings-phase-input-wrap {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 36px 6px 8px;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      background: var(--bg-surface);
      min-height: 36px;
      box-sizing: border-box;
    }
    .settings-phase-input-wrap .settings-phase-swatch {
      width: 20px;
      height: 20px;
      min-width: 20px;
      border: none;
      border-radius: 4px;
      padding: 0;
      cursor: pointer;
      background: transparent;
      flex-shrink: 0;
    }
    .settings-phase-input-wrap .settings-phase-swatch::-webkit-color-swatch-wrapper { padding: 0; }
    .settings-phase-input-wrap .settings-phase-swatch::-webkit-color-swatch { border: none; border-radius: 4px; }
    .settings-phase-input-wrap input[type="text"] {
      flex: 1;
      min-width: 0;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
    }
    .settings-phase-input-wrap input[type="text"]:focus { outline: none; }
    .settings-phase-input-wrap:focus-within { border-color: var(--color-general-primary); }
    .settings-phase-remove {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 24px;
      height: 24px;
      padding: 0;
      border: none;
      background: transparent;
      border-radius: 4px;
      color: var(--text-tertiary);
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
    }
    .settings-phase-remove:hover { color: #dc2626; background: rgba(220, 38, 38, 0.1); }
    .settings-phase-remove:disabled { opacity: 0.4; cursor: not-allowed; }
    .settings-add-phase {
      width: 100%;
      margin-top: 8px;
      padding: 10px 12px;
      font-size: 14px;
      color: var(--text-primary);
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      box-sizing: border-box;
    }
    .settings-add-phase:hover { background: var(--bg-hover); border-color: var(--border-strong); }
    .settings-phase-sprints {
      display: none;
      align-items: stretch;
      height: 36px;
    }
    .settings-phase-list[data-phase-mode="fixed"] .settings-phase-sprints {
      display: flex;
    }
    .settings-phase-sprints-inner {
      display: flex;
      align-items: center;
      height: 36px;
      padding: 0 10px 0 12px;
      font-size: 13px;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      background: var(--bg-surface);
      box-sizing: border-box;
    }
    .settings-phase-sprints input {
      width: 28px;
      padding: 0;
      margin: 0;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      text-align: right;
      -moz-appearance: textfield;
    }
    .settings-phase-sprints input::-webkit-outer-spin-button,
    .settings-phase-sprints input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .settings-phase-sprints .sprints-suffix {
      margin-left: 4px;
      font-size: 13px;
      color: var(--text-tertiary);
      white-space: nowrap;
    }
    .settings-palette-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .settings-palette-option {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 12px;
      width: 100%;
      box-sizing: border-box;
      border: 2px solid var(--border-strong);
      border-radius: 8px;
      cursor: pointer;
      background: var(--bg-surface);
      text-align: left;
    }
    .settings-palette-option:hover { border-color: var(--border-default); }
    .settings-palette-option.selected { border-color: var(--color-general-primary); }
    .settings-dependent-wrap {
      position: relative;
      width: 100%;
    }
    .settings-dependent-trigger {
      width: 100%;
      padding: 10px 40px 10px 12px;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      text-align: left;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23737373' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 12px;
    }
    .settings-dependent-trigger:hover { border-color: var(--border-default); }
    .settings-dependent-wrap.open .settings-dependent-trigger { border-color: var(--color-general-primary); }
    .settings-dependent-panel {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      padding: 8px 0;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      background: var(--bg-surface);
      box-shadow: var(--shadow-md);
      z-index: 100;
      max-height: 320px;
      overflow-y: auto;
    }
    .settings-dependent-wrap.open .settings-dependent-panel { display: block; }
    .settings-dependent-option {
      display: block;
      width: 100%;
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      text-align: left;
      cursor: pointer;
    }
    .settings-dependent-option:hover { background: var(--bg-hover); }
    .settings-dependent-divider {
      height: 1px;
      margin: 8px 0;
      background: var(--border-default);
    }
    .settings-dependent-checkbox-wrap {
      padding: 8px 12px 4px;
    }
    .settings-dependent-checkbox-wrap .settings-hint { margin-top: 4px; margin-bottom: 0; padding: 0 0 4px; }
    .settings-dependent-options { margin-top: 12px; }
    .settings-dependent-options .settings-checkbox-label { margin-bottom: 4px; }
    .settings-palette-name {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .settings-palette-option .settings-palette-name-wrap {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
    }
    .settings-palette-option .settings-palette-name-input {
      flex: 1;
      min-width: 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      background: transparent;
      border: none;
      padding: 0;
      font-family: inherit;
    }
    .settings-palette-option .settings-palette-name-input:focus {
      outline: none;
    }
    .settings-palette-option .settings-palette-rename-btn {
      flex-shrink: 0;
      padding: 2px 6px;
      font-size: 11px;
      color: var(--text-tertiary);
      background: transparent;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
    }
    .settings-palette-option .settings-palette-rename-btn:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }
    .settings-palette-swatches {
      display: flex;
      gap: 4px;
      width: 100%;
      min-height: 32px;
    }
    .settings-palette-swatches span {
      flex: 1;
      min-width: 0;
      border-radius: 6px;
      box-sizing: border-box;
    }
    .settings-save-palette-btn {
      margin-top: 10px;
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text-secondary);
      background: transparent;
      border: 1px solid var(--border-strong);
      border: 1px dashed #d4d4d4;
      border-radius: 6px;
      cursor: pointer;
    }
    .settings-save-palette-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
    .settings-party-list { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }
    .settings-party-item { display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: var(--bg-hover); border-radius: 6px; font-size: 13px; }
    .settings-party-item span { flex: 1; min-width: 0; }
    .settings-party-item button { flex-shrink: 0; padding: 2px 8px; font-size: 12px; color: var(--text-tertiary); background: transparent; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; }
    .settings-party-item button:hover { color: #b91c1c; background: rgba(185,28,28,0.1); }
    .settings-add-party-row { display: flex; gap: 8px; align-items: center; }
    .settings-party-input { flex: 1; min-width: 0; padding: 8px 12px; font-size: 13px; border: 1px solid var(--border-strong); border-radius: 6px; font-family: inherit; }
    .settings-auto-populate-btn {
      width: 100%;
      margin-top: 8px;
      padding: 10px 12px;
      font-size: 14px;
      font-weight: 500;
      color: var(--bg-body);
      background: var(--text-primary);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      box-sizing: border-box;
    }
    .settings-auto-populate-btn:hover {
      background: var(--text-secondary);
      color: var(--bg-body);
    }
    .settings-drawer-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--border-default);
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-shrink: 0;
    }
    @media (max-width: 480px) {
      .settings-drawer { width: 100%; }
      .settings-drawer-body { padding: 16px; }
      .settings-drawer-header,
      .settings-drawer-footer { padding-left: 16px; padding-right: 16px; }
      .settings-tabs { padding: 0 16px; }
      .settings-tab { padding: 12px 14px; font-size: 13px; }
    }
    .settings-save-btn {
      padding: 8px 20px;
      font-size: 14px;
      font-weight: 500;
      border-radius: 6px;
      border: none;
      background: var(--text-primary);
      color: var(--bg-body);
      cursor: pointer;
    }
    .settings-save-btn:hover {
      background: var(--text-secondary);
      color: var(--bg-body);
    }
    .chart-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    .chart-controls label {
      font-size: 14px;
      color: var(--text-secondary);
    }
    .chart-controls select {
      padding: 6px 40px 6px 10px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-color: var(--bg-surface);
      color: var(--text-primary);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23737373' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 12px;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      cursor: pointer;
    }
    .chart-controls select:focus { outline: none; border-color: var(--color-general-primary); }
    .gantt-header-sticky {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
    }
    .phase-header-row {
      display: grid;
      grid-template-columns: 200px 140px 120px 88px repeat(var(--gantt-weeks, 8), var(--gantt-week-width, 1fr));
      width: 100%;
      border-bottom: 1px solid var(--border-default);
      flex-shrink: 0;
    }
    .phase-header-timeline {
      grid-column: 5 / -1;
      display: flex;
      position: relative;
      z-index: 2;
    }
    .phase-header-cell {
      padding: 12px 12px;
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      color: var(--text-primary);
      border-right: 1px solid rgba(0,0,0,0.06);
    }
    @media (prefers-color-scheme: dark) {
      .phase-header-cell {
        border-right: 1px solid rgba(255,255,255,0.06);
      }
    }
    .phase-header-cell:last-child { border-right: none; }
    .phase-header-timeline .phase-header-cell:first-child {
      border-top-left-radius: 8px;
    }
    .phase-header-timeline .phase-header-cell {
      cursor: pointer;
      transition: opacity 0.2s ease, filter 0.15s ease;
    }
    .phase-header-timeline .phase-header-cell:hover {
      filter: brightness(1.08);
    }
    .phase-focus-active .phase-header-cell {
      opacity: 0.16;
    }
    .phase-focus-active .phase-header-cell.phase-focused {
      opacity: 1;
    }
    .phase-focus-active .gantt-row:not(.gantt-header) {
      opacity: 0.16;
      transition: opacity 0.2s ease;
    }
    .phase-focus-active .gantt-row.phase-focused {
      opacity: 1;
    }
    .phase-focus-active .gantt-row.selected {
      opacity: 1 !important;
    }
    .gantt-task-cell .task-chevron { transform: rotate(-90deg); }
    .gantt-row.expanded .gantt-task-cell .task-chevron { transform: rotate(0deg); }
    .gantt-detail-row {
      background: var(--bg-body);
      border-bottom: 1px solid var(--border-default);
      padding: 8px 24px 20px 32px;
      flex-shrink: 0;
      position: sticky;
      left: 0;
      width: 100cqw;
      max-width: 100cqw;
      min-width: 0;
      z-index: 6;
      animation: detailExpand 0.3s ease forwards;
      overflow: hidden;
      box-sizing: border-box;
    }
    .gantt-detail-row.closing {
      animation: detailCollapse 0.2s ease forwards;
    }
    .gantt-wrapper[data-row-appearance="default"] .gantt-detail-row .gantt-detail-row-inner {
      min-height: 280px;
    }
    .gantt-wrapper[data-row-appearance="fill"] .gantt-detail-row .gantt-detail-row-inner {
      min-height: 280px;
    }
    @keyframes detailExpand {
      from { opacity: 0; transform: translateY(-6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes detailCollapse {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-6px); }
    }
    .gantt-detail-row-inner {
      min-width: 0;
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
      max-height: min(60vh, 480px);
      overflow-y: auto;
      box-sizing: border-box;
    }
    .task-detail-content {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      transition: opacity 0.15s ease;
      gap: 20px 24px;
      padding-top: 28px;
      min-width: 0;
      max-width: 100%;
    }
    .task-detail-content .task-detail-field:nth-child(n) { grid-column: span 1; }
    .task-detail-field {
      margin-bottom: 0;
      min-width: 0;
      overflow-wrap: break-word;
    }
    .task-detail-field label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 6px;
    }
    .task-detail-field .field-icon {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      color: var(--text-primary);
    }
    .task-detail-field input[type="text"],
    .task-detail-field textarea,
    .task-detail-field select {
      width: 100%;
      max-width: 100%;
      min-width: 0;
      padding: 10px 12px;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-primary);
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
    }
    .task-detail-field select {
      padding-right: 40px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-color: var(--bg-surface);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23737373' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 12px;
    }
    .task-detail-field select:focus {
      outline: none;
      border-color: var(--color-general-primary);
    }
    .task-detail-field textarea {
      min-height: 80px;
      resize: vertical;
    }
    .task-detail-field input:focus,
    .task-detail-field textarea:focus {
      outline: none;
      border-color: var(--color-general-primary);
    }
    .task-detail-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .task-detail-list li {
      display: flex;
      align-items: center;
      padding: 4px 0;
    }
    .task-detail-list-input-wrap {
      flex: 1;
      min-width: 0;
      position: relative;
    }
    .task-detail-list input {
      width: 100%;
      min-width: 0;
      padding: 6px 36px 6px 10px;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-primary);
      border-radius: 4px;
      font-size: 13px;
      box-sizing: border-box;
    }
    .task-detail-list input:focus { outline: none; border-color: var(--color-general-primary); }
    .task-detail-list-remove {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--text-tertiary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .task-detail-list-remove:hover { color: #dc2626; }
    .task-detail-add-btn {
      display: block;
      width: 100%;
      margin-top: 8px;
      padding: 6px 12px;
      font-size: 13px;
      color: var(--text-tertiary);
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      box-sizing: border-box;
    }
    .task-detail-add-btn:hover { color: var(--text-primary); }
    .task-detail-toolbar {
      position: absolute;
      top: 12px;
      right: 24px;
    }
    .task-detail-edit-btn,
    .task-detail-done-btn {
      padding: 6px 14px;
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-secondary);
    }
    .task-detail-edit-btn:hover,
    .task-detail-done-btn:hover {
      background: var(--bg-subtle);
      color: var(--text-primary);
    }
    .task-detail-done-btn {
      background: var(--color-general-primary);
      border-color: var(--color-general-primary);
      color: #fff;
    }
    .task-detail-done-btn:hover {
      background: var(--color-general-primary-active);
      border-color: var(--color-general-primary-active);
      color: #fff;
    }
    .task-detail-view-value {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.5;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      min-width: 0;
    }
    .task-detail-view-value.empty {
      color: var(--text-tertiary);
      font-style: italic;
    }
    .task-detail-link-cards {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .task-detail-link-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: var(--bg-surface);
      border: 1px solid var(--border-strong);
      border-radius: 8px;
      text-decoration: none;
      color: var(--text-primary);
      transition: border-color 0.15s, box-shadow 0.15s;
      min-width: 0;
    }
    .task-detail-link-card:hover {
      border-color: var(--color-general-primary);
      box-shadow: var(--shadow-md);
    }
    .task-detail-link-card-icon {
      flex-shrink: 0;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-hover);
      color: var(--text-tertiary);
    }
    .task-detail-link-card-icon.figma { background: var(--bg-hover); color: var(--text-tertiary); }
    .task-detail-link-card-icon.jira { background: #0052CC; color: #fff; }
    .task-detail-link-card-icon.google { background: var(--bg-surface); color: #4285F4; border: 1px solid var(--border-strong); }
    .task-detail-link-card-content {
      flex: 1;
      min-width: 0;
    }
    .task-detail-link-card-title {
      font-weight: 500;
      font-size: 14px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .task-detail-link-card-url {
      font-size: 12px;
      color: var(--text-tertiary);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .task-detail-link-card-arrow {
      flex-shrink: 0;
      color: var(--text-secondary);
      font-size: 14px;
    }
    .task-detail-view-list {
      list-style: disc;
      margin: 0 0 0 18px;
      padding: 0;
    }
    .task-detail-view-list li {
      padding: 2px 0;
      font-size: 14px;
      color: var(--text-secondary);
    }
    .task-detail-view-list.empty { color: var(--text-tertiary); font-style: italic; }
    .task-detail-dependents-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .task-detail-dependent-item {
      display: block;
      width: 100%;
      text-align: left;
      padding: 8px 10px;
      border: 1px solid var(--border-default);
      border-radius: 6px;
      background: var(--bg-surface);
      color: var(--text-primary);
      font-size: 14px;
      font-family: inherit;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }
    .task-detail-dependent-item:hover {
      border-color: var(--color-general-primary);
      background: var(--bg-hover);
    }
    .task-detail-dependent-item-view {
      cursor: default;
      pointer-events: none;
    }
    .task-detail-dependent-item-view:hover {
      border-color: var(--border-default);
      background: var(--bg-surface);
    }
    .app-views-wrap { flex: 1; min-height: 0; position: relative; }
    .app-view {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      opacity: 0;
      pointer-events: none;
      transition-property: opacity;
      transition-duration: 0.25s;
      transition-timing-function: ease;
    }
    .app-view.active {
      opacity: 1;
      pointer-events: auto;
      z-index: 1;
    }
    #homeView.active ~ #ganttView #ganttDependencyLine,
    #homeView.active ~ #ganttView #ganttChildConnectorsContainer,
    #homeView.active ~ #ganttView .gantt-dependency-unlink-btn {
      display: none !important;
    }
    #homeView.active {
      padding: 24px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .home-sticky-header {
      flex-shrink: 0;
      margin-bottom: 16px;
    }
    #homeView h1 { margin-bottom: 8px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    #homePageTitle {
      cursor: text;
      border-radius: 4px;
      padding: 2px 4px;
      margin: -2px -4px;
    }
    #homePageDescription {
      cursor: text;
      border-radius: 4px;
      padding: 2px 4px;
      margin: -2px -4px;
    }
    #homePageTitle:focus,
    #homePageDescription:focus {
      outline: none;
      box-shadow: inset 0 0 0 2px var(--color-general-primary);
    }
    .home-project-count-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 24px;
      height: 24px;
      padding: 0 8px;
      font-size: 13px;
      font-weight: 600;
      border-radius: 100px;
      background: var(--color-general-primary);
      color: var(--bg-body);
    }
    .home-subtitle { color: var(--text-secondary); margin: 0 0 24px 0; font-size: 14px; }
    .home-header-row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .home-header-actions { display: flex; align-items: center; gap: 10px; margin-left: auto; }
    .gantt-auth-btn {
      padding: 8px 14px;
      font-size: 13px;
      font-weight: 500;
      border-radius: 6px;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-primary);
      cursor: pointer;
      font-family: inherit;
    }
    .gantt-auth-btn:hover { background: var(--bg-hover); }
    .gantt-auth-user { font-size: 13px; color: var(--text-secondary); margin-right: 4px; }
    .gantt-auth-user-menu {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    .gantt-auth-user-trigger {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      padding: 0;
      border-radius: 50%;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-secondary);
      cursor: pointer;
      font-family: inherit;
      transition: background 0.2s, color 0.2s;
    }
    .gantt-auth-user-trigger:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }
    .gantt-auth-user-trigger svg { width: 18px; height: 18px; }
    .gantt-auth-user-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 220px;
      padding: 8px 0;
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      box-shadow: var(--shadow-md);
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s, visibility 0.15s;
      pointer-events: none;
    }
    .gantt-auth-user-menu:hover .gantt-auth-user-dropdown,
    .gantt-auth-user-menu.open .gantt-auth-user-dropdown {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    .gantt-auth-dropdown-item {
      display: block;
      width: 100%;
      padding: 10px 14px;
      text-align: left;
      font-size: 13px;
      color: var(--text-primary);
      background: none;
      border: none;
      cursor: pointer;
      font-family: inherit;
      text-decoration: none;
      box-sizing: border-box;
    }
    .gantt-auth-dropdown-item:hover {
      background: var(--bg-hover);
    }
    .gantt-auth-dropdown-item.text {
      color: var(--text-secondary);
      cursor: default;
      font-size: 12px;
    }
    .gantt-auth-dropdown-item.text:hover { background: transparent; }
    .gantt-auth-dropdown-divider {
      height: 1px;
      margin: 6px 0;
      background: var(--border-default);
    }
    .gantt-auth-dropdown-section-title {
      padding: 8px 14px 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      color: var(--text-tertiary);
    }
    .gantt-auth-modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 10000;
      display: none; align-items: center; justify-content: center; padding: 24px;
    }
    .gantt-auth-modal-overlay.visible { display: flex; }
    .gantt-auth-modal {
      background: var(--bg-surface); border-radius: 12px; padding: 24px; width: 100%; max-width: 360px;
      box-shadow: var(--shadow-md); border: 1px solid var(--border-default);
    }
    .gantt-auth-modal h3 { margin: 0 0 16px 0; font-size: 18px; font-weight: 600; }
    .gantt-auth-modal form { margin: 0; padding: 0; }
    .gantt-auth-modal input[type="email"],
    .gantt-auth-modal input[type="password"],
    .gantt-auth-modal input[type="url"],
    .gantt-auth-modal input[type="text"] { width: 100%; padding: 10px 12px; margin-bottom: 12px; border-radius: 6px; border: 1px solid var(--border-strong); font-size: 14px; box-sizing: border-box; }
    .gantt-auth-modal .auth-actions { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; }
    .gantt-auth-modal .auth-error { font-size: 13px; color: #b91c1c; margin: 0 0 12px 0; padding: 8px 10px; background: rgba(185, 28, 28, 0.1); border-radius: 6px; border: 1px solid rgba(185, 28, 28, 0.3); display: none; }
    .gantt-auth-modal .auth-config-section { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border-default); }
    .gantt-auth-modal .auth-config-section label { display: block; font-size: 12px; font-weight: 500; color: var(--text-secondary); margin-bottom: 4px; }
    .gantt-auth-modal .auth-login-section.hidden { display: none !important; }
    .gantt-auth-modal .auth-config-section.hidden { display: none !important; }
    .gantt-auth-modal .gantt-auth-btn-primary { background: var(--accent-primary); color: #fff; border: none; font-weight: 600; }
    .gantt-auth-modal .gantt-auth-btn-primary:hover { filter: brightness(1.08); }
    .gantt-auth-modal .gantt-auth-btn-secondary { background: var(--bg-subtle); color: var(--text-primary); border: 1px solid var(--border-strong); }
    .gantt-auth-modal .auth-remember { display: flex; align-items: center; gap: 8px; margin: 10px 0 14px 0; font-size: 13px; color: var(--text-secondary); }
    .gantt-auth-modal .auth-remember input { width: auto; margin: 0; }
    .gantt-auth-modal .auth-use-different { font-size: 12px; color: var(--text-tertiary); margin-top: 16px; }
    .gantt-auth-modal .auth-use-different button { background: none; border: none; color: var(--text-secondary); cursor: pointer; text-decoration: underline; font-size: 12px; padding: 0; font-family: inherit; }
    .gantt-auth-modal .auth-use-different button:hover { color: var(--text-primary); }
    .home-project-list {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      width: 100%;
    }
    @media (max-width: 900px) {
      .home-project-list { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 520px) {
      .home-project-list { grid-template-columns: 1fr; }
    }
    @media (max-width: 640px) {
      .page-header {
        flex-direction: column;
        align-items: stretch;
        gap: 16px;
      }
      .chart-controls {
        justify-content: flex-start;
      }
    }
    .home-project-card {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      padding: 0;
      background: var(--bg-surface);
      border: 1px solid var(--border-default);
      border-radius: 8px;
      box-shadow: var(--shadow-sm);
      overflow: hidden;
    }
    .home-project-card { cursor: pointer; }
    .home-project-card:hover { border-color: var(--border-strong); }
    .home-project-card .home-project-card-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      min-width: 0;
      padding: 14px 16px 16px;
    }
    .home-project-card .home-project-card-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 0 16px 16px;
      margin-top: auto;
    }
    .home-project-card .home-project-card-footer .home-project-footer-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
      transition: opacity 0.2s ease;
    }
    @media (hover: hover) {
      .home-project-card:not(.edit-mode) .home-project-card-footer .home-project-footer-actions {
        opacity: 0;
      }
      .home-project-card:not(.edit-mode):hover .home-project-card-footer .home-project-footer-actions {
        opacity: 1;
      }
    }
    .home-project-timeline-preview {
      flex-shrink: 0;
      width: 100%;
      height: 200px;
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0;
      background: var(--bg-subtle, #f5f5f5);
    }
    @media (prefers-color-scheme: dark) {
      .home-project-timeline-preview { background: var(--bg-subtle, #262626); }
    }
    .home-project-timeline-preview.home-timeline-empty {
      background: transparent;
    }
    .home-project-timeline-preview .home-timeline-svg {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center center;
      color: var(--text-secondary, #525252);
    }
    .home-project-info { display: flex; flex-direction: column; gap: 8px; flex: 1; min-width: 0; }
    .home-project-name { font-weight: 600; font-size: 20px; color: var(--text-primary); line-height: 1.3; }
    .home-project-description { font-size: 15px; color: var(--text-secondary); line-height: 1.45; }
    .home-project-row { width: 100%; font-size: 14px; color: var(--text-secondary); }
    .home-project-card.edit-mode .home-project-card-body { padding: 16px; }
    .home-project-card.edit-mode .home-project-card-footer { padding: 0 16px 16px; }
    .home-project-card.edit-mode .home-project-name-input,
    .home-project-card.edit-mode .home-project-desc-input {
      width: 100%;
      padding: 8px 10px;
      font-size: 14px;
      font-family: inherit;
      border: 1px solid var(--border-strong);
      border-radius: 6px;
      background: var(--bg-surface);
      color: var(--text-primary);
      box-sizing: border-box;
    }
    .home-project-card.edit-mode .home-project-name-input { font-weight: 600; }
    .home-project-card.edit-mode .home-project-desc-input {
      min-height: 60px;
      resize: vertical;
    }
    .home-project-done-btn {
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 600;
      border-radius: 6px;
      border: none;
      background: var(--color-general-primary);
      color: var(--bg-body);
      cursor: pointer;
      font-family: inherit;
    }
    .home-project-done-btn:hover { opacity: 0.9; }
    .home-project-task-count { font-weight: 500; color: var(--text-secondary); }
    .home-project-phase-tag {
      display: inline-block;
      padding: 3px 10px;
      font-size: 12px;
      font-weight: 500;
      border-radius: 4px;
      border: 1px solid transparent;
      align-self: flex-start;
    }
    .home-project-card-footer .home-project-phase-tag { margin-top: 0; }
    .home-project-local-tag {
      display: inline-block;
      padding: 3px 8px;
      font-size: 11px;
      font-weight: 500;
      border-radius: 4px;
      background: var(--bg-subtle, #f0f0f0);
      color: var(--text-secondary);
      border: 1px solid var(--border-default, #e5e5e5);
      align-self: flex-start;
    }
    .home-project-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
    .home-project-action-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      padding: 0;
      border-radius: 6px;
      border: none;
      background: none;
      color: var(--text-secondary);
      cursor: pointer;
      font-family: inherit;
      transition: color 0.2s;
    }
    .home-project-action-btn:hover {
      color: var(--text-primary);
    }
    .home-project-action-btn svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .home-project-delete-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      padding: 0;
      border-radius: 6px;
      border: none;
      background: none;
      color: var(--text-tertiary);
      cursor: pointer;
      font-family: inherit;
      transition: color 0.2s;
    }
    .home-project-delete-btn svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .home-project-delete-btn:hover {
      color: #b91c1c;
    }
    @media (prefers-color-scheme: dark) {
      .home-project-delete-btn:hover {
        color: #fca5a5;
      }
    }
    .home-back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 16px;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 14px;
    }
    .home-back-link:hover { color: var(--text-primary); }
    .gantt-wrapper {
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: auto;
    }
    .gantt-wrapper .gantt-grid {
      flex: 1 0 auto;
      min-height: 0;
    }
    .gantt-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: var(--bg-surface);
      color: var(--text-secondary);
      text-align: center;
      padding: 16px 24px;
      flex-shrink: 0;
      border-top: 1px solid var(--border-strong);
    }
    .gantt-empty-state.hidden { display: none !important; }
    .gantt-empty-state .empty-title { font-size: 18px; font-weight: 600; color: var(--text-primary); }
    .gantt-empty-state-actions { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; }
    .gantt-empty-state .btn-empty-primary {
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      border-radius: 8px;
      border: none;
      background: var(--color-general-primary);
      color: var(--bg-body);
      cursor: pointer;
      font-family: inherit;
    }
    .gantt-empty-state .btn-empty-primary:hover { background: var(--color-general-primary-hover); }
    .gantt-empty-state .btn-empty-secondary {
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      border-radius: 8px;
      border: 1px solid var(--border-strong);
      background: var(--bg-surface);
      color: var(--text-primary);
      cursor: pointer;
      font-family: inherit;
    }
    .gantt-empty-state .btn-empty-secondary:hover { background: var(--bg-hover); }
    .task-chevron {
      display: inline-flex;
      margin-right: 8px;
      color: var(--text-tertiary);
      font-size: 10px;
      transition: transform 0.2s, opacity 0.15s ease;
      pointer-events: none;
      opacity: 0;
    }
    .gantt-task-cell:hover .task-chevron,
    .gantt-row.expanded .gantt-task-cell .task-chevron {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="app-views-wrap">
  <div id="homeView" class="app-view">
    <div class="home-sticky-header">
      <div class="home-header-row">
        <h1><span id="homePageTitle" contenteditable="true">Gantt projects</span> <span class="home-project-count-badge" id="homeProjectCountBadge" contenteditable="false">0</span></h1>
        <div class="home-header-actions">
          <div class="gantt-auth-wrap gantt-auth-user-menu" id="ganttAuthWrap" style="display: none;">
            <button type="button" class="gantt-auth-user-trigger" id="ganttAuthUserTrigger" aria-label="Account menu" aria-expanded="false" aria-haspopup="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
            </button>
            <div class="gantt-auth-user-dropdown" id="ganttAuthUserDropdown" role="menu">
              <div class="gantt-auth-dropdown-section-title">Account</div>
              <div class="gantt-auth-dropdown-item text" id="ganttAuthUserEmail" role="presentation"></div>
              <a href="#" target="_blank" rel="noopener noreferrer" class="gantt-auth-dropdown-item" id="ganttAuthSupabaseLink" role="menuitem">Supabase dashboard</a>
              <div class="gantt-auth-dropdown-divider"></div>
              <div class="gantt-auth-dropdown-section-title">Session</div>
              <button type="button" class="gantt-auth-dropdown-item" id="ganttAuthLogout" role="menuitem">Log out</button>
            </div>
          </div>
          <button type="button" class="gantt-auth-btn" id="ganttAuthLogin">Log in (save to cloud)</button>
          <button type="button" class="home-new-project-btn" id="homeFab" aria-label="New project">+ New project</button>
        </div>
      </div>
      <p class="home-subtitle" id="homePageDescription" contenteditable="true">Create and open project schedules. Each project has its own tasks and settings.</p>
    </div>
    <div class="home-project-list" id="homeProjectList"></div>
  </div>

  <div id="ganttView" class="app-view">
    <a href="#/" class="home-back-link" id="homeBackLink"> All projects</a>
    <header class="page-header">
      <div class="page-header-title-wrap">
        <h1 id="pageTitle" contenteditable="true">Project Schedule</h1>
        <p class="subtitle" id="pageDescription" contenteditable="true">Drag bars to reschedule  Drag edges to change dates  Drag rows to reorder  Click a row to expand details  Click cells to edit</p>
      </div>
      <div class="chart-controls">
      <label for="viewMode">View:</label>
      <select id="viewMode">
        <option value="sprint">Sprint (2 weeks)</option>
        <option value="month">Month (4 weeks)</option>
        <option value="default">Default (8 weeks)</option>
        <option value="project">Entire project</option>
      </select>
      <button type="button" class="settings-btn" id="settingsBtn" title="Project settings">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
      </button>
    </div>
  </header>

  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-drawer">
      <div class="settings-drawer-header">
        <h2>Project Settings</h2>
        <button type="button" class="settings-drawer-close" id="settingsClose">&times;</button>
      </div>
      <div class="settings-tabs">
        <button type="button" class="settings-tab active" data-tab="function">General</button>
        <button type="button" class="settings-tab" data-tab="details">Details</button>
        <button type="button" class="settings-tab" data-tab="style">Style</button>
      </div>
      <div class="settings-drawer-body">
        <div class="settings-tab-panel active" id="settingsTabFunction">
          <div class="settings-section">
            <label>Title</label>
            <input type="text" id="settingsTitle" placeholder="Project Schedule">
          </div>
          <div class="settings-section">
            <label>Description</label>
            <textarea id="settingsDescription" placeholder="Describe your project..."></textarea>
          </div>
          <div class="settings-section">
            <label>Project start date</label>
            <input type="date" id="settingsProjectStartDate">
            <small class="settings-hint">When set, the timeline stays fixed at this date; changing task dates won't shift it.</small>
          </div>
          <div class="settings-section">
            <label>Project end date</label>
            <input type="date" id="settingsProjectEndDate">
            <small class="settings-hint">When set, the timeline is capped at this date; the chart won't extend beyond it.</small>
          </div>
          <div class="settings-section">
            <label>Dependent tasks</label>
            <select id="settingsDependencyGap" aria-hidden="true" style="position:absolute;opacity:0;pointer-events:none;height:0;width:0;">
              <option value="0">0 days (start when previous ends)</option>
              <option value="1">1 day</option>
              <option value="2">2 days</option>
              <option value="3">3 days</option>
              <option value="5">5 days</option>
              <option value="7">1 week</option>
              <option value="14">2 weeks</option>
            </select>
            <div class="settings-dependent-wrap" id="settingsDependentWrap">
              <button type="button" class="settings-dependent-trigger" id="settingsDependentTrigger" aria-expanded="false" aria-haspopup="true">0 days (start when previous ends)</button>
              <div class="settings-dependent-panel" id="settingsDependentPanel" role="menu">
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="0">0 days (start when previous ends)</button>
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="1">1 day</button>
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="2">2 days</button>
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="3">3 days</button>
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="5">5 days</button>
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="7">1 week</button>
                <button type="button" class="settings-dependent-option" role="menuitem" data-value="14">2 weeks</button>
                <div class="settings-dependent-divider"></div>
                <div class="settings-dependent-checkbox-wrap">
                  <label class="settings-checkbox-label">
                    <input type="checkbox" id="settingsIndependentDependencies">
                    <span>Independent start dates & phases for dependencies</span>
                  </label>
                  <small class="settings-hint">When enabled, dependent tasks can have their own start date and phase instead of following the parent. The link remains for tracking; dates are not auto-adjusted.</small>
                </div>
              </div>
            </div>
          </div>
          <div class="settings-section">
            <label class="settings-checkbox-label">
              <input type="checkbox" id="settingsShowDurationOnBar">
              <span>Always show days on bar</span>
            </label>
            <small class="settings-hint">When enabled, the task duration (e.g. 7 days) is shown on every bar instead of only on hover.</small>
          </div>
        </div>
        <div class="settings-tab-panel" id="settingsTabStyle">
          <div class="settings-section">
            <label>View</label>
            <select id="settingsRowAppearance" class="settings-select">
              <option value="compact">Compact</option>
              <option value="default">Default</option>
              <option value="fill">Fill</option>
            </select>
            <small class="settings-hint">Row density and how the task bar area is displayed.</small>
          </div>
          <div class="settings-section">
            <label>Bar style</label>
            <div class="settings-segmented" id="settingsBarStyle" role="group" aria-label="Bar style">
              <button type="button" class="settings-segmented-option" data-value="fill">Fill</button>
              <button type="button" class="settings-segmented-option" data-value="stroke">Stroke</button>
            </div>
          </div>
          <div class="settings-section">
            <label>Color Palette</label>
            <div class="settings-palette-grid" id="settingsPaletteGrid"></div>
            <button type="button" class="settings-save-palette-btn" id="settingsSavePalette">Save current colors as palette</button>
          </div>
        </div>
        <div class="settings-tab-panel" id="settingsTabDetails">
          <div class="settings-section">
            <label>Phase duration</label>
            <select id="settingsPhaseDurationMode">
              <option value="fixed" selected>Fixed (set sprints per phase)</option>
              <option value="dynamic">Dynamic based on child tasks</option>
            </select>
            <small class="settings-hint">Dynamic: phase header width reflects the date range of tasks in that phase. Fixed: set a number of sprints (2 weeks each) per phase.</small>
          </div>
          <div class="settings-section">
            <label>Phases</label>
            <div class="settings-phase-list" id="settingsPhaseList" data-phase-mode="fixed"></div>
            <button type="button" class="settings-add-phase" id="settingsAddPhase">+ Add phase</button>
          </div>
          <div class="settings-section">
            <label class="settings-checkbox-label">
              <input type="checkbox" id="settingsMoveTasksWhenSprintExtended">
              <span>Move tasks when a sprint is extended</span>
            </label>
            <small class="settings-hint">When enabled (fixed phases only), increasing a phase's sprint count will shift later tasks so they stay after the extended phase.</small>
          </div>
          <div class="settings-section settings-snap-to-sprint-wrap" id="settingsSnapToSprintWrap">
            <label class="settings-checkbox-label">
              <input type="checkbox" id="settingsSnapToSprint">
              <span>Snap to sprint</span>
            </label>
            <small class="settings-hint">When enabled, dragging a task start or end date near a sprint boundary (every 2 weeks) will snap it to that date.</small>
          </div>
          <div class="settings-section">
            <label>Responsible parties</label>
            <p class="settings-hint" style="margin-top: 0;">Names shown in the Responsible dropdown for tasks. Saved with the project.</p>
            <div class="settings-party-list" id="settingsResponsiblePartiesList"></div>
            <div class="settings-add-party-row">
              <input type="text" id="settingsPartyInput" placeholder="Add name, press Enter" class="settings-party-input" />
              <button type="button" class="settings-add-phase" id="settingsAddParty">+ Add</button>
            </div>
          </div>
          <div class="settings-section">
            <label>Sample data</label>
            <button type="button" class="settings-auto-populate-btn" id="settingsAutoPopulate">Auto-populate 5 linked tasks</button>
            <small class="settings-hint">Replaces all tasks with 5 sample tasks (Research  Design  Review  Build  Launch) linked consecutively. Useful to explore the chart without starting from scratch.</small>
          </div>
        </div>
      </div>
      <div class="settings-drawer-footer">
        <button type="button" class="settings-save-btn" id="settingsSave">Save</button>
      </div>
    </div>
  </div>

  <div class="task-dependency-tooltip" id="taskDependencyTooltip" role="tooltip"></div>
  <div class="detach-confirm-popup" id="detachConfirmPopup" role="dialog" aria-labelledby="detachConfirmMsg">
    <div class="detach-confirm-msg" id="detachConfirmMsg"></div>
    <p class="detach-confirm-hint" id="detachConfirmHint">You can allow dependent tasks to have their own dates in Settings  General  Dependent tasks.</p>
    <div class="detach-confirm-actions">
      <button type="button" class="detach-confirm-cancel">Keep link</button>
      <button type="button" class="detach-confirm-detach">Detach</button>
    </div>
  </div>
  <div class="detach-confirm-popup phase-confirm-popup" id="phaseConfirmPopup" role="dialog" aria-labelledby="phaseConfirmMsg">
    <div class="detach-confirm-msg" id="phaseConfirmMsg"></div>
    <p class="phase-confirm-hint">You can allow dependent tasks to have their own dates in Settings  General  Dependent tasks.</p>
    <div class="detach-confirm-actions">
      <button type="button" class="phase-confirm-keep">Keep current phase</button>
      <button type="button" class="phase-confirm-move">Move to phase</button>
    </div>
  </div>
  <div class="detach-confirm-popup" id="deleteConfirmPopup" role="dialog" aria-labelledby="deleteConfirmMsg">
    <div class="detach-confirm-msg" id="deleteConfirmMsg"></div>
    <div class="detach-confirm-actions">
      <button type="button" class="delete-confirm-cancel">Cancel</button>
      <button type="button" class="delete-confirm-delete">Delete</button>
    </div>
  </div>
  <div class="phase-select-menu" id="phaseSelectMenu" role="menu" aria-label="Move to phase">
    <div class="phase-select-menu-title">Move to phase</div>
    <div class="phase-select-menu-list" id="phaseSelectMenuList"></div>
  </div>
  <div class="fab-phase-menu" id="fabPhaseMenu" role="menu" aria-label="Start in phase">
    <div class="fab-phase-menu-title">Start in phase</div>
    <div class="fab-phase-menu-list" id="fabPhaseMenuList"></div>
  </div>
  <svg class="gantt-dependency-line" id="ganttDependencyLine" aria-hidden="true">
    <path id="ganttDependencyLinePathHover" d="" stroke="transparent" stroke-width="12" fill="none"/>
    <path id="ganttDependencyLinePath" d="" stroke="#a3a3a3" stroke-width="1" stroke-dasharray="4 3" fill="none"/>
    <g id="ganttDependencyLineDot1" class="connector-dot">
      <circle cx="0" cy="0" r="12" fill="transparent" stroke="none" aria-hidden="true"/>
      <circle cx="0" cy="0" r="3" fill="white" stroke="#d4d4d4" stroke-width="1"/>
      <line x1="-2" y1="0" x2="2" y2="0" stroke="#737373" stroke-width="1" stroke-linecap="round"/>
      <line x1="0" y1="-2" x2="0" y2="2" stroke="#737373" stroke-width="1" stroke-linecap="round"/>
    </g>
    <g id="ganttDependencyLineDot2" class="connector-dot">
      <circle cx="0" cy="0" r="12" fill="transparent" stroke="none" aria-hidden="true"/>
      <circle cx="0" cy="0" r="3" fill="white" stroke="#d4d4d4" stroke-width="1"/>
      <line x1="-2" y1="0" x2="2" y2="0" stroke="#737373" stroke-width="1" stroke-linecap="round"/>
      <line x1="0" y1="-2" x2="0" y2="2" stroke="#737373" stroke-width="1" stroke-linecap="round"/>
    </g>
  </svg>
  <button class="gantt-dependency-unlink-btn" id="ganttDependencyUnlinkBtn" type="button" title="Unlink tasks">
    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/>
      <path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/>
      <line x1="8" y1="2" x2="8" y2="5"/>
      <line x1="2" y1="8" x2="5" y2="8"/>
      <line x1="16" y1="19" x2="16" y2="22"/>
      <line x1="19" y1="16" x2="22" y2="16"/>
    </svg>
  </button>
  <div id="ganttChildConnectorsContainer"></div>
  <div class="gantt-bar-tooltip" id="ganttBarTooltip" role="tooltip">
    <div class="gantt-bar-tooltip-title"></div>
    <div class="gantt-bar-tooltip-row gantt-bar-tooltip-desc">
      <span class="gantt-bar-tooltip-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M16 13H8"/><path d="M16 17H8"/><path d="M10 9H8"/></svg></span>
      <span class="gantt-bar-tooltip-text"></span>
    </div>
    <div class="gantt-bar-tooltip-row gantt-bar-tooltip-party">
      <span class="gantt-bar-tooltip-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg></span>
      <span class="gantt-bar-tooltip-text"></span>
    </div>
    <div class="gantt-bar-tooltip-row gantt-bar-tooltip-depends">
      <span class="gantt-bar-tooltip-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/><path d="M12 5l7 7-7 7"/></svg></span>
      <span class="gantt-bar-tooltip-text"></span>
      <span class="gantt-bar-tooltip-dep-unlink-wrap" style="display:none"><button type="button" class="gantt-bar-tooltip-dep-unlink" title="Unlink" aria-label="Unlink"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/><path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/><line x1="8" y1="2" x2="8" y2="5"/><line x1="2" y1="8" x2="5" y2="8"/><line x1="16" y1="19" x2="16" y2="22"/><line x1="19" y1="16" x2="22" y2="16"/></svg></button></span>
    </div>
    <div class="gantt-bar-tooltip-row gantt-bar-tooltip-dates">
      <span class="gantt-bar-tooltip-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><path d="M16 2v4"/><path d="M8 2v4"/><path d="M3 10h18"/></svg></span>
      <span class="gantt-bar-tooltip-text"></span>
    </div>
    <div class="gantt-bar-tooltip-actions" id="ganttBarTooltipActions" style="display:none">
      <label class="gantt-bar-tooltip-move-label">Move to phase</label>
      <div class="gantt-phase-dropdown gantt-bar-tooltip-phase-dropdown" id="ganttBarTooltipPhaseDropdown"></div>
    </div>
  </div>

  <div class="gantt-toast" id="ganttToast" role="status" aria-live="polite"></div>
  <div class="gantt-drag-guide" id="ganttDragGuide" aria-hidden="true"></div>
  <div class="gantt-wrapper" id="ganttWrapper">
    <div class="gantt-grid" id="ganttGrid">
      <div class="gantt-header-sticky">
        <!-- Phase header: dynamic spans based on task duration (populated by JS) -->
        <div class="phase-header-row" id="phaseHeaderRow"></div>
        <!-- Main header row -->
        <div class="gantt-row gantt-header" id="ganttHeaderRow" style="cursor:default">
          <div class="gantt-cell">Task</div>
          <div class="gantt-cell">Phase</div>
          <div class="gantt-cell">Responsible</div>
          <div class="gantt-cell">Date</div>
          <!-- Week labels populated by JS -->
        </div>
      </div>
      <svg class="gantt-dependency-line gantt-all-dependency-lines" id="ganttAllDependencyLines" aria-hidden="true"></svg>
      <!-- Data rows populated by JS -->
    </div>
    <div id="ganttEmptyState" class="gantt-empty-state hidden" aria-live="polite">
      <span class="empty-title">No tasks yet</span>
      <p>Configure phases and settings, or add sample tasks to explore the chart.</p>
      <div class="gantt-empty-state-actions">
        <button type="button" class="btn-empty-primary" id="ganttEmptyConfigure">Configure project</button>
        <button type="button" class="btn-empty-secondary" id="ganttEmptyPopulate">Add sample tasks</button>
      </div>
    </div>
  </div>
  </div><!-- /#ganttView -->
  </div><!-- /.app-views-wrap -->

  <div class="gantt-auth-modal-overlay" id="ganttAuthModalOverlay">
    <div class="gantt-auth-modal">
      <div class="auth-config-section" id="ganttAuthConfigSection">
        <h3 id="ganttAuthConfigTitle">Connect to Supabase</h3>
        <p style="font-size: 13px; color: var(--text-secondary); margin: 0 0 12px 0;">Enter your project URL and anon key from Supabase Dashboard  Settings  API.</p>
        <label for="ganttAuthConfigUrl">Project URL</label>
        <input type="url" id="ganttAuthConfigUrl" placeholder="https://xxxxx.supabase.co" autocomplete="off" />
        <label for="ganttAuthConfigAnonKey">Anon key</label>
        <input type="text" id="ganttAuthConfigAnonKey" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6..." autocomplete="off" />
        <div class="auth-actions">
          <button type="button" class="gantt-auth-btn" id="ganttAuthConfigSave">Save & continue</button>
          <button type="button" class="gantt-auth-btn" id="ganttAuthCancelConfig">Cancel</button>
        </div>
      </div>
      <div class="auth-login-section hidden" id="ganttAuthLoginSection">
        <h3 id="ganttAuthModalTitle">Log in</h3>
        <form id="ganttAuthLoginForm" name="login" method="post" action="#" autocomplete="on" onsubmit="return false;" aria-label="Log in or sign up">
          <input type="email" id="ganttAuthEmail" name="email" placeholder="Email" autocomplete="email" />
          <input type="password" id="ganttAuthPassword" name="password" placeholder="Password" autocomplete="current-password" />
          <label class="auth-remember">
            <input type="checkbox" id="ganttAuthRemember" checked />
            <span>Remember me</span>
          </label>
          <div class="auth-actions">
            <button type="button" class="gantt-auth-btn gantt-auth-btn-primary" id="ganttAuthSubmit">Log in</button>
            <button type="button" class="gantt-auth-btn gantt-auth-btn-secondary" id="ganttAuthSignupSubmit">Sign up</button>
          </div>
        </form>
        <div class="auth-use-different"><button type="button" id="ganttAuthShowConfig">Use different Supabase project</button></div>
      </div>
      <div class="auth-error" id="ganttAuthError" role="alert"></div>
    </div>
  </div>

  <!-- Load config from config.js (copy config.example.js to config.js and add your Supabase URL + anon key) -->
  <script src="config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <script src="supabase-storage.js"></script>
  <script>
    const DEFAULT_WEEK_START = new Date(2026, 1, 2); // Feb 2, 2026
    const WEEK_MS = 7 * 24 * 60 * 60 * 1000;
    let WEEK_START = new Date(DEFAULT_WEEK_START);
    let WEEKS = 8;

    const DEFAULT_PHASES = [
      { id: "discovery", name: "Discovery", color: "#EAB308" },
      { id: "ideation", name: "Ideation", color: "#0D9488" },
      { id: "development", name: "Development", color: "#0284C7" },
      { id: "review", name: "Review", color: "#14B8A6" },
      { id: "delivery", name: "Delivery", color: "#6366F1" }
    ];
    const COLOR_PALETTES = [
      { name: "Teal", colors: ["#EAB308", "#0D9488", "#0284C7", "#14B8A6", "#6366F1"] },
      { name: "Warm", colors: ["#EFCA08", "#305252", "#F78154", "#96C5B0", "#9E4770"] },
      { name: "Ocean", colors: ["#0EA5E9", "#0284C7", "#0369A1", "#0C4A6E", "#164E63"] },
      { name: "Sunset", colors: ["#F97316", "#E11D48", "#A21CAF", "#7C3AED", "#4F46E5"] },
      { name: "Forest", colors: ["#22C55E", "#16A34A", "#15803D", "#166534", "#14532D"] },
      { name: "Slate", colors: ["#64748B", "#475569", "#334155", "#1E293B", "#0F172A"] }
    ];
    let PHASES = [...DEFAULT_PHASES.map(p => ({ ...p }))];

    const PROJECTS_LIST_KEY = "gantt-projects";
    function getCustomPalettesKey() {
      return "gantt-custom-palettes-" + (currentProjectId || "default");
    }
    let currentProjectId = null;
    let homeEditProjectId = null;

    function slugify(text) {
      return String(text || "")
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "") || "project";
    }
    function getProjectUrl(project) {
      const id = project?.id;
      if (id && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) return "#/project/" + id;
      return "#/project/" + slugify(project?.name || "project");
    }
    function getProjectIdFromHash() {
      const hash = typeof location !== "undefined" ? (location.hash || "").replace(/^#\/?/, "") : "";
      const m = /^project\/(.+)$/.exec(hash);
      if (!m) return null;
      const segment = m[1];
      const projects = loadProjectsList();
      if (projects.some(p => p.id === segment)) return segment;
      if (/^(p-\d+|default)$/.test(segment)) return segment;
      const bySlug = projects.find(p => slugify(p.name) === segment);
      return bySlug ? bySlug.id : null;
    }
    function getCacheKey() {
      return currentProjectId ? "gantt-tasks-" + currentProjectId : "gantt-tasks-default";
    }
    function getSettingsKey() {
      return currentProjectId ? "gantt-settings-" + currentProjectId : "gantt-settings-default";
    }
    function getViewKey() {
      return currentProjectId ? "gantt-view-" + currentProjectId : "gantt-view-default";
    }
    const VIEW_ORDER = ["sprint", "month", "default", "project"];
    function loadProjectsListLocal() {
      try {
        const raw = localStorage.getItem(PROJECTS_LIST_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch { return []; }
    }
    function saveProjectsListLocal(list) {
      try {
        localStorage.setItem(PROJECTS_LIST_KEY, JSON.stringify(list));
      } catch (e) { console.warn("Could not save projects list:", e); }
    }
    function loadProjectsList() {
      if (window.ganttStorage?.isCloudEnabled()) return window.ganttStorage.loadProjectsList() ?? [];
      return loadProjectsListLocal();
    }
    function saveProjectsList(list) {
      if (window.ganttStorage?.isCloudEnabled()) { window.ganttStorage.saveProjectsList(list); return; }
      saveProjectsListLocal(list);
    }
    function isProjectNameTaken(name, excludeProjectId) {
      if (!name || typeof name !== "string") return false;
      const normalized = name.trim().toLowerCase();
      if (!normalized) return false;
      const list = loadProjectsList();
      return list.some(p => p.id !== excludeProjectId && (p.name || "").trim().toLowerCase() === normalized);
    }
    function getUniqueProjectName(baseName) {
      const base = (baseName || "Untitled project").trim() || "Untitled project";
      if (!isProjectNameTaken(base, null)) return base;
      let n = 2;
      while (isProjectNameTaken(base + " " + n, null)) n++;
      return base + " " + n;
    }
    function ensureProjectInList(id, name) {
      const list = loadProjectsList();
      const i = list.findIndex(p => p.id === id);
      if (i >= 0) {
        if (name != null && !isProjectNameTaken(name, id)) list[i].name = name.trim() || list[i].name;
        saveProjectsList(list);
        return;
      }
      const finalName = getUniqueProjectName(name || "Untitled project");
      list.push({ id, name: finalName, createdAt: Date.now() });
      saveProjectsList(list);
    }
    function duplicateProject(sourceId) {
      pushProjectsListUndo();
      const list = loadProjectsList();
      const source = list.find(proj => proj.id === sourceId);
      const sourceName = source?.name || "Untitled project";
      const suggestedCopyName = sourceName.trim().toLowerCase().endsWith(" copy")
        ? sourceName + " (2)"
        : sourceName + " copy";
      const copyName = getUniqueProjectName(suggestedCopyName);
      if (window.ganttStorage?.isCloudEnabled()) {
        return window.ganttStorage.duplicateBoard(sourceId, copyName).then(() => {
          if (typeof renderHomeView === "function") renderHomeView();
        });
      }
      const newId = "p-" + Date.now();
      try {
        const tasksRaw = localStorage.getItem("gantt-tasks-" + sourceId);
        const settingsRaw = localStorage.getItem("gantt-settings-" + sourceId);
        const viewRaw = localStorage.getItem("gantt-view-" + sourceId);
        const palettesRaw = localStorage.getItem("gantt-custom-palettes-" + sourceId);
        if (tasksRaw) localStorage.setItem("gantt-tasks-" + newId, tasksRaw);
        if (settingsRaw) {
          const s = JSON.parse(settingsRaw);
          const s2 = { ...s, title: copyName, description: s.description || "" };
          localStorage.setItem("gantt-settings-" + newId, JSON.stringify(s2));
        } else {
          localStorage.setItem("gantt-settings-" + newId, JSON.stringify({ title: copyName, description: "" }));
        }
        if (viewRaw) localStorage.setItem("gantt-view-" + newId, viewRaw);
        if (palettesRaw) localStorage.setItem("gantt-custom-palettes-" + newId, palettesRaw);
      } catch (e) { console.warn("Could not copy project data:", e); }
      ensureProjectInList(newId, copyName);
    }

    function getProjectPhases(projectId) {
      if (window.ganttStorage?.isCloudEnabled()) {
        const s = window.ganttStorage.loadSettings(projectId);
        if (s?.phases && Array.isArray(s.phases)) return s.phases;
      }
      try {
        const raw = localStorage.getItem("gantt-settings-" + projectId);
        const s = raw ? JSON.parse(raw) : null;
        const phases = (s?.phases && Array.isArray(s.phases)) ? s.phases : DEFAULT_PHASES.map(p => ({ ...p }));
        return phases;
      } catch { return DEFAULT_PHASES.map(p => ({ ...p })); }
    }

    function getProjectTasksForPreview(projectId) {
      try {
        let tasks = [];
        if (window.ganttStorage?.isCloudEnabled()) {
          const list = window.ganttStorage.loadTasks(projectId);
          tasks = Array.isArray(list) ? list : [];
        } else {
          const tasksRaw = localStorage.getItem("gantt-tasks-" + projectId);
          const list = tasksRaw ? JSON.parse(tasksRaw) : [];
          tasks = Array.isArray(list) ? list : [];
        }
        const phases = getProjectPhases(projectId);
        const phaseMap = new Map(phases.map(p => [p.id, p.color || "#737373"]));
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayMs = today.getTime();
        return tasks
          .filter(t => t.startDate && t.endDate)
          .map(t => {
            const start = new Date(t.startDate);
            const end = new Date(t.endDate);
            start.setHours(0, 0, 0, 0);
            end.setHours(0, 0, 0, 0);
            const phaseId = t.phase || phases[0]?.id;
            const color = phaseMap.get(phaseId) || phases[0]?.color || "#737373";
            const isCurrent = todayMs >= start.getTime() && todayMs <= end.getTime();
            const taskName = (t.task && String(t.task).trim()) || "Task";
            return { start, end, color, isCurrent, task: taskName };
          });
      } catch { return []; }
    }

    function getProjectStrokeMode(projectId) {
      if (window.ganttStorage?.isCloudEnabled()) {
        const s = window.ganttStorage.loadSettings(projectId);
        if (s) return !!s.strokeMode;
      }
      try {
        const raw = localStorage.getItem("gantt-settings-" + projectId);
        const s = raw ? JSON.parse(raw) : null;
        return !!s?.strokeMode;
      } catch { return false; }
    }

    function renderHomeTimelinePreview(projectId, containerEl) {
      containerEl.innerHTML = "";
      const bars = getProjectTasksForPreview(projectId);
      if (bars.length === 0) {
        containerEl.classList.add("home-timeline-empty");
        return;
      }
      containerEl.classList.remove("home-timeline-empty");
      const strokeMode = getProjectStrokeMode(projectId);
      const minT = Math.min(...bars.map(b => b.start.getTime()));
      const maxT = Math.max(...bars.map(b => b.end.getTime()));
      const range = Math.max(maxT - minT, 1);
      const labelW = 34;
      const barW = 100;
      const w = labelW + barW;
      const h = 70;
      const rowH = 6;
      const rowGap = 1;
      const padTop = 10;
      const numBars = Math.min(24, bars.length);
      const maxRows = Math.max(1, Math.floor((h - padTop - 4) / (rowH + rowGap)));
      const usedRows = Math.min(maxRows, numBars);
      const contentHeight = usedRows * rowH + (usedRows - 1) * rowGap;
      const padY = padTop;
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 " + w + " " + h);
      svg.setAttribute("preserveAspectRatio", "xMidYMid slice");
      svg.setAttribute("class", "home-timeline-svg");
      svg.setAttribute("aria-hidden", "true");
      for (let r = 0; r <= usedRows; r++) {
        const gy = padY + r * (rowH + rowGap);
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", String(labelW));
        line.setAttribute("y1", gy.toFixed(1));
        line.setAttribute("x2", String(w));
        line.setAttribute("y2", gy.toFixed(1));
        line.setAttribute("stroke", "currentColor");
        line.setAttribute("stroke-opacity", "0.2");
        line.setAttribute("stroke-width", "0.4");
        svg.appendChild(line);
      }
      bars.slice(0, 24).forEach((b, i) => {
        const row = i % maxRows;
        const barX = labelW + Math.max(0, ((b.start.getTime() - minT) / range) * (barW - 2));
        const bw = Math.max(2, ((b.end.getTime() - b.start.getTime()) / range) * (barW - 2));
        const y = padY + row * (rowH + rowGap);
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", barX.toFixed(1));
        rect.setAttribute("y", y.toFixed(1));
        rect.setAttribute("width", bw.toFixed(1));
        rect.setAttribute("height", rowH);
        rect.setAttribute("rx", "1.5");
        if (!b.isCurrent) rect.setAttribute("opacity", "0.32");
        if (strokeMode) {
          rect.setAttribute("fill", hexToRgba(b.color, 0.16));
          rect.setAttribute("stroke", b.color);
          rect.setAttribute("stroke-width", "0.3");
        } else {
          rect.setAttribute("fill", b.color);
        }
        svg.appendChild(rect);
      });
      const labelMaxLen = 12;
      bars.slice(0, 24).forEach((b, i) => {
        const row = i % maxRows;
        const y = padY + row * (rowH + rowGap) + rowH / 2 + 1;
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", "2");
        text.setAttribute("y", y.toFixed(1));
        text.setAttribute("font-size", "3.2");
        text.setAttribute("fill", "currentColor");
        text.setAttribute("text-anchor", "start");
        text.setAttribute("dominant-baseline", "middle");
        if (!b.isCurrent) text.setAttribute("opacity", "0.32");
        const label = b.task.length > labelMaxLen ? b.task.substring(0, labelMaxLen) + "" : b.task;
        text.textContent = label;
        svg.appendChild(text);
      });
      containerEl.appendChild(svg);
    }

    function loadCustomPalettes() {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        const raw = window.ganttStorage.loadCustomPalettes(currentProjectId);
        if (raw != null) return Array.isArray(raw) ? raw : [];
      }
      try {
        const raw = localStorage.getItem(getCustomPalettesKey());
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch { return []; }
    }
    function saveCustomPalettes(palettes) {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        window.ganttStorage.saveCustomPalettes(currentProjectId, palettes);
        return;
      }
      try {
        localStorage.setItem(getCustomPalettesKey(), JSON.stringify(palettes));
      } catch (e) { console.warn("Could not save custom palettes:", e); }
    }
    function getSavedView() {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        const v = window.ganttStorage.loadView(currentProjectId);
        if (v != null) return v;
      }
      return localStorage.getItem(getViewKey());
    }
    function setSavedView(view) {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        window.ganttStorage.saveView(currentProjectId, view);
        return;
      }
      localStorage.setItem(getViewKey(), view);
    }
    const DEFAULT_PAGE_TITLE = "Project Schedule";
    const DEFAULT_PAGE_DESCRIPTION = "Drag bars to reschedule  Drag edges to change dates  Drag rows to reorder  Click a row to expand details  Click cells to edit";

    function loadProjectSettings() {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        const s = window.ganttStorage.loadSettings(currentProjectId);
        if (s != null) return s;
      }
      try {
        const raw = localStorage.getItem(getSettingsKey());
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }
    function saveProjectSettings(settings) {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        window.ganttStorage.saveSettings(currentProjectId, settings);
        return;
      }
      try {
        localStorage.setItem(getSettingsKey(), JSON.stringify(settings));
      } catch (e) { console.warn("Could not save project settings:", e); }
    }
    const JIRA_BASE_URL = ""; // e.g. "https://your-team.atlassian.net"  leave empty to only linkify full URLs
    const DEFAULT_TASKS = [
      { task: "Benchmarking", phase: "discovery", party: "Graham", start: "2/3", end: "2/12", startDate: new Date(2026, 1, 3), endDate: new Date(2026, 1, 12), star: false },
      { task: "Internal Design Audit", phase: "discovery", party: "Kaylan", start: "2/3", end: "2/12", startDate: new Date(2026, 1, 3), endDate: new Date(2026, 1, 12), star: false },
      { task: "Foundations Audit - Content - Strat", phase: "discovery", party: "Charlie", start: "2/3", end: "2/12", startDate: new Date(2026, 1, 3), endDate: new Date(2026, 1, 12), star: false },
      { task: "Principle Workshop & Full team alignment", phase: "ideation", party: "Full Team", start: "2/10", end: "2/10", startDate: new Date(2026, 1, 10), endDate: new Date(2026, 1, 10), star: false },
      { task: "Draft 1: Internal Review & Working Session", phase: "development", party: "Kettle Team", start: "2/18", end: "2/18", startDate: new Date(2026, 1, 18), endDate: new Date(2026, 1, 18), star: false },
      { task: "Full Team Review", phase: "review", party: "Full Team", start: "2/19", end: "2/19", startDate: new Date(2026, 1, 19), endDate: new Date(2026, 1, 19), star: false },
      { task: "Draft 2: Edits", phase: "development", party: "Kettle Team", start: "2/19", end: "2/24", startDate: new Date(2026, 1, 19), endDate: new Date(2026, 1, 24), star: false },
      { task: "Bethany Review & Principle Validation", phase: "review", party: "Full Team", start: "2/25", end: "2/25", startDate: new Date(2026, 1, 25), endDate: new Date(2026, 1, 25), star: true },
      { task: "Draft 3: Bethany Feedback Implemented", phase: "development", party: "Kettle Team", start: "2/26", end: "3/2", startDate: new Date(2026, 1, 26), endDate: new Date(2026, 2, 2), star: false },
      { task: "Sailesh Review & Principle Validation", phase: "review", party: "Full Team", start: "3/3", end: "3/3", startDate: new Date(2026, 2, 3), endDate: new Date(2026, 2, 3), star: true },
      { task: "Draft 4: Sailesh Feedback Implemented", phase: "development", party: "Kettle Team", start: "3/5", end: "3/5", startDate: new Date(2026, 2, 5), endDate: new Date(2026, 2, 5), star: false },
      { task: "Formatting content/guidelines into the documentation template", phase: "development", party: "Kettle Team", start: "3/5", end: "3/16", startDate: new Date(2026, 2, 5), endDate: new Date(2026, 2, 16), star: false },
      { task: "Approval of Guidelines", phase: "delivery", party: "Full Team + VP", start: "", end: "", startDate: null, endDate: null, star: false }
    ];

    let tasks = [];

    function parseTaskRow(t) {
      const links = Array.isArray(t.links) ? t.links : (Array.isArray(t.dependencies) ? t.dependencies : []);
      const migratedLinks = (t.jiraTicket && t.jiraTicket.trim()) ? [t.jiraTicket.trim(), ...links] : links;
      const startDate = t.startDate ? new Date(t.startDate) : null;
      const endDate = t.endDate ? new Date(t.endDate) : null;
      return {
        ...t,
        startDate,
        endDate,
        start: t.start || (startDate ? formatDate(startDate) : ""),
        end: t.end || (endDate ? formatDate(endDate) : ""),
        overview: t.overview || "",
        subTasks: Array.isArray(t.subTasks) ? t.subTasks : [],
        blockers: Array.isArray(t.blockers) ? t.blockers : [],
        links: migratedLinks,
        dependsOn: typeof t.dependsOn === "number" ? t.dependsOn : null,
        phaseSecondary: t.phaseSecondary && t.phaseSecondary !== t.phase ? t.phaseSecondary : null
      };
    }
    function loadTasks() {
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        const raw = window.ganttStorage.loadTasks(currentProjectId);
        if (raw != null) return Array.isArray(raw) ? raw.map(parseTaskRow) : [];
      }
      try {
        const raw = localStorage.getItem(getCacheKey());
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return parsed.map(parseTaskRow);
      } catch {
        return [];
      }
    }

    function saveTasks() {
      const toSave = tasks.map(t => ({
        task: t.task,
        phase: t.phase,
        phaseSecondary: t.phaseSecondary || null,
        party: t.party,
        start: t.start,
        end: t.end,
        startDate: t.startDate ? t.startDate.toISOString() : null,
        endDate: t.endDate ? t.endDate.toISOString() : null,
        star: t.star,
        overview: t.overview || "",
        subTasks: t.subTasks || [],
        blockers: t.blockers || [],
        links: t.links || [],
        dependsOn: typeof t.dependsOn === "number" ? t.dependsOn : null
      }));
      if (window.ganttStorage?.isCloudEnabled() && currentProjectId) {
        window.ganttStorage.saveTasks(currentProjectId, toSave);
        return;
      }
      try {
        localStorage.setItem(getCacheKey(), JSON.stringify(toSave));
      } catch (e) {
        console.warn("Could not save tasks:", e);
      }
    }

    const UNDO_MAX = 50;
    let undoStack = [];
    let redoStack = [];
    let isUndoRedoInProgress = false;

    function getTasksSnapshot() {
      const toSave = tasks.map(t => ({
        task: t.task,
        phase: t.phase,
        phaseSecondary: t.phaseSecondary || null,
        party: t.party,
        start: t.start,
        end: t.end,
        startDate: t.startDate ? t.startDate.toISOString() : null,
        endDate: t.endDate ? t.endDate.toISOString() : null,
        star: t.star,
        overview: t.overview || "",
        subTasks: t.subTasks || [],
        blockers: t.blockers || [],
        links: t.links || [],
        dependsOn: typeof t.dependsOn === "number" ? t.dependsOn : null
      }));
      return JSON.stringify(toSave);
    }

    function parseTasksFromSave(jsonStr) {
      try {
        const parsed = JSON.parse(jsonStr);
        if (!Array.isArray(parsed)) return [];
        return parsed.map(t => {
          const links = Array.isArray(t.links) ? t.links : (Array.isArray(t.dependencies) ? t.dependencies : []);
          const startDate = t.startDate ? new Date(t.startDate) : null;
          const endDate = t.endDate ? new Date(t.endDate) : null;
          return {
            ...t,
            startDate,
            endDate,
            start: t.start || (startDate ? formatDate(startDate) : ""),
            end: t.end || (endDate ? formatDate(endDate) : ""),
            overview: t.overview || "",
            subTasks: Array.isArray(t.subTasks) ? t.subTasks : [],
            blockers: Array.isArray(t.blockers) ? t.blockers : [],
            links,
            dependsOn: typeof t.dependsOn === "number" ? t.dependsOn : null,
            phaseSecondary: t.phaseSecondary && t.phaseSecondary !== t.phase ? t.phaseSecondary : null
          };
        });
      } catch { return []; }
    }

    function pushUndo(entry) {
      if (isUndoRedoInProgress) return;
      redoStack = [];
      undoStack.push(entry);
      if (undoStack.length > UNDO_MAX) undoStack.shift();
    }

    function pushTasksUndo() {
      if (!currentProjectId) return;
      pushUndo({ type: "tasks", projectId: currentProjectId, prev: getTasksSnapshot() });
    }

    function pushProjectsListUndo() {
      pushUndo({ type: "projectsList", prev: JSON.stringify(loadProjectsList()) });
    }

    function performUndo() {
      if (undoStack.length === 0) return;
      const entry = undoStack.pop();
      isUndoRedoInProgress = true;
      try {
        if (entry.type === "tasks" && entry.projectId === currentProjectId) {
          const nextSnapshot = getTasksSnapshot();
          tasks.length = 0;
          tasks.push(...parseTasksFromSave(entry.prev));
          saveTasks();
          redoStack.push({ type: "tasks", projectId: currentProjectId, prev: nextSnapshot });
          if (typeof updateChartRange === "function") updateChartRange();
          if (typeof renderTasks === "function") renderTasks();
          if (typeof updateEmptyState === "function") updateEmptyState();
        } else if (entry.type === "projectsList") {
          const next = JSON.stringify(loadProjectsList());
          const list = JSON.parse(entry.prev);
          const idsBefore = new Set(list.map((x) => x.id));
          saveProjectsList(list);
          redoStack.push({ type: "projectsList", prev: next });
          if (currentProjectId && !idsBefore.has(currentProjectId)) {
            if (typeof location !== "undefined") location.hash = "#/";
          }
          if (typeof renderHomeView === "function" && !currentProjectId) renderHomeView();
        } else if (entry.type === "tasks") {
          undoStack.push(entry);
        }
      } finally {
        isUndoRedoInProgress = false;
      }
    }

    function performRedo() {
      if (redoStack.length === 0) return;
      const entry = redoStack.pop();
      isUndoRedoInProgress = true;
      try {
        if (entry.type === "tasks" && entry.projectId === currentProjectId) {
          const nextSnapshot = getTasksSnapshot();
          tasks.length = 0;
          tasks.push(...parseTasksFromSave(entry.prev));
          saveTasks();
          undoStack.push({ type: "tasks", projectId: currentProjectId, prev: nextSnapshot });
          if (typeof updateChartRange === "function") updateChartRange();
          if (typeof renderTasks === "function") renderTasks();
          if (typeof updateEmptyState === "function") updateEmptyState();
        } else if (entry.type === "projectsList") {
          const next = JSON.stringify(loadProjectsList());
          const list = JSON.parse(entry.prev);
          const idsAfter = new Set(list.map((x) => x.id));
          saveProjectsList(list);
          undoStack.push({ type: "projectsList", prev: next });
          if (currentProjectId && !idsAfter.has(currentProjectId)) {
            if (typeof location !== "undefined") location.hash = "#/";
          }
          if (typeof renderHomeView === "function" && !currentProjectId) renderHomeView();
        } else {
          redoStack.push(entry);
        }
      } finally {
        isUndoRedoInProgress = false;
      }
    }

    function wouldCreateCycle(dependentIdx, primaryIdx) {
      const seen = new Set();
      let curr = primaryIdx;
      while (curr !== null && curr !== undefined && !seen.has(curr)) {
        if (curr === dependentIdx) return true;
        seen.add(curr);
        const t = tasks[curr];
        curr = typeof t?.dependsOn === "number" ? t.dependsOn : null;
      }
      return false;
    }
    function getDependencyGapDays() {
      const s = loadProjectSettings();
      const n = parseInt(s?.dependencyGapDays, 10);
      return isNaN(n) || n < 0 ? 0 : n;
    }
    function getAllowIndependentDependencies() {
      const s = loadProjectSettings();
      return !!s?.allowIndependentDependencies;
    }
    function getProjectStartDate() {
      const s = loadProjectSettings();
      const raw = s?.projectStartDate;
      if (!raw || typeof raw !== "string") return null;
      const parts = raw.trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (!parts) return null;
      const d = new Date(parseInt(parts[1], 10), parseInt(parts[2], 10) - 1, parseInt(parts[3], 10));
      return isNaN(d.getTime()) ? null : d;
    }
    function getProjectEndDate() {
      const s = loadProjectSettings();
      const raw = s?.projectEndDate;
      if (!raw || typeof raw !== "string") return null;
      const parts = raw.trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (!parts) return null;
      const d = new Date(parseInt(parts[1], 10), parseInt(parts[2], 10) - 1, parseInt(parts[3], 10));
      return isNaN(d.getTime()) ? null : d;
    }
    let lastBarChangeOriginalDurationMs = null;
    let lastBarChangeTaskIndex = null;
    let lastBarChangeOriginalStartDate = null;
    let lastBarChangeOriginalEndDate = null;
    let selectedBarIndex = null;
    let selectedBarElement = null;
    let selectedBarClickOutside = null;
    let selectedBarDepLineCleanup = null;
    function updateBarPosition(barElement, taskIndex) {
      if (!barElement) return;
      const task = tasks[taskIndex];
      if (!task || !task.startDate || !task.endDate) return;
      const startOffset = Math.max(0, dateToOffset(task.startDate));
      let endOffset = dateToOffset(task.endDate);
      if (endOffset <= startOffset) endOffset = startOffset + 1/7;
      endOffset = Math.min(WEEKS, endOffset);
      barElement.style.left = (startOffset / WEEKS) * 100 + "%";
      barElement.style.width = ((endOffset - startOffset) / WEEKS) * 100 + "%";
      setBarPhaseStyle(barElement, task);
      const row = document.querySelector(`.gantt-row[data-index="${taskIndex}"]`);
      if (row) {
        const startInp = row.querySelector('.gantt-date-start');
        const endInp = row.querySelector('.gantt-date-end');
        if (startInp) startInp.value = task.start;
        if (endInp) endInp.value = task.end;
      }
    }

    function propagateDependencyChanges(primaryIndex, visited, durationOverride, updateVisuals) {
      if (getAllowIndependentDependencies()) return;
      if (visited && visited.has(primaryIndex)) return;
      const seen = visited || new Set();
      seen.add(primaryIndex);
      const primary = tasks[primaryIndex];
      if (!primary || !primary.endDate) return;
      const gapMs = getDependencyGapDays() * 24 * 60 * 60 * 1000;
      const dependentStartBase = new Date(primary.endDate.getTime() + gapMs);
      tasks.forEach((t, i) => {
        if (t.dependsOn === primaryIndex && t.startDate && t.endDate) {
          const durationMs = (durationOverride && durationOverride.taskIndex === i)
            ? durationOverride.durationMs
            : (t.endDate.getTime() - t.startDate.getTime());
          t.startDate = new Date(dependentStartBase);
          t.endDate = new Date(dependentStartBase.getTime() + durationMs);
          t.start = formatDate(t.startDate);
          t.end = formatDate(t.endDate);
          if (updateVisuals) {
            const bar = document.querySelector(`.gantt-bar[data-index="${i}"]`);
            updateBarPosition(bar, i);
          }
          propagateDependencyChanges(i, seen, undefined, updateVisuals);
        }
      });
    }

    function loadPageHeader() {
      const s = loadProjectSettings();
      if (s) return { title: s.title || DEFAULT_PAGE_TITLE, description: s.description || DEFAULT_PAGE_DESCRIPTION };
      return { title: DEFAULT_PAGE_TITLE, description: DEFAULT_PAGE_DESCRIPTION };
    }
    function savePageHeader(title, description) {
      const s = loadProjectSettings() || {};
      saveProjectSettings({ ...s, title: title || DEFAULT_PAGE_TITLE, description: description || DEFAULT_PAGE_DESCRIPTION });
    }
    function formatDate(d) {
      if (!d) return "";
      return (d.getMonth() + 1) + "/" + d.getDate();
    }

    function parseDateStr(str) {
      if (!str || !str.trim()) return null;
      const s = str.trim().replace(/\s*-\s*/g, "-");
      const parts = s.split("-");
      const parsePart = (p) => {
        const m = p.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?$/);
        if (m) {
          const month = parseInt(m[1], 10) - 1;
          const day = parseInt(m[2], 10);
          const year = m[3] ? parseInt(m[3], 10) : 2026;
          const yr = year < 100 ? 2000 + year : year;
          return new Date(yr, month, day);
        }
        const d = new Date(p);
        return isNaN(d.getTime()) ? null : d;
      };
      const start = parsePart(parts[0].trim());
      if (!start) return null;
      const end = parts[1] ? parsePart(parts[1].trim()) : start;
      return { start, end: end || start };
    }

    function toDateInputValue(d) {
      if (!d) return "";
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    let toastTimer = null;
    function showToast(message, options) {
      const el = document.getElementById("ganttToast");
      if (!el) return;
      if (toastTimer) clearTimeout(toastTimer);
      el.classList.remove("error");
      if (options?.type === "error") el.classList.add("error");
      el.innerHTML = message;
      if (options?.onUndo && typeof options.onUndo === "function") {
        const undoBtn = document.createElement("button");
        undoBtn.type = "button";
        undoBtn.className = "gantt-toast-undo";
        undoBtn.textContent = "Undo";
        undoBtn.addEventListener("click", () => {
          if (toastTimer) clearTimeout(toastTimer);
          toastTimer = null;
          el.classList.remove("visible");
          options.onUndo();
        });
        el.appendChild(undoBtn);
      }
      el.classList.add("visible");
      toastTimer = setTimeout(() => {
        el.classList.remove("visible");
        toastTimer = null;
      }, 2500);
    }

    function dateToOffset(date) {
      return (date - WEEK_START) / WEEK_MS;
    }

    function offsetToDate(offset) {
      return new Date(WEEK_START.getTime() + offset * WEEK_MS);
    }

    const SPRINT_DAYS = 14;
    const SNAP_THRESHOLD_DAYS = 2;
    const DAY_MS = 24 * 60 * 60 * 1000;

    function getSprintSnapBase() {
      const base = getProjectStartDate() || WEEK_START;
      return new Date(base.getFullYear(), base.getMonth(), base.getDate());
    }

    function wouldSnapToSprint(date) {
      const s = loadProjectSettings();
      const snapEnabled = s == null ? true : !!s.snapToSprint;
      if (!snapEnabled || !date) return false;
      const base = getSprintSnapBase();
      const baseMs = base.getTime();
      const dateMs = date.getTime();
      const daysFromBase = (dateMs - baseMs) / DAY_MS;
      for (let n = -1; n <= Math.ceil(daysFromBase / SPRINT_DAYS) + 1; n++) {
        const sprintStartMs = baseMs + n * SPRINT_DAYS * DAY_MS;
        const sprintEndMs = sprintStartMs + (SPRINT_DAYS - 1) * DAY_MS;
        const distStart = Math.abs(dateMs - sprintStartMs) / DAY_MS;
        const distEnd = Math.abs(dateMs - sprintEndMs) / DAY_MS;
        if (distStart <= SNAP_THRESHOLD_DAYS || distEnd <= SNAP_THRESHOLD_DAYS) {
          return true;
        }
      }
      return false;
    }

    function getSprintBoundaryInfo(date) {
      const s = loadProjectSettings();
      const snapEnabled = s == null ? true : !!s.snapToSprint;
      if (!snapEnabled || !date) return null;
      const base = getSprintSnapBase();
      const baseMs = base.getTime();
      const dateMs = date.getTime();
      const daysFromBase = (dateMs - baseMs) / DAY_MS;
      let bestBoundary = null;
      let bestDist = SNAP_THRESHOLD_DAYS + 1;
      let bestType = null;
      for (let n = -1; n <= Math.ceil(daysFromBase / SPRINT_DAYS) + 1; n++) {
        const sprintStartMs = baseMs + n * SPRINT_DAYS * DAY_MS;
        const sprintEndMs = sprintStartMs + (SPRINT_DAYS - 1) * DAY_MS;
        const distStart = Math.abs(dateMs - sprintStartMs) / DAY_MS;
        const distEnd = Math.abs(dateMs - sprintEndMs) / DAY_MS;
        if (distStart <= SNAP_THRESHOLD_DAYS && distStart < bestDist) {
          bestDist = distStart;
          bestBoundary = sprintStartMs;
          bestType = "start";
        }
        if (distEnd <= SNAP_THRESHOLD_DAYS && distEnd < bestDist) {
          bestDist = distEnd;
          bestBoundary = sprintEndMs;
          bestType = "end";
        }
      }
      if (bestBoundary != null) {
        return { date: new Date(bestBoundary), type: bestType };
      }
      return null;
    }

    function snapDateToSprint(date) {
      const info = getSprintBoundaryInfo(date);
      return info ? info.date : date;
    }

    function getFixedPhaseTotalWeeks() {
      const s = loadProjectSettings();
      if (s?.phaseDurationMode === "dynamic") return null;
      return PHASES.reduce((sum, p) => sum + (Math.max(1, parseInt(p.sprints, 10) || 2) * 2), 0);
    }

    function computeChartRange() {
      const fixedStart = getProjectStartDate();
      const fixedPhaseWeeks = getFixedPhaseTotalWeeks();
      let minDate = null, maxDate = null;
      tasks.forEach(t => {
        if (t.startDate) minDate = minDate ? new Date(Math.min(minDate.getTime(), t.startDate.getTime())) : new Date(t.startDate);
        if (t.endDate) maxDate = maxDate ? new Date(Math.max(maxDate.getTime(), t.endDate.getTime())) : new Date(t.endDate);
      });
      if (!minDate && !maxDate && !fixedStart) {
        WEEK_START = new Date(DEFAULT_WEEK_START);
        WEEKS = fixedPhaseWeeks != null ? Math.max(8, fixedPhaseWeeks) : 8;
        return;
      }
      const end = maxDate || minDate || fixedStart;
      let weekStart;
      if (fixedStart) {
        const anchor = new Date(fixedStart.getFullYear(), fixedStart.getMonth(), fixedStart.getDate());
        if (minDate && minDate < anchor) {
          weekStart = new Date(minDate);
          weekStart.setDate(weekStart.getDate() - weekStart.getDay());
        } else {
          weekStart = anchor;
        }
      } else {
        const start = minDate || maxDate;
        weekStart = new Date(start);
        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
      }
      WEEK_START = weekStart;
      if (fixedPhaseWeeks != null) {
        WEEKS = Math.max(8, fixedPhaseWeeks);
      } else {
        const weeksNeeded = Math.floor((end - weekStart) / WEEK_MS) + 1;
        WEEKS = Math.max(8, weeksNeeded);
      }
      const fixedEnd = getProjectEndDate();
      if (fixedEnd) {
        const weeksToFixedEnd = Math.ceil((fixedEnd.getTime() - WEEK_START.getTime()) / WEEK_MS);
        if (weeksToFixedEnd > 0 && weeksToFixedEnd < WEEKS) WEEKS = Math.max(8, weeksToFixedEnd);
      }
    }

    let grid;
    let addedPlaceholderThisSession = false;

    function getPhaseColor(phaseId) {
      const p = PHASES.find(x => x.id === phaseId);
      return (p && p.color) || (PHASES[0] && PHASES[0]?.color) || "#737373";
    }
    function hexToRgba(hex, alpha) {
      const n = parseInt(hex.slice(1), 16);
      const r = (n >> 16) & 255, g = (n >> 8) & 255, b = n & 255;
      return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
    }
    function applyPaletteSwatchStyle(span, hex, strokeMode) {
      if (strokeMode) {
        span.style.background = hexToRgba(hex, 0.16);
        span.style.border = "1px solid " + hex;
      } else {
        span.style.background = hex;
        span.style.border = "none";
      }
    }
    function updatePaletteSwatchPreviews() {
      const strokePreview = document.querySelector("#settingsBarStyle .settings-segmented-option[data-value='stroke']")?.classList.contains("selected");
      document.querySelectorAll(".settings-palette-option").forEach(opt => {
        let colors = [];
        try { colors = JSON.parse(opt.dataset.colors || "[]"); } catch (e) {}
        const swatches = opt.querySelectorAll(".settings-palette-swatches span");
        colors.forEach((c, i) => { if (swatches[i]) applyPaletteSwatchStyle(swatches[i], c, strokePreview); });
      });
    }
    function setBarPhaseStyle(barElement, task) {
      const strokeMode = document.querySelector(".gantt-wrapper")?.getAttribute("data-bar-stroke-mode") === "true";
      const primary = task.phase || PHASES[0]?.id;
      const secondary = task.phaseSecondary && task.phaseSecondary !== primary ? task.phaseSecondary : null;
      const strokeEl = barElement.querySelector(".gantt-bar-stroke");
      const inner = barElement.querySelector(".gantt-bar-inner");
      if (secondary) {
        const c1 = getPhaseColor(primary);
        const c2 = getPhaseColor(secondary);
        if (strokeMode) {
          barElement.style.background = "none";
          barElement.style.border = "none";
          barElement.style.color = "var(--text-primary)";
          if (strokeEl) {
            strokeEl.style.border = "1px solid transparent";
            strokeEl.style.background = "linear-gradient(transparent, transparent) padding-box, linear-gradient(to right, " + c1 + ", " + c2 + ") border-box";
            strokeEl.style.backgroundClip = "padding-box, border-box";
            strokeEl.style.webkitBackgroundClip = "padding-box, border-box";
          }
          if (inner) {
            inner.style.inset = "1px";
            inner.style.borderRadius = "3px";
            inner.style.background = "linear-gradient(to right, " + hexToRgba(c1, 0.16) + ", " + hexToRgba(c2, 0.16) + ")";
          }
        } else {
          barElement.style.background = "linear-gradient(to right, " + c1 + ", " + c2 + ")";
          barElement.style.border = "none";
          barElement.style.color = getContrastColor(c1);
          if (strokeEl) {
            strokeEl.style.border = "";
            strokeEl.style.background = "";
            strokeEl.style.backgroundClip = "";
            strokeEl.style.webkitBackgroundClip = "";
          }
          if (inner) { inner.style.inset = ""; inner.style.borderRadius = ""; inner.style.background = ""; }
        }
      } else {
        const c = getPhaseColor(primary);
        if (strokeMode) {
          barElement.style.background = hexToRgba(c, 0.16);
          barElement.style.border = "1px solid " + c;
          barElement.style.color = "var(--text-primary)";
          if (strokeEl) {
            strokeEl.style.border = "";
            strokeEl.style.background = "";
            strokeEl.style.backgroundClip = "";
            strokeEl.style.webkitBackgroundClip = "";
          }
          if (inner) { inner.style.inset = ""; inner.style.borderRadius = ""; inner.style.background = ""; }
        } else {
          barElement.style.background = c;
          barElement.style.border = "none";
          barElement.style.color = getContrastColor(c);
          if (strokeEl) {
            strokeEl.style.border = "";
            strokeEl.style.background = "";
            strokeEl.style.backgroundClip = "";
            strokeEl.style.webkitBackgroundClip = "";
          }
          if (inner) { inner.style.inset = ""; inner.style.borderRadius = ""; inner.style.background = ""; }
        }
      }
      barElement.dataset.phase = primary;
    }
    const CONNECTOR_CORNER_RADIUS = 10;
    function connectorPathD(x1, y1, x2, y2) {
      const r = Math.min(CONNECTOR_CORNER_RADIUS, Math.max(0, y2 - y1) / 2, Math.max(0, x2 - x1) / 2);
      if (r <= 0) return "M " + x1 + " " + y1 + " L " + x1 + " " + y2 + " L " + x2 + " " + y2;
      return "M " + x1 + " " + y1 + " L " + x1 + " " + (y2 - r) + " Q " + x1 + " " + y2 + " " + (x1 + r) + " " + y2 + " L " + x2 + " " + y2;
    }

    let expandedTaskIndex = null;
    let detailEditMode = false;

    function getLinkCardInfo(item) {
      const isUrl = /^https?:\/\//i.test(item);
      const href = isUrl ? item : (JIRA_BASE_URL && /^[A-Z]+-\d+$/i.test(item) ? (JIRA_BASE_URL.replace(/\/$/, "") + "/browse/" + encodeURIComponent(item)) : null);
      if (!href) return { href: null, title: item, shortUrl: "", type: "generic" };
      try {
        const u = new URL(href);
        const host = u.hostname.replace(/^www\./, "");
        if (/figma\.com/i.test(host)) {
          const match = u.pathname.match(/\/design\/[^/]+\/([^/?]+)/);
          const raw = match ? match[1] : "";
          const title = raw ? decodeURIComponent(raw).replace(/-/g, " ").trim() || "Figma Design" : "Figma Design";
          return { href, title, shortUrl: "figma.com", type: "figma" };
        }
        if (/atlassian\.net|jira\./i.test(host) || /^[A-Z]+-\d+$/i.test(item)) {
          const ticketMatch = item.match(/[A-Z]+-\d+/i) || href.match(/\/browse\/([A-Z]+-\d+)/i);
          const title = ticketMatch ? ticketMatch[1] : "Jira";
          return { href, title, shortUrl: host, type: "jira" };
        }
        if (/google\.com/i.test(host)) {
          const title = host === "docs.google.com" ? "Google Docs" : host === "drive.google.com" ? "Google Drive" : "Google";
          return { href, title, shortUrl: host, type: "google" };
        }
        const title = u.pathname && u.pathname !== "/" ? u.pathname.split("/").filter(Boolean).pop().replace(/-/g, " ") : host;
        return { href, title: decodeURIComponent(title).slice(0, 50), shortUrl: host, type: "generic" };
      } catch {
        return { href, title: item.slice(0, 50), shortUrl: "", type: "generic" };
      }
    }

    const FIELD_ICONS = {
      overview: '<svg class="field-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>',
      tasks: '<svg class="field-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>',
      subTasks: '<svg class="field-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>',
      blockers: '<svg class="field-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>',
      links: '<svg class="field-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>',
      dependsOn: '<svg class="field-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/><path d="M12 5l7 7-7 7"/></svg>'
    };

    function collapseDetail(animate) {
      const existing = grid.querySelector(".gantt-detail-row");
      if (!existing) {
        expandedTaskIndex = null;
        grid.querySelectorAll(".gantt-row.expanded").forEach(r => r.classList.remove("expanded"));
        return;
      }
      if (!animate) {
        existing.remove();
        expandedTaskIndex = null;
        grid.querySelectorAll(".gantt-row.expanded").forEach(r => r.classList.remove("expanded"));
        return;
      }
      existing.classList.add("closing");
      existing.addEventListener("animationend", () => {
        existing.remove();
        expandedTaskIndex = null;
        grid.querySelectorAll(".gantt-row.expanded").forEach(r => r.classList.remove("expanded"));
      }, { once: true });
    }

    function expandTaskDetail(index) {
      if (expandedTaskIndex === index) {
        collapseDetail(true);
        return;
      }
      collapseDetail(false);
      const task = tasks[index];
      if (!task) return;
      const row = grid.querySelector('.gantt-row[data-index="' + index + '"]');
      if (!row) return;
      expandedTaskIndex = index;
      detailEditMode = false;
      row.classList.add("expanded");
      const detailRow = document.createElement("div");
      detailRow.className = "gantt-detail-row";
      const inner = document.createElement("div");
      inner.className = "gantt-detail-row-inner";
      detailRow.appendChild(inner);
      renderTaskDetailContent(task, inner, detailRow);
      row.insertAdjacentElement("afterend", detailRow);
    }

    document.addEventListener("keydown", (e) => {
      const inFormControl = e.target.closest("input, select, textarea");
      if (e.key === "z" || e.key === "y") {
        const isUndo = (e.key === "z" && e.shiftKey === false) || (e.key === "y" && e.shiftKey === true);
        const isRedo = (e.key === "z" && e.shiftKey === true) || (e.key === "y" && e.shiftKey === false);
        if ((e.metaKey || e.ctrlKey) && !e.altKey && !inFormControl) {
          if (isUndo) {
            e.preventDefault();
            performUndo();
          } else if (isRedo) {
            e.preventDefault();
            performRedo();
          }
        }
        return;
      }
      if (selectedBarIndex !== null && !inFormControl && e.shiftKey && (e.key === "ArrowUp" || e.key === "ArrowDown")) {
        const from = selectedBarIndex;
        const to = e.key === "ArrowUp" ? from - 1 : from + 1;
        if (to < 0 || to >= tasks.length) return;
        e.preventDefault();
        pushTasksUndo();
        const [moved] = tasks.splice(from, 1);
        tasks.splice(to, 0, moved);
        tasks.forEach((t) => {
          if (typeof t.dependsOn !== "number") return;
          const i = t.dependsOn;
          if (i === from) t.dependsOn = to;
          else if (from < i && i < to) t.dependsOn = i - 1;
          else if (i === to) t.dependsOn = to + 1;
        });
        if (typeof updateChartRange === "function") updateChartRange();
        saveTasks();
        renderTasks();
        const newBar = document.querySelector('.gantt-bar[data-index="' + to + '"]');
        if (newBar && typeof selectBar === "function") selectBar(newBar, to);
        return;
      }
      if (e.key !== "Escape") return;
      if (selectedBarElement) {
        e.preventDefault();
        deselectBar();
        return;
      }
      if (expandedTaskIndex !== null) {
        e.preventDefault();
        collapseDetail(true);
      }
    });

    function renderTaskDetailContent(task, container, detailRow) {
      if (!container) {
        const row = grid.querySelector(".gantt-detail-row");
        if (row) {
          container = row.querySelector(".gantt-detail-row-inner");
          detailRow = row;
        }
        if (!container) return;
      }
      container.innerHTML = "";
      const toolbar = document.createElement("div");
      toolbar.className = "task-detail-toolbar";
      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "task-detail-edit-btn";
      editBtn.textContent = "Edit";
      const doneBtn = document.createElement("button");
      doneBtn.type = "button";
      doneBtn.className = "task-detail-done-btn";
      doneBtn.textContent = "Done";
      const contentArea = document.createElement("div");
      contentArea.className = "task-detail-content";

      function showView() {
        detailEditMode = false;
        editBtn.style.display = "";
        doneBtn.style.display = "none";
        contentArea.style.opacity = "0";
        setTimeout(() => {
          contentArea.innerHTML = "";
          renderTaskDetailView(task, contentArea);
          contentArea.style.opacity = "1";
        }, 150);
      }
      function showEdit() {
        detailEditMode = true;
        editBtn.style.display = "none";
        doneBtn.style.display = "";
        contentArea.style.opacity = "0";
        setTimeout(() => {
          contentArea.innerHTML = "";
          renderTaskDetailForm(task, contentArea);
          contentArea.style.opacity = "1";
        }, 150);
      }

      editBtn.addEventListener("click", showEdit);
      doneBtn.addEventListener("click", showView);
      toolbar.appendChild(editBtn);
      toolbar.appendChild(doneBtn);
      detailRow.appendChild(toolbar);
      container.appendChild(contentArea);
      if (detailEditMode) {
        editBtn.style.display = "none";
        doneBtn.style.display = "";
        renderTaskDetailForm(task, contentArea);
      } else {
        doneBtn.style.display = "none";
        renderTaskDetailView(task, contentArea);
      }
    }

    function renderTaskDetailView(task, container) {
      container.innerHTML = "";
      const currentIdx = tasks.indexOf(task);
      const dependents = tasks.map((t, idx) => ({ task: t, idx })).filter(({ task: t }) => typeof t.dependsOn === "number" && t.dependsOn === currentIdx);
      const hasDependents = dependents.length > 0;
      const depFields = [
        { key: "dependsOn", label: "Depends on", type: "dependsOn" },
        { key: "dependents", label: "Dependents", type: "dependents", dependents }
      ];
      const fields = [
        { key: "overview", label: "Overview / Description", type: "textarea" },
        ...(hasDependents ? depFields.slice().reverse() : depFields),
        { key: "subTasks", label: "Tasks", type: "list" },
        { key: "links", label: "Links", type: "list" }
      ];
      fields.forEach((f, i) => {
        const field = document.createElement("div");
        field.className = "task-detail-field";
        field.innerHTML = "<label>" + (FIELD_ICONS[f.key] || FIELD_ICONS.dependsOn) + "<span>" + f.label + "</span></label>";
        const value = document.createElement("div");
        value.className = "task-detail-view-value";
        if (f.type === "dependsOn") {
          const idx = task.dependsOn;
          if (typeof idx !== "number" || !tasks[idx]) {
            value.textContent = "";
            value.classList.add("empty");
          } else {
            const t = tasks[idx];
            value.textContent = (t.star ? " " : "") + (t.task || "Task " + (idx + 1));
          }
        } else if (f.type === "dependents") {
          const list = f.dependents || [];
          if (list.length === 0) {
            value.textContent = "No dependent tasks";
            value.classList.add("empty");
          } else {
            const wrap = document.createElement("div");
            wrap.className = "task-detail-dependents-list";
            list.forEach(({ task: depTask }) => {
              const span = document.createElement("span");
              span.className = "task-detail-dependent-item task-detail-dependent-item-view";
              span.textContent = (depTask.star ? " " : "") + (depTask.task || "Task");
              wrap.appendChild(span);
            });
            value.appendChild(wrap);
          }
        } else if (f.type === "text" || f.type === "textarea") {
          const v = (task[f.key] || "").trim();
          if (!v) {
            value.textContent = "";
            value.classList.add("empty");
          } else {
            value.textContent = v;
          }
        } else {
          const arr = task[f.key] || [];
          if (arr.length === 0) {
            value.textContent = "";
            value.classList.add("empty");
          } else {
            if (f.key === "links") {
              const cardsWrap = document.createElement("div");
              cardsWrap.className = "task-detail-link-cards";
              arr.filter(Boolean).forEach(item => {
                const info = getLinkCardInfo(item);
                if (!info.href) {
                  const fallback = document.createElement("div");
                  fallback.className = "task-detail-view-value";
                  fallback.textContent = item;
                  cardsWrap.appendChild(fallback);
                  return;
                }
                const a = document.createElement("a");
                a.href = info.href;
                a.target = "_blank";
                a.rel = "noopener noreferrer";
                a.className = "task-detail-link-card";
                const icon = document.createElement("div");
                icon.className = "task-detail-link-card-icon " + info.type;
                if (info.type === "figma") {
                  const img = document.createElement("img");
                  img.src = "https://upload.wikimedia.org/wikipedia/commons/3/33/Figma-logo.svg";
                  img.alt = "Figma";
                  img.width = 18;
                  img.height = 27;
                  img.style.objectFit = "contain";
                  icon.appendChild(img);
                }
                else if (info.type === "jira") icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M11.571 11.513H0a5.218 5.218 0 0 0 5.232 5.215h2.13v2.057A5.215 5.215 0 0 0 12.575 24V12.518a1.005 1.005 0 0 0-1.005-1.005zm5.723-5.756H5.736a5.215 5.215 0 0 0 5.215 5.214h2.129v2.058a5.218 5.218 0 0 0 5.215 5.214h2.016V6.758a1.001 1.001 0 0 0-1.001-1.001zM23.013 0H11.455a5.215 5.215 0 0 0 5.215 5.215h2.129v2.057a5.215 5.215 0 0 0 5.215 5.215h2.016V1.005A1.001 1.001 0 0 0 23.013 0z"/></svg>';
                else if (info.type === "google") icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>';
                else icon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>';
                const content = document.createElement("div");
                content.className = "task-detail-link-card-content";
                const titleEl = document.createElement("div");
                titleEl.className = "task-detail-link-card-title";
                titleEl.textContent = info.title;
                const urlEl = document.createElement("div");
                urlEl.className = "task-detail-link-card-url";
                urlEl.textContent = info.shortUrl || item;
                content.appendChild(titleEl);
                content.appendChild(urlEl);
                const arrow = document.createElement("span");
                arrow.className = "task-detail-link-card-arrow";
                arrow.textContent = "";
                a.appendChild(icon);
                a.appendChild(content);
                a.appendChild(arrow);
                cardsWrap.appendChild(a);
              });
              value.appendChild(cardsWrap);
            } else {
              const ul = document.createElement("ul");
              ul.className = "task-detail-view-list";
              arr.filter(Boolean).forEach(item => {
                const li = document.createElement("li");
                li.textContent = item;
                ul.appendChild(li);
              });
              value.appendChild(ul);
            }
          }
        }
        field.appendChild(value);
        container.appendChild(field);
      });
    }

    function renderListField(container, items, task, key, placeholder, onRerender) {
      container.innerHTML = "";
      const ul = document.createElement("ul");
      ul.className = "task-detail-list";
      (items || []).forEach((item, i) => {
        const li = document.createElement("li");
        const wrap = document.createElement("div");
        wrap.className = "task-detail-list-input-wrap";
        const inp = document.createElement("input");
        inp.type = "text";
        inp.value = typeof item === "string" ? item : "";
        inp.placeholder = placeholder;
        inp.addEventListener("change", () => {
          task[key] = task[key] || [];
          task[key][i] = inp.value.trim();
          task[key] = task[key].filter(Boolean);
          saveTasks();
        });
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "task-detail-list-remove";
        removeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>';
        removeBtn.title = "Remove";
        removeBtn.addEventListener("click", () => {
          task[key] = (task[key] || []).filter((_, j) => j !== i);
          if (onRerender) onRerender();
          saveTasks();
        });
        wrap.appendChild(inp);
        wrap.appendChild(removeBtn);
        li.appendChild(wrap);
        ul.appendChild(li);
      });
      container.appendChild(ul);
      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.className = "task-detail-add-btn";
      addBtn.textContent = "+ Add";
      addBtn.addEventListener("click", () => {
        task[key] = task[key] || [];
        task[key].push("");
        if (onRerender) onRerender();
        saveTasks();
      });
      container.appendChild(addBtn);
    }

    function renderTaskDetailForm(task, container) {
      if (!container) {
        const detailRow = grid.querySelector(".gantt-detail-row");
        if (detailRow) container = detailRow.querySelector(".task-detail-content");
        if (!container) return;
      }
      container.innerHTML = "";
      const rerender = () => renderTaskDetailForm(task, container);

      const overviewField = document.createElement("div");
      overviewField.className = "task-detail-field";
      overviewField.innerHTML = '<label>' + FIELD_ICONS.overview + '<span>Overview / Description</span></label>';
      const overviewInput = document.createElement("textarea");
      overviewInput.placeholder = "Describe the task, goals, and context...";
      overviewInput.value = task.overview || "";
      overviewInput.addEventListener("change", () => { task.overview = overviewInput.value; saveTasks(); });
      overviewField.appendChild(overviewInput);
      container.appendChild(overviewField);

      const dependsOnField = document.createElement("div");
      dependsOnField.className = "task-detail-field";
      dependsOnField.innerHTML = '<label>' + FIELD_ICONS.dependsOn + '<span>Depends on</span></label>';
      const dependsOnSelect = document.createElement("select");
      dependsOnSelect.className = "task-detail-depends-on";
      const currentIdx = tasks.indexOf(task);
      const optNone = document.createElement("option");
      optNone.value = "";
      optNone.textContent = " No dependency";
      dependsOnSelect.appendChild(optNone);
      tasks.forEach((t, idx) => {
        if (idx === currentIdx) return;
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = (t.star ? " " : "") + (t.task || "Task " + (idx + 1));
        if (task.dependsOn === idx) opt.selected = true;
        dependsOnSelect.appendChild(opt);
      });
      dependsOnSelect.addEventListener("change", () => {
        const v = dependsOnSelect.value;
        const oldParentIdx = task.dependsOn;
        const wasLinked = oldParentIdx !== null;
        pushTasksUndo();
        task.dependsOn = v === "" ? null : parseInt(v, 10);
        const taskName = (task.star ? " " : "") + (task.task || "Task");
        if (task.dependsOn !== null) {
          const parentTask = tasks[task.dependsOn];
          const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
          propagateDependencyChanges(task.dependsOn);
          showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${taskName}"  "${parentName}"`, { onUndo: performUndo });
        } else if (wasLinked && tasks[oldParentIdx]) {
          const oldParentTask = tasks[oldParentIdx];
          const oldParentName = (oldParentTask.star ? " " : "") + (oldParentTask.task || "Task");
          showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/><path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/><line x1="8" y1="2" x2="8" y2="5"/><line x1="2" y1="8" x2="5" y2="8"/><line x1="16" y1="19" x2="16" y2="22"/><line x1="19" y1="16" x2="22" y2="16"/></svg> "${taskName}" unlinked from "${oldParentName}"`, { onUndo: performUndo });
        }
        if (typeof updateChartRange === "function") updateChartRange();
        saveTasks();
        if (onRerender) onRerender();
      });
      dependsOnField.appendChild(dependsOnSelect);
      container.appendChild(dependsOnField);

      const dependentsField = document.createElement("div");
      dependentsField.className = "task-detail-field";
      dependentsField.innerHTML = '<label>' + FIELD_ICONS.dependsOn + '<span>Dependents</span></label>';
      const dependentsList = document.createElement("div");
      dependentsList.className = "task-detail-dependents-list";
      const dependents = tasks.map((t, idx) => ({ task: t, idx })).filter(({ task: t }) => typeof t.dependsOn === "number" && t.dependsOn === currentIdx);
      if (dependents.length === 0) {
        const empty = document.createElement("div");
        empty.className = "task-detail-view-value empty";
        empty.textContent = "No dependent tasks";
        dependentsList.appendChild(empty);
      } else {
        dependents.forEach(({ task: depTask, idx: depIdx }) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "task-detail-dependent-item";
          btn.textContent = (depTask.star ? " " : "") + (depTask.task || "Task " + (depIdx + 1));
          btn.addEventListener("click", () => {
            const bar = document.querySelector('.gantt-bar[data-index="' + depIdx + '"]');
            if (bar && typeof selectBar === "function") selectBar(bar, depIdx);
          });
          dependentsList.appendChild(btn);
        });
      }
      dependentsField.appendChild(dependentsList);
      container.appendChild(dependentsField);

      const tasksField = document.createElement("div");
      tasksField.className = "task-detail-field";
      tasksField.innerHTML = '<label>' + FIELD_ICONS.tasks + '<span>Tasks</span></label>';
      const tasksList = document.createElement("div");
      renderListField(tasksList, task.subTasks, task, "subTasks", "Sub-task or checklist item", rerender);
      tasksField.appendChild(tasksList);
      container.appendChild(tasksField);

      const linksField = document.createElement("div");
      linksField.className = "task-detail-field";
      linksField.innerHTML = '<label>' + FIELD_ICONS.links + '<span>Links</span></label>';
      const linksList = document.createElement("div");
      renderListField(linksList, task.links, task, "links", "Jira ticket, Figma URL, or other link", rerender);
      linksField.appendChild(linksList);
      container.appendChild(linksField);
    }

    function getContrastColor(hex) {
      const h = hex.replace("#", "");
      const r = parseInt(h.substr(0, 2), 16) / 255;
      const g = parseInt(h.substr(2, 2), 16) / 255;
      const b = parseInt(h.substr(4, 2), 16) / 255;
      const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
      return luminance < 0.5 ? "#ffffff" : "#1a1a1a";
    }

    function deselectBar() {
      document.querySelectorAll(".gantt-bar.bar-family").forEach((b) => b.classList.remove("bar-family"));
      if (selectedBarElement) {
        if (selectedBarElement._selectionDurationHint) {
          selectedBarElement._selectionDurationHint.remove();
          selectedBarElement._selectionDurationHint = null;
        }
        selectedBarElement.classList.remove("selected");
        selectedBarElement = null;
      }
      selectedBarIndex = null;
      const phaseWrap = document.getElementById("ganttBarTooltipPhaseDropdown")?.firstElementChild;
      if (phaseWrap?._tooltipList?.parentNode) {
        phaseWrap._tooltipList.remove();
        phaseWrap.classList.remove("open");
      }
      const tooltipEl = document.getElementById("ganttBarTooltip");
      const actionsEl = document.getElementById("ganttBarTooltipActions");
      if (tooltipEl) {
        tooltipEl.classList.remove("visible", "has-actions");
        tooltipEl.style.borderColor = "";
      }
      if (actionsEl) actionsEl.style.display = "none";
      if (selectedBarClickOutside) {
        document.removeEventListener("click", selectedBarClickOutside);
        selectedBarClickOutside = null;
      }
      const depLineEl = document.getElementById("ganttDependencyLine");
      if (depLineEl) depLineEl.classList.remove("visible");
      const mainUnlinkBtn = document.getElementById("ganttDependencyUnlinkBtn");
      if (mainUnlinkBtn) {
        mainUnlinkBtn.classList.remove("visible");
        mainUnlinkBtn.style.pointerEvents = "none";
      }
      if (selectedBarDepLineCleanup) {
        selectedBarDepLineCleanup();
        selectedBarDepLineCleanup = null;
      }
      const childContainer = document.getElementById("ganttChildConnectorsContainer");
      if (childContainer) childContainer.innerHTML = "";
      grid?.querySelectorAll(".gantt-row:not(.gantt-header)").forEach(r => { r.draggable = true; });
    }

    function populateTooltipForBar(tooltipEl, task, index) {
      if (!tooltipEl || !task) return;
      const titleEl = tooltipEl.querySelector(".gantt-bar-tooltip-title");
      const partyRow = tooltipEl.querySelector(".gantt-bar-tooltip-party");
      const partyText = partyRow?.querySelector(".gantt-bar-tooltip-text");
      const descRow = tooltipEl.querySelector(".gantt-bar-tooltip-desc");
      const descText = descRow?.querySelector(".gantt-bar-tooltip-text");
      const datesRow = tooltipEl.querySelector(".gantt-bar-tooltip-dates");
      const datesText = datesRow?.querySelector(".gantt-bar-tooltip-text");
      if (titleEl) titleEl.textContent = (task.star ? " " : "") + (task.task || "Task");
      if (partyRow && partyText) {
        partyText.textContent = task.party || "";
        partyRow.style.display = task.party ? "" : "none";
      }
      const depRow = tooltipEl.querySelector(".gantt-bar-tooltip-depends");
      const depText = depRow?.querySelector(".gantt-bar-tooltip-text");
      const depUnlinkWrap = depRow?.querySelector(".gantt-bar-tooltip-dep-unlink-wrap");
      const depUnlinkBtn = depUnlinkWrap?.querySelector(".gantt-bar-tooltip-dep-unlink");
      if (depRow && depText) {
        if (typeof task.dependsOn === "number" && tasks[task.dependsOn]) {
          const primary = tasks[task.dependsOn];
          depText.textContent = "Depends on: " + ((primary.star ? " " : "") + (primary.task || "Task"));
          depRow.style.display = "";
          depRow.style.color = getPhaseColor(primary.phase || PHASES[0]?.id);
          if (depUnlinkWrap) depUnlinkWrap.style.display = "";
          if (depUnlinkBtn) {
            depUnlinkBtn.onclick = (e) => {
              e.stopPropagation();
              const t = tasks[index];
              const p = t && typeof t.dependsOn === "number" ? tasks[t.dependsOn] : null;
              if (!t || !p) return;
              pushTasksUndo();
              t.dependsOn = null;
              saveTasks();
              renderTasks();
              deselectBar();
              const parentName = (p.star ? " " : "") + (p.task || "Task");
              const childName = (t.star ? " " : "") + (t.task || "Task");
              showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/><path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/><line x1="8" y1="2" x2="8" y2="5"/><line x1="2" y1="8" x2="5" y2="8"/><line x1="16" y1="19" x2="16" y2="22"/><line x1="19" y1="16" x2="22" y2="16"/></svg> "${childName}" unlinked from "${parentName}"`, { onUndo: performUndo });
            };
          }
        } else {
          depRow.style.display = "none";
          depRow.style.color = "";
          if (depUnlinkWrap) depUnlinkWrap.style.display = "none";
          if (depUnlinkBtn) depUnlinkBtn.onclick = null;
        }
      }
      if (descText) descText.textContent = (task.overview || "").trim() || "";
      if (datesRow && datesText) {
        let datesStr = "";
        if (task.start && task.end) {
          datesStr = task.start === task.end ? task.start : task.start + "  " + task.end;
          if (task.startDate && task.endDate) {
            const days = Math.ceil((task.endDate - task.startDate) / (24 * 60 * 60 * 1000)) + 1;
            const sprints = Math.ceil(days / 14);
            datesStr += "  " + sprints + " sprint" + (sprints !== 1 ? "s" : "");
          }
        }
        datesText.textContent = datesStr;
        datesRow.style.display = datesStr ? "" : "none";
      }
    }

    function getRelatedBarIndices(index) {
      const set = new Set([index]);
      const task = tasks[index];
      const parentIdx = task && typeof task.dependsOn === "number" ? task.dependsOn : null;
      if (parentIdx !== null) set.add(parentIdx);
      tasks.forEach((t, j) => {
        if (typeof t.dependsOn === "number" && t.dependsOn === index) set.add(j);
      });
      return set;
    }

    function attachSingleLineDotHandlers(depLineDot1, depLineDot2, depLinePath, depLinePathHover, primaryIdx, dependentIdx, getCoords, primaryColor) {
      const circle1 = depLineDot1?.querySelector?.("circle") || depLineDot1?.firstElementChild;
      const circle2 = depLineDot2?.querySelector?.("circle") || depLineDot2?.firstElementChild;
      const path = depLinePath;
      const pathHit = depLinePathHover;
      const dotR = 3;
      const addHandlers = (circle, end, dotEl) => {
        const onDown = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const coords = getCoords();
          const { x1, y1, x2, y2 } = coords;
          const fixedX = end === "primary" ? x2 : x1;
          const fixedY = end === "primary" ? y2 : y1;
          const otherX = end === "primary" ? x1 : x2;
          const otherY = end === "primary" ? y1 : y2;
          dotEl.classList.add("connector-dot-dragging");
          path.classList.add("connector-dragging");
          const onMove = (e2) => {
            e2.preventDefault();
            const cx = e2.clientX;
            const cy = e2.clientY;
            dotEl.setAttribute("transform", `translate(${cx}, ${cy - (end === "primary" ? dotR : 0)})`);
            const newD = end === "primary" ? connectorPathD(cx, cy, fixedX, fixedY) : connectorPathD(fixedX, fixedY, cx, cy);
            path.setAttribute("d", newD);
            if (pathHit) pathHit.setAttribute("d", newD);
            const ganttWrapper = document.querySelector(".gantt-wrapper");
            const prevWrapperPE = ganttWrapper?.style.pointerEvents;
            if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
            const elements = document.elementsFromPoint(cx, cy);
            if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
            let hoveredIdx = null;
            for (const el of elements) {
              const row = el.closest?.(".gantt-row[data-index]");
              if (row && !row.classList.contains("gantt-header")) {
                hoveredIdx = parseInt(row.getAttribute("data-index"), 10);
                break;
              }
              const barEl = el.closest?.(".gantt-bar");
              if (barEl) {
                hoveredIdx = parseInt(barEl.getAttribute("data-index"), 10);
                break;
              }
            }
            let previewColor = "#a3a3a3";
            if (hoveredIdx !== null && !isNaN(hoveredIdx)) {
              if (end === "primary" && hoveredIdx !== dependentIdx && !wouldCreateCycle(dependentIdx, hoveredIdx)) {
                previewColor = getPhaseColor(tasks[hoveredIdx].phase || PHASES[0]?.id);
              } else if (end === "dependent" && hoveredIdx !== primaryIdx && !wouldCreateCycle(hoveredIdx, primaryIdx)) {
                previewColor = getPhaseColor(tasks[hoveredIdx].phase || PHASES[0]?.id);
              }
            }
            path.setAttribute("stroke", previewColor);
          };
          const onUp = (e2) => {
            e2.preventDefault();
            e2.stopPropagation();
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onUp);
            const ganttWrapper = document.querySelector(".gantt-wrapper");
            const prevWrapperPE = ganttWrapper?.style.pointerEvents;
            if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
            const elements = document.elementsFromPoint(e2.clientX, e2.clientY);
            if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
            let newIdx = null;
            for (const el of elements) {
              const row = el.closest?.(".gantt-row[data-index]");
              if (row && !row.classList.contains("gantt-header")) {
                newIdx = parseInt(row.getAttribute("data-index"), 10);
                break;
              }
              const bar = el.closest?.(".gantt-bar");
              if (bar) {
                newIdx = parseInt(bar.getAttribute("data-index"), 10);
                break;
              }
            }
            dotEl.classList.remove("connector-dot-dragging");
            path.classList.remove("connector-dragging");
            let didUpdate = false;
            let toastMessage = "";
            if (newIdx !== null && !isNaN(newIdx)) {
              if (end === "primary" && newIdx !== dependentIdx && !wouldCreateCycle(dependentIdx, newIdx)) {
                pushTasksUndo();
                tasks[dependentIdx].dependsOn = newIdx;
                propagateDependencyChanges(newIdx);
                didUpdate = true;
                const childTask = tasks[dependentIdx];
                const newParentTask = tasks[newIdx];
                const childName = (childTask.star ? " " : "") + (childTask.task || "Task");
                const parentName = (newParentTask.star ? " " : "") + (newParentTask.task || "Task");
                toastMessage = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${childName}"  "${parentName}"`;
              } else if (end === "dependent" && newIdx !== primaryIdx && !wouldCreateCycle(newIdx, primaryIdx)) {
                pushTasksUndo();
                tasks[dependentIdx].dependsOn = null;
                tasks[newIdx].dependsOn = primaryIdx;
                propagateDependencyChanges(primaryIdx);
                didUpdate = true;
                const newChildTask = tasks[newIdx];
                const parentTask = tasks[primaryIdx];
                const childName = (newChildTask.star ? " " : "") + (newChildTask.task || "Task");
                const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
                toastMessage = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${childName}"  "${parentName}"`;
              }
            }
            if (didUpdate) {
              saveTasks();
              renderTasks();
              if (toastMessage) showToast(toastMessage, { onUndo: performUndo });
            } else if (path && primaryColor) {
              path.setAttribute("stroke", primaryColor);
            }
          };
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onUp, { once: true });
          onMove(e);
        };
        circle.addEventListener("mousedown", onDown);
        return () => circle.removeEventListener("mousedown", onDown);
      };
      const off1 = circle1 ? addHandlers(circle1, "primary", depLineDot1) : () => {};
      const off2 = circle2 ? addHandlers(circle2, "dependent", depLineDot2) : () => {};
      return () => { off1(); off2(); };
    }

    function selectBar(bar, index) {
      if (selectedBarIndex === index && selectedBarElement === bar) {
        deselectBar();
        return;
      }
      deselectBar();
      const t = tasks[index];
      if (!t) return;
      const tooltipEl = document.getElementById("ganttBarTooltip");
      const actionsEl = document.getElementById("ganttBarTooltipActions");
      if (!tooltipEl) return;
      selectedBarIndex = index;
      selectedBarElement = bar;
      bar.classList.add("selected");
      grid?.querySelectorAll(".gantt-row:not(.gantt-header)").forEach(r => { r.draggable = false; });
      const related = getRelatedBarIndices(index);
      document.querySelectorAll(".gantt-bar").forEach((b) => {
        const idx = b.getAttribute("data-index");
        if (idx !== null && related.has(parseInt(idx, 10))) b.classList.add("bar-family");
      });
      if (t.startDate && t.endDate) {
        const days = Math.max(1, Math.ceil((t.endDate - t.startDate) / (24 * 60 * 60 * 1000)) + 1);
        const hintEl = document.createElement("span");
        hintEl.className = "gantt-bar-duration-hint";
        hintEl.textContent = days + " day" + (days !== 1 ? "s" : "");
        bar.appendChild(hintEl);
        bar._selectionDurationHint = hintEl;
      }
      const depLineEl = document.getElementById("ganttDependencyLine");
      const depLinePath = document.getElementById("ganttDependencyLinePath");
      const depLinePathHover = document.getElementById("ganttDependencyLinePathHover");
      const depLineDot1 = document.getElementById("ganttDependencyLineDot1");
      const depLineDot2 = document.getElementById("ganttDependencyLineDot2");
      if (typeof t.dependsOn === "number" && tasks[t.dependsOn]) {
        const primaryBar = document.querySelector('.gantt-bar[data-index="' + t.dependsOn + '"]');
        if (primaryBar && depLineEl && depLinePath) {
          const primaryColor = getPhaseColor(tasks[t.dependsOn].phase || PHASES[0]?.id);
          const unlinkBtn = document.getElementById("ganttDependencyUnlinkBtn");
          const updateLine = () => {
            const pr = primaryBar.getBoundingClientRect();
            const dr = bar.getBoundingClientRect();
            const x1 = pr.left + pr.width / 2;
            const y1 = pr.bottom;
            const x2 = dr.left;
            const y2 = dr.top + dr.height / 2;
            const pathD = connectorPathD(x1, y1, x2, y2);
            depLinePath.setAttribute("d", pathD);
            depLinePath.setAttribute("stroke", primaryColor);
            if (depLinePathHover) depLinePathHover.setAttribute("d", pathD);
            const dotR = 3;
            if (depLineDot1) { depLineDot1.setAttribute("transform", `translate(${x1}, ${y1 - dotR})`); }
            if (depLineDot2) { depLineDot2.setAttribute("transform", `translate(${x2}, ${y2})`); }
            depLineEl.setAttribute("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight);
            depLineEl.setAttribute("width", window.innerWidth);
            depLineEl.setAttribute("height", window.innerHeight);
            depLineEl.classList.add("visible");
          };
          updateLine();
          const getCoords = () => {
            const pr = primaryBar.getBoundingClientRect();
            const dr = bar.getBoundingClientRect();
            return { x1: pr.left + pr.width / 2, y1: pr.bottom, x2: dr.left, y2: dr.top + dr.height / 2 };
          };
          const singleLineDotCleanup = attachSingleLineDotHandlers(depLineDot1, depLineDot2, depLinePath, depLinePathHover, t.dependsOn, index, getCoords, primaryColor);
          const wrapper = document.querySelector(".gantt-wrapper");
          wrapper?.addEventListener("scroll", updateLine, true);
          window.addEventListener("scroll", updateLine, true);
          window.addEventListener("resize", updateLine);
          selectedBarDepLineCleanup = () => {
            singleLineDotCleanup();
            wrapper?.removeEventListener("scroll", updateLine, true);
            window.removeEventListener("scroll", updateLine, true);
            window.removeEventListener("resize", updateLine);
            if (unlinkBtn) {
              unlinkBtn.classList.remove("visible");
              if (unlinkBtn._unlinkHandler) {
                unlinkBtn.removeEventListener("click", unlinkBtn._unlinkHandler);
                unlinkBtn._unlinkHandler = null;
              }
            }
          };
        }
      }
      populateTooltipForBar(tooltipEl, t, index);
      const phaseDropdownContainer = document.getElementById("ganttBarTooltipPhaseDropdown");
      if (phaseDropdownContainer) {
        phaseDropdownContainer.innerHTML = "";
        const phaseDropdown = createTooltipPhaseDropdown(t.phase || PHASES[0]?.id, t.phaseSecondary || null, async (phaseId, isSecondary) => {
          if (isSecondary) {
            t.phaseSecondary = t.phaseSecondary === phaseId ? null : (phaseId === (t.phase || PHASES[0]?.id) ? null : phaseId);
            setBarPhaseStyle(bar, t);
            phaseDropdown._updateLabel(t.phase || PHASES[0]?.id, t.phaseSecondary || null);
            if (phaseDropdown._updateOptionStates) phaseDropdown._updateOptionStates(t.phase || PHASES[0]?.id, t.phaseSecondary || null);
            const rowPhaseWrap = bar.closest(".gantt-row")?.querySelector(".gantt-phase-dropdown-wrap");
            if (rowPhaseWrap && rowPhaseWrap._setPhaseSecondary) rowPhaseWrap._setPhaseSecondary(t.phaseSecondary || null);
            saveTasks();
            return;
          }
          if (!phaseId || !t.startDate || !t.endDate) return;
          const hasTwoPhases = t.phaseSecondary && t.phaseSecondary !== (t.phase || PHASES[0]?.id);
          if (!getAllowIndependentDependencies() && !hasTwoPhases && typeof t.dependsOn === "number" && tasks[t.dependsOn]) {
            const phaseName = PHASES.find(p => p.id === phaseId)?.name || phaseId;
            const parentTask = tasks[t.dependsOn];
            const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
            const taskName = (t.star ? " " : "") + (t.task || "Task");
            const msg = `"${taskName.trim() || "This task"}" is linked to "${parentName}". Unlink before moving to ${phaseName}?`;
            const connectorEl = document.getElementById("ganttDependencyLinePath");
            const anchor = (connectorEl && connectorEl.getAttribute("d")) ? connectorEl : phaseDropdown;
            const unlink = await showDetachConfirm(anchor, msg, { showSettingsHint: true });
            if (!unlink) {
              phaseDropdown._updateLabel(t.phase || PHASES[0]?.id, t.phaseSecondary || null);
              return;
            }
            t.dependsOn = null;
          }
          const phaseIdx = PHASES.findIndex(p => p.id === phaseId);
          if (phaseIdx < 0) return;
          const startWeekOffset = getPhaseStartWeekOffset(phaseIdx);
          const durationMs = t.endDate.getTime() - t.startDate.getTime();
          const oldPhase = t.phase;
          t.phase = phaseId;
          t.phaseSecondary = null;
          t.startDate = offsetToDate(startWeekOffset);
          t.endDate = new Date(t.startDate.getTime() + durationMs);
          t.start = formatDate(t.startDate);
          t.end = formatDate(t.endDate);
          setBarPhaseStyle(bar, t);
          const dateCell = bar.closest(".gantt-row")?.querySelector(".gantt-date-cell");
          const startInp = dateCell?.querySelector('.gantt-date-start');
          const endInp = dateCell?.querySelector('.gantt-date-end');
          if (startInp) startInp.value = t.start;
          if (endInp) endInp.value = t.end;
          const rowPhaseWrap = bar.closest(".gantt-row")?.querySelector(".gantt-phase-dropdown-wrap");
          if (rowPhaseWrap && rowPhaseWrap._updateLabel) rowPhaseWrap._updateLabel(phaseId);
          const so = dateToOffset(t.startDate);
          let eo = dateToOffset(t.endDate);
          if (eo <= so) eo = so + 1 / 7;
          eo = Math.min(WEEKS, eo);
          bar.style.left = (Math.max(0, so) / WEEKS) * 100 + "%";
          bar.style.width = ((eo - Math.max(0, so)) / WEEKS) * 100 + "%";
          // Update child tasks to the same phase (only when not using independent deps)
          if (oldPhase !== phaseId && !getAllowIndependentDependencies()) {
            tasks.forEach((childTask) => {
              if (childTask.dependsOn === index) {
                childTask.phase = phaseId;
              }
            });
            saveTasks();
            renderTasks(); // Refresh to show updated child phases
            return; // Skip additional updates since renderTasks() handles everything
          }
          if (typeof propagateDependencyChanges === "function") propagateDependencyChanges(index);
          if (typeof updateChartRange === "function") updateChartRange();
          saveTasks();
        });
        phaseDropdownContainer.appendChild(phaseDropdown);
      }
      if (actionsEl) actionsEl.style.display = "";
      tooltipEl.style.borderColor = hexToRgba(getPhaseColor(t.phase || PHASES[0]?.id), 0.24);
      tooltipEl.classList.add("has-actions", "visible");
      const rect = bar.getBoundingClientRect();
      tooltipEl.style.left = rect.left + rect.width / 2 + "px";
      tooltipEl.style.transform = "translate(-50%, calc(-100% - 8px))";
      tooltipEl.style.top = rect.top + "px";
      selectedBarClickOutside = (e) => {
        if (bar.contains(e.target) || tooltipEl.contains(e.target)) return;
        if (tooltipEl.contains(document.activeElement)) return;
        if (e.target.closest(".gantt-phase-dropdown-list") || e.target.closest(".gantt-party-dropdown-list")) return;
        const depLineEl = document.getElementById("ganttDependencyLine");
        const childContainer = document.getElementById("ganttChildConnectorsContainer");
        if ((depLineEl && depLineEl.contains(e.target)) || (childContainer && childContainer.contains(e.target))) return;
        deselectBar();
      };
      document.addEventListener("click", selectedBarClickOutside);
      
      // Show connectors to child tasks
      const childTasks = tasks.map((task, idx) => ({ task, idx })).filter(({ task }) => task.dependsOn === index);
      if (childTasks.length > 0) {
        const container = document.getElementById("ganttChildConnectorsContainer");
        if (container) {
          container.innerHTML = ""; // Clear previous child connectors
          const childColor = getPhaseColor(t.phase || PHASES[0]?.id);
          let countBadge = null;
          if (childTasks.length > 1) {
            countBadge = document.createElement("div");
            countBadge.className = "gantt-connector-count-badge";
            countBadge.style.backgroundColor = childColor;
            countBadge.textContent = String(childTasks.length);
            container.appendChild(countBadge);
          }
          
          childTasks.forEach(({ task: childTask, idx: childIdx }) => {
            const childBar = document.querySelector('.gantt-bar[data-index="' + childIdx + '"]');
            if (!childBar) return;
            
            // Create SVG for this child connector
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.classList.add("gantt-dependency-line", "visible");
            svg.style.position = "fixed";
            svg.style.top = "0";
            svg.style.left = "0";
            svg.style.pointerEvents = "none";
            svg.style.zIndex = "9998";
            
            const pathHover = document.createElementNS("http://www.w3.org/2000/svg", "path");
            pathHover.setAttribute("stroke", "transparent");
            pathHover.setAttribute("stroke-width", "12");
            pathHover.setAttribute("fill", "none");
            pathHover.style.pointerEvents = "none";
            
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("stroke", childColor);
            path.setAttribute("stroke-width", "1");
            path.setAttribute("stroke-dasharray", "4 3");
            path.setAttribute("fill", "none");
            path.style.pointerEvents = "none";
            
            const dot1 = document.createElementNS("http://www.w3.org/2000/svg", "g");
            dot1.setAttribute("class", "connector-dot");
            const dot1Circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            dot1Circle.setAttribute("r", "3");
            dot1Circle.setAttribute("fill", "white");
            dot1Circle.setAttribute("stroke", "#d4d4d4");
            dot1Circle.setAttribute("stroke-width", "1");
            dot1.appendChild(dot1Circle);
            dot1.style.pointerEvents = "none";
            
            const dot2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
            dot2.setAttribute("class", "connector-dot");
            const dot2Circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            dot2Circle.setAttribute("r", "3");
            dot2Circle.setAttribute("fill", "white");
            dot2Circle.setAttribute("stroke", "#d4d4d4");
            dot2Circle.setAttribute("stroke-width", "1");
            dot2.appendChild(dot2Circle);
            dot2.style.pointerEvents = "none";
            
            svg.appendChild(pathHover);
            svg.appendChild(path);
            svg.appendChild(dot1);
            svg.appendChild(dot2);
            container.appendChild(svg);
            
            // Create unlink button for this child
            const unlinkBtn = document.createElement("button");
            unlinkBtn.className = "gantt-dependency-unlink-btn visible";
            unlinkBtn.type = "button";
            unlinkBtn.title = "Unlink tasks";
            unlinkBtn.style.backgroundColor = childColor;
            unlinkBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/>
              <path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/>
              <line x1="8" y1="2" x2="8" y2="5"/>
              <line x1="2" y1="8" x2="5" y2="8"/>
              <line x1="16" y1="19" x2="16" y2="22"/>
              <line x1="19" y1="16" x2="22" y2="16"/>
            </svg>`;
            container.appendChild(unlinkBtn);
            
            const updateChildLine = () => {
              const pr = bar.getBoundingClientRect();
              const cr = childBar.getBoundingClientRect();
              const x1 = pr.left + pr.width / 2;
              const y1 = pr.bottom;
              const x2 = cr.left;
              const y2 = cr.top + cr.height / 2;
              const pathD = connectorPathD(x1, y1, x2, y2);
              path.setAttribute("d", pathD);
              pathHover.setAttribute("d", pathD);
              const dotR = 3;
              dot1.setAttribute("transform", `translate(${x1}, ${y1 - dotR})`);
              dot2.setAttribute("transform", `translate(${x2}, ${y2})`);
              svg.setAttribute("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight);
              svg.setAttribute("width", window.innerWidth);
              svg.setAttribute("height", window.innerHeight);
              unlinkBtn.style.left = x1 + "px";
              unlinkBtn.style.top = y2 + "px";
              if (countBadge) {
                const badgeOffsetY = 36;
                countBadge.style.left = x1 + "px";
                countBadge.style.top = (y1 + badgeOffsetY) + "px";
              }
            };
            updateChildLine();
            
            // Unlink handler
            const unlinkHandler = () => {
              const childName = (childTask.star ? " " : "") + (childTask.task || "Task");
              const parentName = (t.star ? " " : "") + (t.task || "Task");
              pushTasksUndo();
              childTask.dependsOn = null;
              deselectBar();
              saveTasks();
              renderTasks();
              showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/><path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/><line x1="8" y1="2" x2="8" y2="5"/><line x1="2" y1="8" x2="5" y2="8"/><line x1="16" y1="19" x2="16" y2="22"/><line x1="19" y1="16" x2="22" y2="16"/></svg> "${childName}" unlinked from "${parentName}"`, { onUndo: performUndo });
            };
            unlinkBtn.addEventListener("click", unlinkHandler);
            
            // Hover handlers
            let hoverTimer = null;
            const showBtn = () => {
              if (hoverTimer) clearTimeout(hoverTimer);
              unlinkBtn.classList.add("visible");
            };
            const hideBtn = () => {
              hoverTimer = setTimeout(() => {
                if (selectedBarElement === bar) unlinkBtn.classList.add("visible");
                else unlinkBtn.classList.remove("visible");
              }, 200);
            };
            svg.addEventListener("mouseenter", showBtn);
            svg.addEventListener("mouseleave", hideBtn);
            unlinkBtn.addEventListener("mouseenter", showBtn);
            unlinkBtn.addEventListener("mouseleave", hideBtn);
            
            // Scroll/resize handlers
            const wrapper = document.querySelector(".gantt-wrapper");
            wrapper?.addEventListener("scroll", updateChildLine, true);
            window.addEventListener("scroll", updateChildLine, true);
            window.addEventListener("resize", updateChildLine);
            
            // Store cleanup
            if (!selectedBarDepLineCleanup) {
              selectedBarDepLineCleanup = () => {};
            }
            const prevCleanup = selectedBarDepLineCleanup;
            selectedBarDepLineCleanup = () => {
              prevCleanup();
              wrapper?.removeEventListener("scroll", updateChildLine, true);
              window.removeEventListener("scroll", updateChildLine, true);
              window.removeEventListener("resize", updateChildLine);
              svg.removeEventListener("mouseenter", showBtn);
              svg.removeEventListener("mouseleave", hideBtn);
              unlinkBtn.removeEventListener("mouseenter", showBtn);
              unlinkBtn.removeEventListener("mouseleave", hideBtn);
              unlinkBtn.removeEventListener("click", unlinkHandler);
            };
          });
        }
      }
    }

    function createPhaseSelect(task, bar, phaseDotEl, taskIndex) {
      const wrap = document.createElement("div");
      wrap.className = "gantt-phase-dropdown-wrap";
      wrap.style.display = "flex";
      wrap.style.alignItems = "center";
      wrap.style.gap = "6px";
      wrap.style.minWidth = "0";
      const primaryWrap = document.createElement("div");
      primaryWrap.className = "gantt-phase-dropdown";
      const trigger = document.createElement("button");
      trigger.type = "button";
      trigger.className = "gantt-phase-dropdown-trigger";
      const dot = document.createElement("span");
      dot.className = "phase-dot";
      dot.style.background = getPhaseColor(task.phase || PHASES[0]?.id);
      const label = document.createElement("span");
      const primaryId = task.phase || PHASES[0]?.id;
      const secondaryId = task.phaseSecondary && task.phaseSecondary !== primaryId ? task.phaseSecondary : null;
      label.textContent = secondaryId
        ? (PHASES.find(p => p.id === primaryId)?.name || primaryId) + " \u2192 " + (PHASES.find(p => p.id === secondaryId)?.name || secondaryId)
        : (PHASES.find(p => p.id === primaryId)?.name || primaryId);
      const chevron = document.createElement("span");
      chevron.className = "phase-chevron";
      chevron.textContent = "\u25BC";
      trigger.appendChild(dot);
      trigger.appendChild(label);
      trigger.appendChild(chevron);
      const list = document.createElement("div");
      list.className = "gantt-phase-dropdown-list";
      const hint = document.createElement("div");
      hint.className = "gantt-phase-dropdown-hint";
      hint.textContent = "Shift+click for 2nd phase";
      hint.style.cssText = "font-size:10px;color:#a3a3a3;padding:4px 10px 6px;border-bottom:1px solid #ebebeb;";
      list.appendChild(hint);
      PHASES.forEach(p => {
        const opt = document.createElement("button");
        opt.type = "button";
        opt.className = "gantt-phase-dropdown-option";
        opt.dataset.phaseId = p.id;
        const optDot = document.createElement("span");
        optDot.className = "phase-dot";
        optDot.style.background = p.color;
        opt.appendChild(optDot);
        const optLabel = document.createElement("span");
        optLabel.textContent = p.name;
        opt.appendChild(optLabel);
        opt.addEventListener("click", (e) => {
          e.stopPropagation();
          if (e.shiftKey) {
            task.phaseSecondary = task.phaseSecondary === p.id ? null : (p.id === (task.phase || PHASES[0]?.id) ? null : p.id);
            saveTasks();
            setBarPhaseStyle(bar, task);
            updatePhaseLabel();
            updateListOptionStates();
            renderTasks();
          } else {
            const oldPhase = task.phase;
            task.phase = p.id;
            task.phaseSecondary = null;
            if (typeof taskIndex === "number" && oldPhase !== p.id && !getAllowIndependentDependencies()) {
              tasks.forEach((t) => {
                if (t.dependsOn === taskIndex) {
                  t.phase = p.id;
                  t.phaseSecondary = null;
                }
              });
            }
            saveTasks();
            setBarPhaseStyle(bar, task);
            updatePhaseLabel();
            updateListOptionStates();
            primaryWrap.classList.remove("open");
            if (list.parentNode) list.remove();
            renderPhaseHeaders();
            renderTasks();
          }
        });
        list.appendChild(opt);
      });
      function updateListOptionStates() {
        const pid = task.phase || PHASES[0]?.id;
        const sid = task.phaseSecondary && task.phaseSecondary !== pid ? task.phaseSecondary : null;
        list.querySelectorAll(".gantt-phase-dropdown-option").forEach((o) => {
          const id = o.dataset.phaseId;
          o.classList.remove("selected", "phase-primary", "phase-secondary");
          if (id === pid) o.classList.add("selected", "phase-primary");
          if (id === sid) o.classList.add("phase-secondary");
        });
      }
      trigger.addEventListener("click", (e) => {
        e.stopPropagation();
        const wasOpen = primaryWrap.classList.contains("open");
        document.querySelectorAll(".gantt-phase-dropdown-list").forEach(el => { if (el !== list) el.remove(); });
        primaryWrap.classList.toggle("open");
        if (!wasOpen && primaryWrap.classList.contains("open")) {
          updateListOptionStates();
          const cell = trigger.closest(".gantt-phase-cell");
          const r = cell ? cell.getBoundingClientRect() : trigger.getBoundingClientRect();
          list.style.left = r.left + "px";
          list.style.top = r.bottom + "px";
          list.style.right = "auto";
          list.style.minWidth = r.width + "px";
          list.style.display = "block";
          document.body.appendChild(list);
          requestAnimationFrame(() => {
            const lr = list.getBoundingClientRect();
            if (lr.right > window.innerWidth) list.style.left = (window.innerWidth - lr.width - 8) + "px";
            if (lr.left < 8) list.style.left = "8px";
          });
        } else if (!primaryWrap.classList.contains("open") && list.parentNode) list.remove();
      });
      document.addEventListener("click", (e) => {
        if (!wrap.contains(e.target) && !list.contains(e.target)) {
          primaryWrap.classList.remove("open");
          if (list.parentNode) list.remove();
        }
      });
      primaryWrap.appendChild(trigger);
      wrap.appendChild(primaryWrap);

      function updatePhaseLabel() {
        const pid = task.phase || PHASES[0]?.id;
        const sid = task.phaseSecondary && task.phaseSecondary !== pid ? task.phaseSecondary : null;
        if (PHASES.length === 0 && !pid) {
          label.textContent = "Add phases in Settings";
        } else {
          label.textContent = sid
            ? (PHASES.find(x => x.id === pid)?.name || pid) + " \u2192 " + (PHASES.find(x => x.id === sid)?.name || sid)
            : (PHASES.find(x => x.id === pid)?.name || pid);
        }
        dot.style.background = getPhaseColor(pid);
      }
      wrap._updateLabel = (phaseId) => {
        task.phase = phaseId;
        task.phaseSecondary = null;
        updatePhaseLabel();
      };
      wrap._setPhaseSecondary = (secondaryId) => {
        task.phaseSecondary = secondaryId || null;
        updatePhaseLabel();
      };
      return wrap;
    }

    function createTooltipPhaseDropdown(currentPhaseId, currentPhaseSecondaryId, onSelect) {
      const wrap = document.createElement("div");
      wrap.className = "gantt-phase-dropdown gantt-bar-tooltip-phase-dropdown";
      const trigger = document.createElement("button");
      trigger.type = "button";
      trigger.className = "gantt-phase-dropdown-trigger";
      const dot = document.createElement("span");
      dot.className = "phase-dot";
      dot.style.background = getPhaseColor(currentPhaseId || PHASES[0]?.id);
      const label = document.createElement("span");
      const sid = currentPhaseSecondaryId && currentPhaseSecondaryId !== currentPhaseId ? currentPhaseSecondaryId : null;
      if (PHASES.length === 0 && !currentPhaseId) {
        label.textContent = "Add phases in Settings";
      } else {
        label.textContent = sid
          ? (PHASES.find(p => p.id === currentPhaseId)?.name || currentPhaseId) + " \u2192 " + (PHASES.find(p => p.id === sid)?.name || sid)
          : (PHASES.find(p => p.id === currentPhaseId)?.name || currentPhaseId || PHASES[0]?.name);
      }
      const chevron = document.createElement("span");
      chevron.className = "phase-chevron";
      chevron.textContent = "\u25BC";
      trigger.appendChild(dot);
      trigger.appendChild(label);
      trigger.appendChild(chevron);
      const list = document.createElement("div");
      list.className = "gantt-phase-dropdown-list gantt-bar-tooltip-phase-dropdown-list";
      const hint = document.createElement("div");
      hint.className = "gantt-phase-dropdown-hint";
      hint.textContent = PHASES.length === 0 ? "Add phases in project Settings" : "Shift+click for 2nd phase";
      hint.style.cssText = "font-size:10px;color:#a3a3a3;padding:4px 10px 6px;border-bottom:1px solid #404040;";
      list.appendChild(hint);
      PHASES.forEach(p => {
        const opt = document.createElement("button");
        opt.type = "button";
        opt.className = "gantt-phase-dropdown-option";
        if (p.id === currentPhaseId) opt.classList.add("selected");
        if (currentPhaseSecondaryId && currentPhaseSecondaryId !== currentPhaseId && p.id === currentPhaseSecondaryId) opt.classList.add("phase-secondary");
        opt.dataset.phaseId = p.id;
        const optDot = document.createElement("span");
        optDot.className = "phase-dot";
        optDot.style.background = p.color;
        opt.appendChild(optDot);
        opt.appendChild(document.createTextNode(p.name));
        opt.addEventListener("click", (e) => {
          const isSecondary = e.shiftKey;
          onSelect(p.id, isSecondary);
          if (!isSecondary) {
            wrap._updateLabel(p.id, null);
            wrap.classList.remove("open");
            if (list.parentNode) list.remove();
          }
        });
        list.appendChild(opt);
      });
      trigger.addEventListener("click", (e) => {
        e.stopPropagation();
        const wasOpen = wrap.classList.contains("open");
        wrap.classList.toggle("open");
        if (!wasOpen && wrap.classList.contains("open")) {
          document.body.appendChild(list);
          list.style.display = "block";
          const r = trigger.getBoundingClientRect();
          list.style.left = r.left + "px";
          list.style.top = r.bottom + "px";
          list.style.right = "auto";
          list.style.minWidth = r.width + "px";
          requestAnimationFrame(() => {
            const lr = list.getBoundingClientRect();
            if (lr.right > window.innerWidth) list.style.left = (window.innerWidth - lr.width - 8) + "px";
            if (lr.left < 8) list.style.left = "8px";
          });
        } else if (!wrap.classList.contains("open")) {
          if (list.parentNode) list.remove();
        }
      });
      document.addEventListener("click", (e) => {
        if (!wrap.contains(e.target) && !list.contains(e.target)) {
          wrap.classList.remove("open");
          if (list.parentNode) list.remove();
        }
      });
      wrap.appendChild(trigger);
      wrap._tooltipList = list;
      wrap._updateLabel = (phaseId, phaseSecondaryId) => {
        const p = PHASES.find(x => x.id === phaseId);
        const sid = phaseSecondaryId && phaseSecondaryId !== phaseId ? phaseSecondaryId : null;
        if (p) {
          label.textContent = sid
            ? p.name + " \u2192 " + (PHASES.find(x => x.id === sid)?.name || sid)
            : p.name;
          dot.style.background = p.color;
        }
      };
      wrap._updateOptionStates = (primaryId, secondaryId) => {
        list.querySelectorAll(".gantt-phase-dropdown-option").forEach((o) => {
          const id = o.dataset.phaseId;
          o.classList.remove("selected", "phase-secondary");
          if (id === primaryId) o.classList.add("selected");
          if (secondaryId && secondaryId !== primaryId && id === secondaryId) o.classList.add("phase-secondary");
        });
      };
      return wrap;
    }

    function updateGanttDragGuide(leftPx) {
      const guideEl = document.getElementById("ganttDragGuide");
      if (!guideEl) return;
      const headerRow = document.getElementById("ganttHeaderRow");
      const wrapper = document.getElementById("ganttWrapper");
      guideEl.style.left = leftPx + "px";
      if (headerRow && wrapper) {
        const hRect = headerRow.getBoundingClientRect();
        const wRect = wrapper.getBoundingClientRect();
        const tableTop = hRect.bottom;
        const tableHeight = Math.max(0, wRect.bottom - tableTop);
        guideEl.style.top = tableTop + "px";
        guideEl.style.height = tableHeight + "px";
      } else {
        guideEl.style.top = "0";
        guideEl.style.height = "100vh";
      }
      guideEl.classList.add("visible");
    }

    function createBar(task, dateCell, timelineCell, index) {
      const bar = document.createElement("div");
      bar.className = "gantt-bar";
      bar.dataset.index = index;
      bar.dataset.phase = task.phase || PHASES[0]?.id;
      bar.title = "Drag to move  Drag edges to resize  Click to select";
      const barStroke = document.createElement("div");
      barStroke.className = "gantt-bar-stroke";
      const barInner = document.createElement("div");
      barInner.className = "gantt-bar-inner";
      bar.appendChild(barStroke);
      bar.appendChild(barInner);
      setBarPhaseStyle(bar, task);
      const startOffset = Math.max(0, dateToOffset(task.startDate));
      let endOffset = dateToOffset(task.endDate);
      if (endOffset <= startOffset) endOffset = startOffset + 1/7;
      endOffset = Math.min(WEEKS, endOffset);
      bar.style.left = (startOffset / WEEKS) * 100 + "%";
      bar.style.width = ((endOffset - startOffset) / WEEKS) * 100 + "%";
      const durationHintHover = document.createElement("span");
      durationHintHover.className = "gantt-bar-duration-hint gantt-bar-duration-hint-hover";
      const updateHoverHint = () => {
        if (!task.startDate || !task.endDate) return;
        const days = Math.max(1, Math.ceil((task.endDate - task.startDate) / (24 * 60 * 60 * 1000)) + 1);
        durationHintHover.textContent = days + " day" + (days !== 1 ? "s" : "");
      };
      updateHoverHint();
      bar.appendChild(durationHintHover);
      bar.addEventListener("mouseenter", updateHoverHint);
      const resizeHandleLeft = document.createElement("span");
      resizeHandleLeft.className = "resize-handle resize-handle-left";
      const resizeHandle = document.createElement("span");
      resizeHandle.className = "resize-handle";
      const DRAG_THRESHOLD_PX = 5;
      bar.addEventListener("mousedown", (e) => {
        if (e.target.closest(".resize-handle")) return;
        e.preventDefault();
        const startX = e.clientX;
        const startY = e.clientY;
        let dragStarted = false;
        let durationHint = null;
        let snapIndicator = null;
        let lastClientX = e.clientX;
        let currentLeft = parseFloat(bar.style.left);
        const barWidth = parseFloat(bar.style.width);
        const durationDays = (task.endDate - task.startDate) / (24*60*60*1000);
        let moved = false;
        let lastShownBoundary = null;
        const updateGuide = () => {
          const r = bar.getBoundingClientRect();
          updateGanttDragGuide(r.left);
        };
        const hideGuide = () => {
          const guideEl = document.getElementById("ganttDragGuide");
          if (guideEl) { guideEl.classList.remove("visible", "snap-zone"); }
        };
        const updateDurationHint = () => {
          if (!durationHint) return;
          const w = parseFloat(bar.style.width);
          const days = Math.max(1, Math.round((w / 100) * WEEKS * 7));
          durationHint.textContent = days + " day" + (days !== 1 ? "s" : "");
        };
        function startDrag() {
          if (dragStarted) return;
          dragStarted = true;
          deselectBar();
          bar.classList.add("dragging");
          lastBarChangeOriginalStartDate = new Date(task.startDate);
          lastBarChangeOriginalEndDate = new Date(task.endDate);
          if (typeof task.dependsOn === "number" && tasks[task.dependsOn]) {
            lastBarChangeOriginalDurationMs = task.endDate.getTime() - task.startDate.getTime();
            lastBarChangeTaskIndex = index;
          }
          durationHint = document.createElement("span");
          durationHint.className = "gantt-bar-duration-hint";
          bar.appendChild(durationHint);
          snapIndicator = document.createElement("span");
          snapIndicator.className = "gantt-bar-snap-indicator";
          snapIndicator.title = "Will snap to sprint";
          snapIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.5 14.98c.02 0 .03.01.05.01 1.4 0 2.5-1.1 2.5-2.5V8c0-1.4-1.1-2.5-2.5-2.5h-3c-.28 0-.5.22-.5.5v7c0 1.4 1.1 2.48 2.5 2.48M20 7h2c.55 0 1 .45 1 1v4.5c0 .55-.45 1-1 1s-1-.45-1-1V7zM6.5 5.5h-3C2.1 5.5 1 6.6 1 8v4.5c0 1.4 1.1 2.5 2.5 2.5.02 0 .03-.01.05-.01C5.05 14.98 6 13.9 6 12.5v-7c0-.28-.22-.5-.5-.5M4 7v5.5c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1h2zM15.5 16H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 16H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 19H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M15.5 19H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5"/></svg>';
          bar.appendChild(snapIndicator);
          updateDurationHint();
          updateGuide();
        }
        const onMove = (e2) => {
          if (!dragStarted) {
            if (Math.hypot(e2.clientX - startX, e2.clientY - startY) < DRAG_THRESHOLD_PX) return;
            startDrag();
            lastClientX = e2.clientX;
          }
          moved = true;
          const w = timelineCell.offsetWidth;
          if (w <= 0) return;
          const dxPct = (e2.clientX - lastClientX) / w * 100;
          lastClientX = e2.clientX;
          currentLeft = Math.max(-100, Math.min(100 - barWidth, currentLeft + dxPct));
          bar.style.left = currentLeft + "%";
          updateDurationHint();
          updateGuide();
          const offset = (currentLeft / 100) * WEEKS;
          const rawStart = offsetToDate(offset);
          const inSnapZone = wouldSnapToSprint(rawStart);
          const guideEl = document.getElementById("ganttDragGuide");
          if (guideEl) guideEl.classList.toggle("snap-zone", inSnapZone);
          snapIndicator.classList.toggle("visible", inSnapZone);
          if (inSnapZone) {
            const boundaryInfo = getSprintBoundaryInfo(rawStart);
            if (boundaryInfo) {
              const boundaryKey = boundaryInfo.date.getTime() + "-" + boundaryInfo.type;
              if (lastShownBoundary !== boundaryKey) {
                lastShownBoundary = boundaryKey;
                showToast(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.5 14.98c.02 0 .03.01.05.01 1.4 0 2.5-1.1 2.5-2.5V8c0-1.4-1.1-2.5-2.5-2.5h-3c-.28 0-.5.22-.5.5v7c0 1.4 1.1 2.48 2.5 2.48M20 7h2c.55 0 1 .45 1 1v4.5c0 .55-.45 1-1 1s-1-.45-1-1V7zM6.5 5.5h-3C2.1 5.5 1 6.6 1 8v4.5c0 1.4 1.1 2.5 2.5 2.5.02 0 .03-.01.05-.01C5.05 14.98 6 13.9 6 12.5v-7c0-.28-.22-.5-.5-.5M4 7v5.5c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1h2zM15.5 16H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 16H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 19H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M15.5 19H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5"/></svg> Snap to: Sprint ${boundaryInfo.type}  ${formatDate(boundaryInfo.date)}`);
              }
            }
          } else {
            lastShownBoundary = null;
          }
          task.startDate = rawStart;
          task.endDate = new Date(task.startDate.getTime() + durationDays * 24 * 60 * 60 * 1000);
          currentLeft = (dateToOffset(task.startDate) / WEEKS) * 100;
          bar.style.left = currentLeft + "%";
          task.start = formatDate(task.startDate);
          task.end = formatDate(task.endDate);
          const phaseAtPos = getPhaseForWeekOffset(dateToOffset(task.startDate), index);
          const oldPhase = task.phase;
          if (phaseAtPos && phaseAtPos !== task.phase) {
            task.phase = phaseAtPos;
            task.phaseSecondary = null;
            setBarPhaseStyle(bar, task);
            // Update child tasks to the same phase (only when not using independent deps)
            if (!getAllowIndependentDependencies()) {
              tasks.forEach((t, childIdx) => {
                if (t.dependsOn === index) {
                  t.phase = phaseAtPos;
                  t.phaseSecondary = null;
                  const childBar = grid?.querySelector(`.gantt-bar[data-index="${childIdx}"]`);
                  if (childBar) setBarPhaseStyle(childBar, t);
                }
              });
            }
          } else {
            setBarPhaseStyle(bar, task);
          }
          const startInp = dateCell.querySelector('.gantt-date-start');
          const endInp = dateCell.querySelector('.gantt-date-end');
          if (startInp) startInp.value = task.start;
          if (endInp) endInp.value = task.end;
          propagateDependencyChanges(index, undefined, undefined, true);
        };
        const onUp = () => {
          hideGuide();
          if (durationHint) durationHint.remove();
          if (snapIndicator) snapIndicator.remove();
          if (dragStarted) bar.classList.remove("dragging");
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
          if (!dragStarted || !moved) {
            return;
          }
          if (wouldSnapToSprint(task.startDate)) {
            const snapped = snapDateToSprint(task.startDate);
            const durationMs = task.endDate.getTime() - task.startDate.getTime();
            task.startDate = snapped;
            task.endDate = new Date(snapped.getTime() + durationMs);
            task.start = formatDate(task.startDate);
            task.end = formatDate(task.endDate);
            const startOffset = dateToOffset(task.startDate);
            const endOffset = dateToOffset(task.endDate);
            bar.style.left = (startOffset / WEEKS) * 100 + "%";
            bar.style.width = ((endOffset - startOffset) / WEEKS) * 100 + "%";
            const startInp = dateCell.querySelector('.gantt-date-start');
            const endInp = dateCell.querySelector('.gantt-date-end');
            if (startInp) startInp.value = task.start;
            if (endInp) endInp.value = task.end;
            propagateDependencyChanges(index, undefined, undefined, false);
          }
          // Save tasks after move to persist phase changes
          saveTasks();
          // Update phase dropdowns to reflect new phase (parent and children)
          const row = bar.closest(".gantt-row");
          if (row) {
            const phaseDropdown = row.querySelector(".gantt-phase-dropdown");
            if (phaseDropdown && phaseDropdown._updateLabel) {
              phaseDropdown._updateLabel(task.phase);
            }
          }
          // Update child phase dropdowns
          tasks.forEach((t, childIdx) => {
            if (t.dependsOn === index) {
              const childRow = grid?.querySelector(`.gantt-row[data-index="${childIdx}"]`);
              if (childRow) {
                const childPhaseWrap = childRow.querySelector(".gantt-phase-dropdown-wrap");
                if (childPhaseWrap && childPhaseWrap._updateLabel) {
                  childPhaseWrap._updateLabel(t.phase);
                }
              }
            }
          });
          if (typeof onBarChangeEnd === "function") onBarChangeEnd(index);
        };
        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
      });
      bar.addEventListener("click", (e) => {
        if (e.target.closest(".resize-handle") || e.target.closest(".resize-handle-left")) return;
        e.stopPropagation();
        if (typeof selectBar === "function") selectBar(bar, index);
      });
      resizeHandleLeft.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        deselectBar();
        bar.classList.add("resizing");
        lastBarChangeOriginalStartDate = new Date(task.startDate);
        lastBarChangeOriginalEndDate = new Date(task.endDate);
        if (typeof task.dependsOn === "number" && tasks[task.dependsOn]) {
          lastBarChangeOriginalDurationMs = task.endDate.getTime() - task.startDate.getTime();
          lastBarChangeTaskIndex = index;
        }
        const durationHint = document.createElement("span");
        durationHint.className = "gantt-bar-duration-hint";
        bar.appendChild(durationHint);
        const snapIndicator = document.createElement("span");
        snapIndicator.className = "gantt-bar-snap-indicator";
        snapIndicator.title = "Will snap to sprint";
        snapIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.5 14.98c.02 0 .03.01.05.01 1.4 0 2.5-1.1 2.5-2.5V8c0-1.4-1.1-2.5-2.5-2.5h-3c-.28 0-.5.22-.5.5v7c0 1.4 1.1 2.48 2.5 2.48M20 7h2c.55 0 1 .45 1 1v4.5c0 .55-.45 1-1 1s-1-.45-1-1V7zM6.5 5.5h-3C2.1 5.5 1 6.6 1 8v4.5c0 1.4 1.1 2.5 2.5 2.5.02 0 .03-.01.05-.01C5.05 14.98 6 13.9 6 12.5v-7c0-.28-.22-.5-.5-.5M4 7v5.5c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1h2zM15.5 16H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 16H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 19H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M15.5 19H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5"/></svg>';
        bar.appendChild(snapIndicator);
        const updateDurationHint = () => {
          const w = parseFloat(bar.style.width);
          const days = Math.max(1, Math.round((w / 100) * WEEKS * 7));
          durationHint.textContent = days + " day" + (days !== 1 ? "s" : "");
        };
        updateDurationHint();
        const updateGuide = () => {
          const guideEl = document.getElementById("ganttDragGuide");
          if (!guideEl) return;
          const r = bar.getBoundingClientRect();
          guideEl.style.left = r.left + "px";
          guideEl.style.top = "0";
          guideEl.style.height = "100vh";
          guideEl.classList.add("visible");
        };
        const hideGuide = () => {
          const guideEl = document.getElementById("ganttDragGuide");
          if (guideEl) { guideEl.classList.remove("visible", "snap-zone"); }
        };
        updateGuide();
        let lastClientX = e.clientX;
        let currentLeft = parseFloat(bar.style.left);
        let currentWidth = parseFloat(bar.style.width);
        const rightEdge = currentLeft + currentWidth;
        let lastShownBoundary = null;
        const onMove = (e2) => {
          const w = timelineCell.offsetWidth;
          if (w <= 0) return;
          const dxPct = (e2.clientX - lastClientX) / w * 100;
          lastClientX = e2.clientX;
          currentLeft = Math.max(-100, Math.min(rightEdge - 2, currentLeft + dxPct));
          currentWidth = rightEdge - currentLeft;
          bar.style.left = currentLeft + "%";
          bar.style.width = currentWidth + "%";
          updateDurationHint();
          updateGuide();
          const startOffset = (currentLeft / 100) * WEEKS;
          const rawStart = offsetToDate(startOffset);
          const inSnapZone = wouldSnapToSprint(rawStart);
          const guideEl = document.getElementById("ganttDragGuide");
          if (guideEl) guideEl.classList.toggle("snap-zone", inSnapZone);
          snapIndicator.classList.toggle("visible", inSnapZone);
          if (inSnapZone) {
            const boundaryInfo = getSprintBoundaryInfo(rawStart);
            if (boundaryInfo) {
              const boundaryKey = boundaryInfo.date.getTime() + "-" + boundaryInfo.type;
              if (lastShownBoundary !== boundaryKey) {
                lastShownBoundary = boundaryKey;
                showToast(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.5 14.98c.02 0 .03.01.05.01 1.4 0 2.5-1.1 2.5-2.5V8c0-1.4-1.1-2.5-2.5-2.5h-3c-.28 0-.5.22-.5.5v7c0 1.4 1.1 2.48 2.5 2.48M20 7h2c.55 0 1 .45 1 1v4.5c0 .55-.45 1-1 1s-1-.45-1-1V7zM6.5 5.5h-3C2.1 5.5 1 6.6 1 8v4.5c0 1.4 1.1 2.5 2.5 2.5.02 0 .03-.01.05-.01C5.05 14.98 6 13.9 6 12.5v-7c0-.28-.22-.5-.5-.5M4 7v5.5c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1h2zM15.5 16H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 16H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 19H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M15.5 19H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5"/></svg> Snap to: Sprint ${boundaryInfo.type}  ${formatDate(boundaryInfo.date)}`);
              }
            }
          } else {
            lastShownBoundary = null;
          }
          task.startDate = rawStart;
          task.endDate = offsetToDate(dateToOffset(task.startDate) + (currentWidth / 100) * WEEKS);
          currentLeft = (dateToOffset(task.startDate) / WEEKS) * 100;
          bar.style.left = currentLeft + "%";
          task.start = formatDate(task.startDate);
          task.end = formatDate(task.endDate);
          const phaseAtPos = getPhaseForWeekOffset(dateToOffset(task.startDate), index);
          if (phaseAtPos) {
            task.phase = phaseAtPos;
            task.phaseSecondary = null;
          }
          setBarPhaseStyle(bar, task);
          const startInp = dateCell.querySelector('.gantt-date-start');
          const endInp = dateCell.querySelector('.gantt-date-end');
          if (startInp) startInp.value = task.start;
          if (endInp) endInp.value = task.end;
          propagateDependencyChanges(index, undefined, undefined, true);
        };
        const onUp = () => {
          hideGuide();
          durationHint.remove();
          snapIndicator.remove();
          bar.classList.remove("resizing");
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
          if (wouldSnapToSprint(task.startDate)) {
            const snapped = snapDateToSprint(task.startDate);
            task.startDate = snapped;
            task.start = formatDate(task.startDate);
            task.endDate = offsetToDate(dateToOffset(task.startDate) + (currentWidth / 100) * WEEKS);
            task.end = formatDate(task.endDate);
            const startOffset = dateToOffset(task.startDate);
            const endOffset = dateToOffset(task.endDate);
            bar.style.left = (startOffset / WEEKS) * 100 + "%";
            bar.style.width = ((endOffset - startOffset) / WEEKS) * 100 + "%";
            const startInp = dateCell.querySelector('.gantt-date-start');
            const endInp = dateCell.querySelector('.gantt-date-end');
            if (startInp) startInp.value = task.start;
            if (endInp) endInp.value = task.end;
            propagateDependencyChanges(index, undefined, undefined, false);
          }
          if (typeof onBarChangeEnd === "function") onBarChangeEnd(index);
        };
        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
      });
      bar.appendChild(resizeHandleLeft);
      resizeHandle.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        deselectBar();
        bar.classList.add("resizing");
        lastBarChangeOriginalStartDate = new Date(task.startDate);
        lastBarChangeOriginalEndDate = new Date(task.endDate);
        const durationHint = document.createElement("span");
        durationHint.className = "gantt-bar-duration-hint";
        bar.appendChild(durationHint);
        const snapIndicator = document.createElement("span");
        snapIndicator.className = "gantt-bar-snap-indicator";
        snapIndicator.title = "Will snap to sprint";
        snapIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.5 14.98c.02 0 .03.01.05.01 1.4 0 2.5-1.1 2.5-2.5V8c0-1.4-1.1-2.5-2.5-2.5h-3c-.28 0-.5.22-.5.5v7c0 1.4 1.1 2.48 2.5 2.48M20 7h2c.55 0 1 .45 1 1v4.5c0 .55-.45 1-1 1s-1-.45-1-1V7zM6.5 5.5h-3C2.1 5.5 1 6.6 1 8v4.5c0 1.4 1.1 2.5 2.5 2.5.02 0 .03-.01.05-.01C5.05 14.98 6 13.9 6 12.5v-7c0-.28-.22-.5-.5-.5M4 7v5.5c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1h2zM15.5 16H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 16H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 19H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M15.5 19H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5"/></svg>';
        bar.appendChild(snapIndicator);
        const updateDurationHint = () => {
          const w = parseFloat(bar.style.width);
          const days = Math.max(1, Math.round((w / 100) * WEEKS * 7));
          durationHint.textContent = days + " day" + (days !== 1 ? "s" : "");
        };
        updateDurationHint();
        const updateGuide = () => {
          const r = bar.getBoundingClientRect();
          updateGanttDragGuide(r.left + r.width);
        };
        const hideGuide = () => {
          const guideEl = document.getElementById("ganttDragGuide");
          if (guideEl) guideEl.classList.remove("visible", "snap-zone");
        };
        updateGuide();
        let lastClientX = e.clientX;
        let currentWidth = parseFloat(bar.style.width);
        const barLeft = parseFloat(bar.style.left);
        let lastShownBoundary = null;
        const onMove = (e2) => {
          const w = timelineCell.offsetWidth;
          if (w <= 0) return;
          const dxPct = (e2.clientX - lastClientX) / w * 100;
          lastClientX = e2.clientX;
          currentWidth = Math.max(2, Math.min(100 - barLeft, currentWidth + dxPct));
          const rawEndDate = offsetToDate(dateToOffset(task.startDate) + (currentWidth / 100) * WEEKS);
          const inSnapZone = wouldSnapToSprint(rawEndDate);
          const guideEl = document.getElementById("ganttDragGuide");
          if (guideEl) guideEl.classList.toggle("snap-zone", inSnapZone);
          snapIndicator.classList.toggle("visible", inSnapZone);
          if (inSnapZone) {
            const boundaryInfo = getSprintBoundaryInfo(rawEndDate);
            if (boundaryInfo) {
              const boundaryKey = boundaryInfo.date.getTime() + "-" + boundaryInfo.type;
              if (lastShownBoundary !== boundaryKey) {
                lastShownBoundary = boundaryKey;
                showToast(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21.5 14.98c.02 0 .03.01.05.01 1.4 0 2.5-1.1 2.5-2.5V8c0-1.4-1.1-2.5-2.5-2.5h-3c-.28 0-.5.22-.5.5v7c0 1.4 1.1 2.48 2.5 2.48M20 7h2c.55 0 1 .45 1 1v4.5c0 .55-.45 1-1 1s-1-.45-1-1V7zM6.5 5.5h-3C2.1 5.5 1 6.6 1 8v4.5c0 1.4 1.1 2.5 2.5 2.5.02 0 .03-.01.05-.01C5.05 14.98 6 13.9 6 12.5v-7c0-.28-.22-.5-.5-.5M4 7v5.5c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1h2zM15.5 16H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 16H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M9 19H5.5c-.28 0-.5.22-.5.5s.22.5.5.5H9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5M15.5 19H12c-.28 0-.5.22-.5.5s.22.5.5.5h3.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5"/></svg> Snap to: Sprint ${boundaryInfo.type}  ${formatDate(boundaryInfo.date)}`);
              }
            }
          } else {
            lastShownBoundary = null;
          }
          task.endDate = rawEndDate;
          const snappedEndOffset = dateToOffset(task.endDate);
          const snappedStartOffset = dateToOffset(task.startDate);
          currentWidth = ((snappedEndOffset - snappedStartOffset) / WEEKS) * 100;
          bar.style.width = Math.max(2, currentWidth) + "%";
          updateGuide();
          updateDurationHint();
          task.end = formatDate(task.endDate);
          setBarPhaseStyle(bar, task);
          const startInp = dateCell.querySelector('.gantt-date-start');
          const endInp = dateCell.querySelector('.gantt-date-end');
          if (startInp) startInp.value = task.start;
          if (endInp) endInp.value = task.end;
          propagateDependencyChanges(index, undefined, undefined, true);
        };
        const onUp = () => {
          hideGuide();
          durationHint.remove();
          snapIndicator.remove();
          bar.classList.remove("resizing");
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onUp);
          if (wouldSnapToSprint(task.endDate)) {
            const snapped = snapDateToSprint(task.endDate);
            task.endDate = snapped;
            task.end = formatDate(task.endDate);
            const startOffset = dateToOffset(task.startDate);
            const endOffset = dateToOffset(task.endDate);
            currentWidth = ((endOffset - startOffset) / WEEKS) * 100;
            bar.style.width = Math.max(2, currentWidth) + "%";
            const endInp = dateCell.querySelector('.gantt-date-end');
            if (endInp) endInp.value = task.end;
            propagateDependencyChanges(index, undefined, undefined, false);
          }
          if (typeof onBarChangeEnd === "function") onBarChangeEnd(index);
        };
        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
      });
      bar.appendChild(resizeHandle);
      return bar;
    }

    function getPhaseTaskCount(phaseId) {
      return tasks.filter(t => t.phase === phaseId).length;
    }

    function getPhaseStartWeekOffset(phaseIndex) {
      let offset = 0;
      for (let i = 0; i < phaseIndex && i < PHASES.length; i++) {
        offset += getPhaseWeekSpan(PHASES[i].id);
      }
      return offset;
    }

    function showPhaseSelectMenu(anchorEl, taskIndex) {
      return new Promise((resolve) => {
        const popup = document.getElementById("phaseSelectMenu");
        const listEl = document.getElementById("phaseSelectMenuList");
        if (!popup || !listEl) return resolve(null);
        listEl.innerHTML = "";
        PHASES.forEach((p, i) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "phase-select-menu-item";
          btn.dataset.phaseId = p.id;
          const swatch = document.createElement("span");
          swatch.className = "phase-swatch";
          swatch.style.background = p.color;
          btn.appendChild(swatch);
          btn.appendChild(document.createTextNode(p.name));
          btn.addEventListener("click", () => {
            finish(p.id);
          });
          listEl.appendChild(btn);
        });
        const rect = anchorEl.getBoundingClientRect();
        popup.style.left = rect.left + rect.width / 2 + "px";
        const popupHeight = 120;
        const spaceBelow = window.innerHeight - rect.bottom;
        if (spaceBelow < popupHeight + 8 && rect.top > popupHeight + 8) {
          popup.style.top = rect.top - 8 + "px";
          popup.style.transform = "translate(-50%, -100%)";
        } else {
          popup.style.top = rect.bottom + 8 + "px";
          popup.style.transform = "translateX(-50%)";
        }
        popup.classList.add("visible");
        const finish = (result) => {
          popup.classList.remove("visible");
          document.removeEventListener("click", onClickOutside);
          document.removeEventListener("keydown", onEscape);
          resolve(result);
        };
        const onClickOutside = (e) => {
          if (!popup.contains(e.target) && !anchorEl.contains(e.target)) finish(null);
        };
        const onEscape = (e) => { if (e.key === "Escape") finish(null); };
        document.addEventListener("keydown", onEscape);
        requestAnimationFrame(() => document.addEventListener("click", onClickOutside));
      });
    }

    function getPhaseWeekSpan(phaseId) {
      const s = loadProjectSettings();
      if (s?.phaseDurationMode !== "dynamic") {
        const p = PHASES.find(x => x.id === phaseId);
        const sprints = Math.max(1, parseInt(p?.sprints, 10) || 2);
        return sprints * 2;
      }
      const phaseTasks = tasks.filter(t => t.phase === phaseId && t.startDate && t.endDate);
      if (phaseTasks.length === 0) return 1;
      const minStart = Math.min(...phaseTasks.map(t => t.startDate.getTime()));
      const maxEnd = Math.max(...phaseTasks.map(t => t.endDate.getTime()));
      return Math.max(1, Math.floor((maxEnd - minStart) / WEEK_MS) + 1);
    }

    function getPhaseDateRange(phaseIndex, baseDate) {
      if (phaseIndex < 0 || phaseIndex >= PHASES.length) return null;
      const startWeekOffset = getPhaseStartWeekOffset(phaseIndex);
      const spanWeeks = getPhaseWeekSpan(PHASES[phaseIndex].id);
      const startDate = new Date(baseDate.getTime() + startWeekOffset * WEEK_MS);
      const endDate = new Date(baseDate.getTime() + (startWeekOffset + spanWeeks) * WEEK_MS - DAY_MS);
      return { startDate, endDate };
    }

    function renderPhaseHeaders() {
      if (PHASES.length === 0) {
        const html = '<div class="phase-header-cell" style="grid-column:1/span 4"></div><div class="phase-header-timeline"><div class="phase-header-cell phase-header-empty" style="flex:1;background:var(--bg-hover);color:var(--text-tertiary);font-size:12px;">Add phases in Settings</div></div>';
        document.getElementById("phaseHeaderRow").innerHTML = html;
        return;
      }
      const spans = PHASES.map(p => getPhaseWeekSpan(p.id));
      const phaseCells = PHASES.map((p, i) => {
        const borderColor = getContrastColor(p.color);
        return '<div class="phase-header-cell" data-phase-id="' + p.id + '" style="flex:' + spans[i] + ';background:' + p.color + ';color:' + borderColor + '">' + p.name + '</div>';
      }).join("");
      const html = '<div class="phase-header-cell" style="grid-column:1/span 4"></div>' +
        '<div class="phase-header-timeline">' + phaseCells + '</div>';
      document.getElementById("phaseHeaderRow").innerHTML = html;
      
      // Add hover listeners to phase headers
      const timeline = document.querySelector(".phase-header-timeline");
      if (timeline) {
        const phaseCellElements = timeline.querySelectorAll(".phase-header-cell[data-phase-id]");
        phaseCellElements.forEach(cell => {
          cell.addEventListener("mouseenter", () => {
            const phaseId = cell.dataset.phaseId;
            document.querySelector(".gantt-wrapper")?.classList.add("phase-focus-active");
            // Dim all phase headers except the hovered one
            phaseCellElements.forEach(c => {
              if (c === cell) {
                c.classList.add("phase-focused");
              } else {
                c.classList.remove("phase-focused");
              }
            });
            // Dim all rows and bars except those in the hovered phase
            document.querySelectorAll(".gantt-row:not(.gantt-header)").forEach(row => {
              const taskIndex = parseInt(row.dataset.index, 10);
              const task = tasks[taskIndex];
              if (task && task.phase === phaseId) {
                row.classList.add("phase-focused");
              } else {
                row.classList.remove("phase-focused");
              }
            });
          });
          
          cell.addEventListener("mouseleave", () => {
            document.querySelector(".gantt-wrapper")?.classList.remove("phase-focus-active");
            phaseCellElements.forEach(c => c.classList.remove("phase-focused"));
            document.querySelectorAll(".gantt-row:not(.gantt-header)").forEach(row => {
              row.classList.remove("phase-focused");
            });
          });
        });
      }
    }

    function renderTaskRow(task, i) {
      const row = document.createElement("div");
      row.className = "gantt-row";
      row.dataset.index = i;
      row.draggable = true;
      const taskCell = document.createElement("div");
      taskCell.className = "gantt-cell gantt-task-cell";
      const nameWrap = document.createElement("span");
      nameWrap.className = "task-name-wrap";
      const taskText = document.createElement("span");
      taskText.className = "task-text";
      taskText.contentEditable = "false";
      taskText.textContent = (task.star ? " " : "") + task.task;
      nameWrap.appendChild(taskText);
      taskCell.appendChild(nameWrap);
      const renameBtn = document.createElement("button");
      renameBtn.className = "task-rename-btn";
      renameBtn.type = "button";
      renameBtn.title = "Rename";
      renameBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>';
      renameBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        taskText.contentEditable = "true";
        taskText.focus();
        const sel = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(taskText);
        sel.removeAllRanges();
        sel.addRange(range);
      });
      const taskActions = document.createElement("div");
      taskActions.className = "task-actions";
      taskActions.appendChild(renameBtn);
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "gantt-delete-btn";
      deleteBtn.type = "button";
      deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>';
      deleteBtn.title = "Delete task";
      deleteBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        const idx = tasks.indexOf(task);
        if (idx < 0) return;
        const dependents = tasks.filter((t, i) => i !== idx && typeof t.dependsOn === "number" && t.dependsOn === idx);
        if (dependents.length > 0) {
          const count = dependents.length;
          const msg = count === 1
            ? `"${(task.task || "Task").trim() || "This task"}" has 1 task that depends on it. Deleting will remove that dependency link.`
            : `"${(task.task || "Task").trim() || "This task"}" has ${count} tasks that depend on it. Deleting will remove those dependency links.`;
          const confirmed = await showDeleteConfirm(deleteBtn, msg);
          if (!confirmed) return;
        }
        const deletedTaskName = task.task || "Task";
        pushTasksUndo();
        tasks.forEach((t) => {
          if (typeof t.dependsOn !== "number") return;
          if (t.dependsOn === idx) t.dependsOn = null;
          else if (t.dependsOn > idx) t.dependsOn--;
        });
        tasks.splice(idx, 1);
        if (tasks.length === 0) {
          const settings = loadProjectSettings() || {};
          saveProjectSettings({ ...settings, placeholderDismissed: true });
        }
        if (typeof updateChartRange === "function") updateChartRange();
        saveTasks();
        showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Task deleted`, { onUndo: performUndo });
      });
      const duplicateBtn = document.createElement("button");
      duplicateBtn.className = "gantt-duplicate-btn";
      duplicateBtn.type = "button";
      duplicateBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
      duplicateBtn.title = "Duplicate task";
      duplicateBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const idx = tasks.indexOf(task);
        if (idx >= 0) {
          pushTasksUndo();
          const copy = {
            task: task.task,
            phase: task.phase,
            party: task.party,
            start: task.start,
            end: task.end,
            startDate: task.startDate ? new Date(task.startDate) : null,
            endDate: task.endDate ? new Date(task.endDate) : null,
            star: task.star,
            overview: task.overview || "",
            subTasks: (task.subTasks || []).slice(),
            blockers: (task.blockers || []).slice(),
            links: (task.links || []).slice(),
            dependsOn: typeof task.dependsOn === "number" ? (task.dependsOn > idx ? task.dependsOn + 1 : task.dependsOn) : null
          };
          tasks.splice(idx + 1, 0, copy);
          if (typeof updateChartRange === "function") updateChartRange();
          saveTasks();
          showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Task duplicated`, { onUndo: performUndo });
        }
      });
      taskActions.appendChild(duplicateBtn);
      taskActions.appendChild(deleteBtn);
      taskCell.appendChild(taskActions);
      const phaseCell = document.createElement("div");
      phaseCell.className = "gantt-cell gantt-phase-cell";
      const partyCell = document.createElement("div");
      partyCell.className = "gantt-cell gantt-party-cell";

      function createPartyDropdown(t) {
        const s = loadProjectSettings() || {};
        const savedParties = Array.isArray(s.responsibleParties) ? s.responsibleParties : [];
        const fromTasks = tasks.map(x => x.party).filter(Boolean);
        const opts = [...new Set([...savedParties, "Unassigned", ...fromTasks])].sort();
        const wrap = document.createElement("div");
        wrap.className = "gantt-party-dropdown";
        const trigger = document.createElement("button");
        trigger.type = "button";
        trigger.className = "gantt-party-dropdown-trigger";
        const label = document.createElement("span");
        label.textContent = t.party || "Unassigned";
        const chevron = document.createElement("span");
        chevron.className = "party-chevron";
        chevron.textContent = "\u25BC";
        trigger.appendChild(label);
        trigger.appendChild(chevron);
        const list = document.createElement("div");
        list.className = "gantt-party-dropdown-list";
        opts.forEach(p => {
          const opt = document.createElement("button");
          opt.type = "button";
          opt.className = "gantt-party-dropdown-option";
          if (p === (t.party || "Unassigned")) opt.classList.add("selected");
          opt.textContent = p;
          opt.addEventListener("click", () => {
            t.party = p;
            label.textContent = p;
            wrap.classList.remove("open");
            saveTasks();
          });
          list.appendChild(opt);
        });
        const addOpt = document.createElement("button");
        addOpt.type = "button";
        addOpt.className = "gantt-party-dropdown-option gantt-party-add-new";
        addOpt.textContent = "+ Add new...";
        addOpt.addEventListener("click", () => {
          wrap.classList.remove("open");
          const inp = document.createElement("input");
          inp.className = "gantt-party-input";
          inp.type = "text";
          inp.placeholder = "Type name and press Enter";
          inp.autocomplete = "off";
          partyCell.replaceChild(inp, wrap);
          inp.focus();
          inp.addEventListener("blur", () => {
            const v = inp.value.trim();
            t.party = v || "Unassigned";
            partyCell.replaceChild(createPartyDropdown(t), inp);
            saveTasks();
          });
          inp.addEventListener("keydown", (e) => {
            if (e.key === "Enter") { e.preventDefault(); inp.blur(); }
            if (e.key === "Escape") partyCell.replaceChild(createPartyDropdown(t), inp);
          });
        });
        list.appendChild(addOpt);
        trigger.addEventListener("click", (e) => {
          e.stopPropagation();
          const wasOpen = wrap.classList.contains("open");
          wrap.classList.toggle("open");
          if (!wasOpen && wrap.classList.contains("open")) {
          const cell = trigger.closest(".gantt-party-cell");
          const r = cell ? cell.getBoundingClientRect() : trigger.getBoundingClientRect();
          list.style.left = r.left + "px";
          list.style.top = r.bottom + "px";
          list.style.right = "auto";
          list.style.minWidth = r.width + "px";
            requestAnimationFrame(() => {
              const lr = list.getBoundingClientRect();
              if (lr.right > window.innerWidth) list.style.left = (window.innerWidth - lr.width - 8) + "px";
              if (lr.left < 8) list.style.left = "8px";
            });
          }
        });
        document.addEventListener("click", (e) => {
          if (!wrap.contains(e.target)) wrap.classList.remove("open");
        });
        wrap.appendChild(trigger);
        wrap.appendChild(list);
        return wrap;
      }
      partyCell.appendChild(createPartyDropdown(task));

      const dateCell = document.createElement("div");
      dateCell.className = "gantt-cell gantt-date-cell";
      const dateWrap = document.createElement("div");
      dateWrap.className = "gantt-date-input-wrap";
      const startInput = document.createElement("input");
      startInput.type = "text";
      startInput.className = "gantt-date-start";
      startInput.placeholder = "Start";
      startInput.value = task.start || "";
      const endInput = document.createElement("input");
      endInput.type = "text";
      endInput.className = "gantt-date-end";
      endInput.placeholder = "End";
      endInput.value = task.end || "";
      const updateFromInputs = () => {
        const startParsed = parseDateStr(startInput.value);
        const endParsed = parseDateStr(endInput.value);
        const startDate = startParsed?.start || endParsed?.start;
        const endDate = endParsed?.start || endParsed?.end || startDate;
        if (startDate) {
          task.startDate = startDate;
          task.start = formatDate(startDate);
          startInput.value = task.start;
        }
        if (endDate) {
          task.endDate = endDate;
          task.end = formatDate(endDate);
          endInput.value = task.end;
        }
        if (startDate && endDate && task.startDate.getTime() > task.endDate.getTime()) {
          task.endDate = new Date(task.startDate.getTime());
          task.end = task.start;
          endInput.value = task.end;
        }
        if (startDate || endDate) {
          if (bar) {
            const so = Math.max(0, dateToOffset(task.startDate || task.endDate));
            let eo = dateToOffset(task.endDate || task.startDate);
            if (eo <= so) eo = so + 1/7;
            eo = Math.min(WEEKS, eo);
            bar.style.left = (so / WEEKS) * 100 + "%";
            bar.style.width = ((eo - so) / WEEKS) * 100 + "%";
          }
          propagateDependencyChanges(i);
          if (typeof updateChartRange === "function") updateChartRange();
        }
      };
      startInput.addEventListener("blur", updateFromInputs);
      endInput.addEventListener("blur", updateFromInputs);
      startInput.addEventListener("keydown", (e) => { if (e.key === "Enter") startInput.blur(); });
      endInput.addEventListener("keydown", (e) => { if (e.key === "Enter") endInput.blur(); });
      const dateSep = document.createElement("span");
      dateSep.className = "gantt-date-sep";
      dateSep.textContent = "";
      dateWrap.appendChild(startInput);
      dateWrap.appendChild(dateSep);
      dateWrap.appendChild(endInput);
      dateCell.appendChild(dateWrap);
      const timelineCell = document.createElement("div");
      timelineCell.className = "gantt-cell gantt-timeline-cell";
      timelineCell.style.gridColumn = "span " + WEEKS;
      let bar = null;
      if (task.startDate && task.endDate) {
        bar = createBar(task, dateCell, timelineCell, i);
        timelineCell.appendChild(bar);
      }
      const phaseSelectEl = createPhaseSelect(task, bar, null, i);
      phaseCell.appendChild(phaseSelectEl);
      taskText.addEventListener("blur", () => {
        const t = taskText.textContent.trim();
        task.task = t.replace(/^\s*/, "");
        task.star = t.startsWith("");
        taskText.contentEditable = "false";
        saveTasks();
      });
      taskCell.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        taskText.contentEditable = "true";
        taskText.focus();
        const sel = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(taskText);
        sel.removeAllRanges();
        sel.addRange(range);
      });
      row.appendChild(taskCell);
      row.appendChild(phaseCell);
      row.appendChild(partyCell);
      row.appendChild(dateCell);
      row.appendChild(timelineCell);

      row.addEventListener("click", (e) => {
        if (e.target.closest(".gantt-delete-btn") || e.target.closest(".gantt-duplicate-btn") || e.target.closest(".gantt-bar") || e.target.closest(".resize-handle") || e.target.closest(".gantt-phase-cell") || e.target.closest(".gantt-party-cell") || e.target.closest(".gantt-date-cell")) return;
        document.querySelectorAll(".gantt-row.selected").forEach(r => r.classList.remove("selected"));
        row.classList.add("selected");
        const idx = parseInt(row.dataset.index, 10);
        if (!isNaN(idx)) expandTaskDetail(idx);
      });

      return row;
    }

    let draggedIndex = null;
    function setupRowDrag(row, index) {
      row.addEventListener("dragstart", (e) => {
        if (e.target.closest(".gantt-bar") || e.target.closest(".gantt-timeline-cell") || e.target.closest(".gantt-party-cell")) {
          e.preventDefault();
          return;
        }
        draggedIndex = index;
        row.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", index);
      });
      row.addEventListener("dragend", () => {
        row.classList.remove("dragging");
        draggedIndex = null;
      });
      row.addEventListener("dragover", (e) => {
        e.preventDefault();
        if (draggedIndex === null || draggedIndex === index) return;
      });
      row.addEventListener("drop", (e) => {
        e.preventDefault();
        const from = draggedIndex;
        const to = index;
        if (from === null || from === to) return;
        pushTasksUndo();
        const [moved] = tasks.splice(from, 1);
        tasks.splice(to, 0, moved);
        tasks.forEach((t) => {
          if (typeof t.dependsOn !== "number") return;
          const i = t.dependsOn;
          if (i === from) t.dependsOn = to;
          else if (from < i && i < to) t.dependsOn = i - 1;
          else if (i === to) t.dependsOn = to + 1;
        });
        if (typeof updateChartRange === "function") updateChartRange();
        saveTasks();
      });
    }

    const addBtn = document.createElement("button");
    addBtn.id = "addTaskFab";
    addBtn.className = "add-task-fab";
    addBtn.textContent = "+";
    addBtn.setAttribute("aria-label", "Add task");
    addBtn.setAttribute("aria-haspopup", "menu");
    addBtn.setAttribute("aria-expanded", "false");
    const fabPhaseMenu = document.getElementById("fabPhaseMenu");
    const fabPhaseMenuList = document.getElementById("fabPhaseMenuList");
    function closeFabPhaseMenu() {
      if (!fabPhaseMenu) return;
      fabPhaseMenu.classList.remove("visible");
      addBtn.setAttribute("aria-expanded", "false");
      document.removeEventListener("click", fabPhaseMenu._outsideClick);
      document.removeEventListener("keydown", fabPhaseMenu._escapeKey);
    }
    function addTaskInPhase(phaseId) {
      closeFabPhaseMenu();
      pushTasksUndo();
      const resolvedPhaseId = phaseId || PHASES[0]?.id || "";
      let startDate, endDate;
      const phaseIdx = PHASES.findIndex(p => p.id === resolvedPhaseId);
      if (resolvedPhaseId && phaseIdx >= 0 && typeof getPhaseStartWeekOffset === "function" && typeof offsetToDate === "function") {
        const startWeekOffset = getPhaseStartWeekOffset(phaseIdx);
        startDate = offsetToDate(startWeekOffset);
        endDate = new Date(startDate.getTime() + 6 * 24 * 60 * 60 * 1000); // one week from phase start
      } else {
        const now = new Date();
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        endDate = new Date(startDate.getTime() + 6 * 24 * 60 * 60 * 1000);
      }
      const newTask = { task: "New task", phase: resolvedPhaseId, party: "Unassigned", start: "", end: "", startDate, endDate, star: false, overview: "", subTasks: [], blockers: [], links: [], dependsOn: null };
      newTask.start = formatDate(newTask.startDate);
      newTask.end = formatDate(newTask.endDate);
      tasks.push(newTask);
      saveTasks();
      if (typeof updateChartRange === "function") updateChartRange();
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          const rows = grid.querySelectorAll(".gantt-row[draggable]");
          const lastRow = rows[rows.length - 1];
          if (lastRow) lastRow.scrollIntoView({ behavior: "smooth", block: "end" });
        });
      });
    }
    addBtn.onclick = (e) => {
      e.stopPropagation();
      if (fabPhaseMenu.classList.contains("visible")) {
        closeFabPhaseMenu();
        return;
      }
      const phases = PHASES.length ? PHASES : [{ id: "", name: "Default", color: "#737373" }];
      fabPhaseMenuList.innerHTML = "";
      phases.forEach((p) => {
        const item = document.createElement("button");
        item.type = "button";
        item.className = "fab-phase-menu-item";
        item.setAttribute("role", "menuitem");
        const swatch = document.createElement("span");
        swatch.className = "phase-swatch";
        swatch.style.background = p.color || "#737373";
        item.appendChild(swatch);
        item.appendChild(document.createTextNode(p.name || p.id || "Default"));
        item.dataset.phaseId = p.id;
        item.addEventListener("click", (ev) => { ev.stopPropagation(); addTaskInPhase(p.id); });
        fabPhaseMenuList.appendChild(item);
      });
      const fabRect = addBtn.getBoundingClientRect();
      fabPhaseMenu.style.left = Math.max(12, fabRect.left + fabRect.width - 200) + "px";
      fabPhaseMenu.style.right = "auto";
      fabPhaseMenu.style.bottom = (window.innerHeight - fabRect.top + 8) + "px";
      fabPhaseMenu.style.top = "auto";
      fabPhaseMenu.classList.add("visible");
      addBtn.setAttribute("aria-expanded", "true");
      fabPhaseMenu._outsideClick = (e) => {
        if (fabPhaseMenu.contains(e.target) || addBtn.contains(e.target)) return;
        closeFabPhaseMenu();
      };
      fabPhaseMenu._escapeKey = (e) => { if (e.key === "Escape") closeFabPhaseMenu(); };
      setTimeout(() => {
        document.addEventListener("click", fabPhaseMenu._outsideClick);
        document.addEventListener("keydown", fabPhaseMenu._escapeKey);
      }, 0);
    };

    function ensureOneEmptyTaskWhenEmpty() {
      if (tasks.length !== 0 || addedPlaceholderThisSession) return;
      const s = loadProjectSettings();
      if (s?.placeholderDismissed) return;
      addedPlaceholderThisSession = true;
      pushTasksUndo();
      const base = getProjectStartDate() || new Date();
      const startDate = new Date(base.getFullYear(), base.getMonth(), base.getDate());
      const endDate = new Date(startDate.getTime() + 6 * 24 * 60 * 60 * 1000);
      const empty = { task: "my first task", phase: PHASES[0]?.id || "", party: "Unassigned", start: formatDate(startDate), end: formatDate(endDate), startDate, endDate, star: false, overview: "", subTasks: [], blockers: [], links: [], dependsOn: null };
      tasks.push(empty);
      saveTasks();
    }
    function renderTasks() {
      if (!grid) return;
      ensureOneEmptyTaskWhenEmpty();
      updateEmptyState();
      deselectBar();
      collapseDetail(false);
      const existingRows = grid.querySelectorAll(".gantt-row[draggable]");
      existingRows.forEach(r => r.remove());
      tasks.forEach((task, i) => {
        const row = renderTaskRow(task, i);
        setupRowDrag(row, i);
        grid.appendChild(row);
      });
      renderPhaseHeaders();
    }

    const LEFT_COLS = 540;

    function getVisibleWeeks() {
      const mode = document.getElementById("viewMode")?.value || "default";
      if (mode === "sprint") return 2;
      if (mode === "month") return 4;
      if (mode === "project") return WEEKS;
      return 8;
    }

    function updateWeekWidth() {
      const wrapper = document.querySelector(".gantt-wrapper");
      const gridEl = document.getElementById("ganttGrid");
      if (!wrapper || !gridEl) return;
      const visibleWeeks = getVisibleWeeks();
      const containerWidth = wrapper.offsetWidth || wrapper.parentElement?.offsetWidth || 1200;
      const weekWidth = Math.max(48, (containerWidth - LEFT_COLS) / visibleWeeks);
      wrapper.style.setProperty("--gantt-weeks", WEEKS);
      wrapper.style.setProperty("--gantt-week-width", weekWidth + "px");
      gridEl.style.minWidth = (LEFT_COLS + WEEKS * weekWidth) + "px";
    }

    let scrollSaveTid = null;
    function saveScrollPosition() {
      const wrapper = document.querySelector(".gantt-wrapper");
      if (!wrapper) return;
      const s = loadProjectSettings() || {};
      saveProjectSettings({ ...s, scrollPosition: { scrollTop: wrapper.scrollTop, scrollLeft: wrapper.scrollLeft } });
    }
    function restoreScrollPosition() {
      const wrapper = document.querySelector(".gantt-wrapper");
      const pos = loadProjectSettings()?.scrollPosition;
      if (!wrapper || !pos || typeof pos.scrollTop !== "number" || typeof pos.scrollLeft !== "number") return;
      wrapper.scrollTop = Math.max(0, pos.scrollTop);
      wrapper.scrollLeft = Math.max(0, pos.scrollLeft);
    }

    function updateChartRange() {
      computeChartRange();
      const wrapper = document.querySelector(".gantt-wrapper");
      if (wrapper) wrapper.style.setProperty("--gantt-weeks", WEEKS);
      updateWeekWidth();
      renderWeekLabels();
      renderPhaseHeaders();
      renderTasks();
      saveTasks();
    }

    function showDetachConfirm(anchorEl, message, options) {
      const { showSettingsHint = false } = options || {};
      return new Promise((resolve) => {
        const popup = document.getElementById("detachConfirmPopup");
        const msgEl = document.getElementById("detachConfirmMsg");
        const hintEl = document.getElementById("detachConfirmHint");
        const cancelBtn = popup?.querySelector(".detach-confirm-cancel");
        const detachBtn = popup?.querySelector(".detach-confirm-detach");
        if (!popup || !msgEl) return resolve(false);
        msgEl.textContent = message;
        if (hintEl) {
          hintEl.classList.toggle("hidden", !showSettingsHint);
        }
        const rect = anchorEl.getBoundingClientRect();
        const midX = rect.left + rect.width / 2;
        const midY = rect.top + rect.height / 2;
        popup.style.left = midX + "px";
        popup.style.transform = "translate(-50%, -50%)";
        popup.style.top = midY + "px";
        popup.classList.add("visible");
        const finish = (result) => {
          popup.classList.remove("visible");
          cancelBtn?.removeEventListener("click", onCancel);
          detachBtn?.removeEventListener("click", onDetach);
          document.removeEventListener("click", onClickOutside);
          document.removeEventListener("keydown", onEscape);
          resolve(result);
        };
        const onCancel = () => finish(false);
        const onDetach = () => finish(true);
        const onClickOutside = (e) => {
          if (!popup.contains(e.target) && !anchorEl.contains(e.target)) finish(false);
        };
        const onEscape = (e) => { if (e.key === "Escape") finish(false); };
        cancelBtn?.addEventListener("click", onCancel);
        detachBtn?.addEventListener("click", onDetach);
        document.addEventListener("keydown", onEscape);
        requestAnimationFrame(() => document.addEventListener("click", onClickOutside));
      });
    }

    function showDeleteConfirm(anchorEl, message) {
      return new Promise((resolve) => {
        const popup = document.getElementById("deleteConfirmPopup");
        const msgEl = document.getElementById("deleteConfirmMsg");
        const cancelBtn = popup?.querySelector(".delete-confirm-cancel");
        const deleteBtn = popup?.querySelector(".delete-confirm-delete");
        if (!popup || !msgEl) return resolve(false);
        msgEl.textContent = message;
        const rect = anchorEl.getBoundingClientRect();
        popup.style.left = rect.left + rect.width / 2 + "px";
        const popupHeight = 80;
        const spaceBelow = window.innerHeight - rect.bottom;
        if (spaceBelow < popupHeight + 8 && rect.top > popupHeight + 8) {
          popup.style.top = rect.top - 8 + "px";
          popup.style.transform = "translate(-50%, -100%)";
        } else {
          popup.style.top = rect.bottom + 8 + "px";
          popup.style.transform = "translateX(-50%)";
        }
        popup.classList.add("visible");
        const finish = (result) => {
          popup.classList.remove("visible");
          cancelBtn?.removeEventListener("click", onCancel);
          deleteBtn?.removeEventListener("click", onDelete);
          document.removeEventListener("click", onClickOutside);
          document.removeEventListener("keydown", onEscape);
          resolve(result);
        };
        const onCancel = () => finish(false);
        const onDelete = () => finish(true);
        const onClickOutside = (e) => {
          if (!popup.contains(e.target) && !anchorEl.contains(e.target)) finish(false);
        };
        const onEscape = (e) => { if (e.key === "Escape") finish(false); };
        cancelBtn?.addEventListener("click", onCancel);
        deleteBtn?.addEventListener("click", onDelete);
        document.addEventListener("keydown", onEscape);
        requestAnimationFrame(() => document.addEventListener("click", onClickOutside));
      });
    }

    function showPhaseConfirm(anchorEl, message, moveLabel) {
      return new Promise((resolve) => {
        const popup = document.getElementById("phaseConfirmPopup");
        const msgEl = document.getElementById("phaseConfirmMsg");
        const keepBtn = popup?.querySelector(".phase-confirm-keep");
        const moveBtn = popup?.querySelector(".phase-confirm-move");
        if (!popup || !msgEl) return resolve(false);
        msgEl.textContent = message;
        moveBtn.textContent = moveLabel || "Move to phase";
        const rect = anchorEl.getBoundingClientRect();
        const midX = rect.left + rect.width / 2;
        const midY = rect.top + rect.height / 2;
        popup.style.left = midX + "px";
        popup.style.top = midY + "px";
        popup.style.transform = "translate(-50%, -50%)";
        popup.classList.add("visible");
        const finish = (result) => {
          popup.classList.remove("visible");
          keepBtn?.removeEventListener("click", onKeep);
          moveBtn?.removeEventListener("click", onMove);
          document.removeEventListener("click", onClickOutside);
          document.removeEventListener("keydown", onEscape);
          resolve(result);
        };
        const onKeep = () => finish(false);
        const onMove = () => finish(true);
        const onClickOutside = (e) => {
          if (!popup.contains(e.target) && !anchorEl.contains(e.target)) finish(false);
        };
        const onEscape = (e) => { if (e.key === "Escape") finish(false); };
        keepBtn?.addEventListener("click", onKeep);
        moveBtn?.addEventListener("click", onMove);
        document.addEventListener("keydown", onEscape);
        requestAnimationFrame(() => document.addEventListener("click", onClickOutside));
      });
    }

    function getPhaseWeekSpanExcluding(phaseId, excludeTaskIndex) {
      const s = loadProjectSettings();
      if (s?.phaseDurationMode !== "dynamic") {
        const p = PHASES.find(x => x.id === phaseId);
        const sprints = Math.max(1, parseInt(p?.sprints, 10) || 2);
        return sprints * 2;
      }
      const phaseTasks = tasks.filter((t, i) => i !== excludeTaskIndex && t.phase === phaseId && t.startDate && t.endDate);
      if (phaseTasks.length === 0) return 1;
      const minStart = Math.min(...phaseTasks.map(t => t.startDate.getTime()));
      const maxEnd = Math.max(...phaseTasks.map(t => t.endDate.getTime()));
      return Math.max(1, Math.floor((maxEnd - minStart) / WEEK_MS) + 1);
    }

    function getPhaseForWeekOffset(weekOffset, excludeTaskIndex) {
      const spanFn = (p) => excludeTaskIndex != null ? getPhaseWeekSpanExcluding(p.id, excludeTaskIndex) : getPhaseWeekSpan(p.id);
      const spans = PHASES.map(p => spanFn(p));
      const total = spans.reduce((a, b) => a + b, 0);
      if (total <= 0) return PHASES[0]?.id || null;
      const pos = Math.max(0, Math.min(1, weekOffset / WEEKS));
      let cumulative = 0;
      for (let i = 0; i < PHASES.length; i++) {
        cumulative += spans[i] / total;
        if (pos <= cumulative) return PHASES[i].id;
      }
      return PHASES[PHASES.length - 1]?.id || null;
    }

    async function onBarChangeEnd(taskIndex) {
      const task = typeof taskIndex === "number" ? tasks[taskIndex] : null;
      const primaryIdx = task && typeof task.dependsOn === "number" ? task.dependsOn : null;
      const primary = primaryIdx !== null ? tasks[primaryIdx] : null;
      if (!getAllowIndependentDependencies() && task && primary && primary.endDate && task.startDate) {
        const gapMs = getDependencyGapDays() * 24 * 60 * 60 * 1000;
        const expectedStart = new Date(primary.endDate.getTime() + gapMs);
        const actualStart = task.startDate.getTime();
        const expectedStartTime = expectedStart.getTime();
        if (Math.abs(actualStart - expectedStartTime) > 60 * 60 * 1000) {
          const primaryName = (primary.star ? " " : "") + (primary.task || "Task");
          const bar = document.querySelector('.gantt-bar[data-index="' + taskIndex + '"]');
          const connectorEl = document.getElementById("ganttDependencyLinePath");
          const anchor = (connectorEl && connectorEl.getAttribute("d")) ? connectorEl : (bar || document.body);
          const message = "This task depends on \"" + primaryName + "\". Changing the start date would break the link.";
          const detach = await showDetachConfirm(anchor, message, { showSettingsHint: true });
          if (detach) {
            const childName = (task.star ? " " : "") + (task.task || "Task");
            const parentName = (primary.star ? " " : "") + (primary.task || "Task");
            pushTasksUndo();
            task.dependsOn = null;
            showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/><path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/><line x1="8" y1="2" x2="8" y2="5"/><line x1="2" y1="8" x2="5" y2="8"/><line x1="16" y1="19" x2="16" y2="22"/><line x1="19" y1="16" x2="22" y2="16"/></svg> "${childName}" unlinked from "${parentName}"`, { onUndo: performUndo });
          } else {
            const durationOverride = (lastBarChangeTaskIndex === taskIndex && lastBarChangeOriginalDurationMs != null)
              ? { taskIndex, durationMs: lastBarChangeOriginalDurationMs }
              : undefined;
            propagateDependencyChanges(primaryIdx, undefined, durationOverride);
          }
        }
      }
      lastBarChangeOriginalDurationMs = null;
      lastBarChangeTaskIndex = null;
      if (task && task.startDate && task.phase && lastBarChangeOriginalStartDate && lastBarChangeOriginalEndDate) {
        const weekOffset = dateToOffset(task.startDate);
        const phaseForPosition = getPhaseForWeekOffset(weekOffset, taskIndex);
        if (phaseForPosition && phaseForPosition !== task.phase) {
          const phaseInfo = PHASES.find(p => p.id === phaseForPosition);
          const phaseName = phaseInfo?.name || phaseForPosition;
          const bar = document.querySelector('.gantt-bar[data-index="' + taskIndex + '"]');
          const connectorEl = document.getElementById("ganttDependencyLinePath");
          const anchor = (connectorEl && connectorEl.getAttribute("d")) ? connectorEl : (bar || document.body);
          const message = "This task is now in the \"" + phaseName + "\" region. Move it to this phase or keep it linked to the current one?";
          const moveLabel = "Move to " + phaseName;
          const movePhase = await showPhaseConfirm(anchor, message, moveLabel);
          if (movePhase) {
            task.phase = phaseForPosition;
          } else if (lastBarChangeOriginalStartDate && lastBarChangeOriginalEndDate) {
            task.startDate = new Date(lastBarChangeOriginalStartDate);
            task.endDate = new Date(lastBarChangeOriginalEndDate);
            task.start = formatDate(task.startDate);
            task.end = formatDate(task.endDate);
            const row = grid?.querySelector('.gantt-row[data-index="' + taskIndex + '"]');
            const dateCell = row?.querySelector(".gantt-date-cell");
            if (dateCell) {
              const startInp = dateCell.querySelector('.gantt-date-start');
              const endInp = dateCell.querySelector('.gantt-date-end');
              if (startInp) startInp.value = task.start;
              if (endInp) endInp.value = task.end;
            }
            const barEl = document.querySelector('.gantt-bar[data-index="' + taskIndex + '"]');
            if (barEl) {
              const so = dateToOffset(task.startDate);
              let eo = dateToOffset(task.endDate);
              if (eo <= so) eo = so + 1 / 7;
              eo = Math.min(WEEKS, Math.max(0, eo));
              barEl.style.left = (Math.max(0, so) / WEEKS) * 100 + "%";
              barEl.style.width = ((eo - Math.max(0, so)) / WEEKS) * 100 + "%";
            }
          }
        }
      }
      lastBarChangeOriginalStartDate = null;
      lastBarChangeOriginalEndDate = null;
      if (typeof taskIndex === "number") propagateDependencyChanges(taskIndex);
      const prevWeeks = WEEKS;
      const prevStart = WEEK_START.getTime();
      computeChartRange();
      const rangeChanged = WEEKS !== prevWeeks || WEEK_START.getTime() !== prevStart;
      if (rangeChanged) {
        updateChartRange();
      } else {
        renderPhaseHeaders();
        renderTasks();
        saveTasks();
      }
    }

    function renderWeekLabels() {
      const headerRow = document.getElementById("ganttHeaderRow");
      if (!headerRow) return;
      const existing = headerRow.querySelectorAll(".week-label, .gantt-header-delete-cell");
      existing.forEach(el => el.remove());
      for (let w = 0; w < WEEKS; w++) {
        const cell = document.createElement("div");
        cell.className = "gantt-cell week-label";
        const d = new Date(WEEK_START.getTime() + w * WEEK_MS);
        cell.textContent = d.toLocaleDateString("en-US", { month: "short", day: "numeric" });
        headerRow.appendChild(cell);
      }
      const deletePlaceholder = document.createElement("div");
      deletePlaceholder.className = "gantt-cell gantt-header-delete-cell";
      headerRow.appendChild(deletePlaceholder);
    }

    function applyRowAppearance() {
      const s = loadProjectSettings();
      const mode = s?.rowAppearance === "compact" || s?.rowAppearance === "fill" ? s.rowAppearance : "default";
      const wrapper = document.querySelector(".gantt-wrapper");
      if (wrapper) {
        wrapper.setAttribute("data-row-appearance", mode);
        if (s?.strokeMode) wrapper.setAttribute("data-bar-stroke-mode", "true");
        else wrapper.removeAttribute("data-bar-stroke-mode");
        if (s?.showDurationOnBar) wrapper.setAttribute("data-show-duration-on-bar", "true");
        else wrapper.removeAttribute("data-show-duration-on-bar");
      }
    }
    function applySettingsPreviewFromForm() {
      const wrapper = document.querySelector(".gantt-wrapper");
      if (!wrapper) return;
      const rowAppearanceEl = document.getElementById("settingsRowAppearance");
      const mode = rowAppearanceEl?.value === "compact" || rowAppearanceEl?.value === "fill" ? rowAppearanceEl.value : "default";
      wrapper.setAttribute("data-row-appearance", mode);
      const barStyleSelected = document.querySelector("#settingsBarStyle .settings-segmented-option.selected");
      const strokeMode = barStyleSelected?.dataset.value === "stroke";
      if (strokeMode) wrapper.setAttribute("data-bar-stroke-mode", "true");
      else wrapper.removeAttribute("data-bar-stroke-mode");
      const showDurationEl = document.getElementById("settingsShowDurationOnBar");
      if (showDurationEl?.checked) wrapper.setAttribute("data-show-duration-on-bar", "true");
      else wrapper.removeAttribute("data-show-duration-on-bar");
    }
    function getDefaultPhasesWithSprints() {
      return DEFAULT_PHASES.map(p => ({ ...p, sprints: 2 }));
    }
    function applyProjectSettings() {
      applyRowAppearance();
      const s = loadProjectSettings();
      if (!s) {
        PHASES = getDefaultPhasesWithSprints();
        return;
      }
      if (Array.isArray(s.phases) && s.phases.length > 0) {
        PHASES = s.phases.map(p => ({ id: p.id, name: p.name || p.id, color: p.color || "#737373", sprints: p.sprints ?? 2 }));
      } else {
        PHASES = getDefaultPhasesWithSprints();
      }
    }
    function setupPhaseListDrag(phaseList) {
      if (!phaseList) return;
      let draggedItem = null;
      phaseList.addEventListener("dragstart", (e) => {
        const item = e.target.closest(".settings-phase-item");
        if (!item || e.target.closest('input[type="text"]') || e.target.closest('input[type="number"]') || e.target.closest('input[type="color"]') || e.target.closest(".settings-phase-remove")) return;
        draggedItem = item;
        item.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", item.dataset.phaseId);
      });
      phaseList.addEventListener("dragend", (e) => {
        const item = e.target.closest(".settings-phase-item");
        if (item) {
          item.classList.remove("dragging");
          draggedItem = null;
        }
      });
      phaseList.addEventListener("dragover", (e) => {
        e.preventDefault();
        const item = e.target.closest(".settings-phase-item");
        if (!draggedItem || !item || draggedItem === item) return;
        e.dataTransfer.dropEffect = "move";
      });
      phaseList.addEventListener("drop", (e) => {
        e.preventDefault();
        const item = e.target.closest(".settings-phase-item");
        if (!draggedItem || !item || draggedItem === item) return;
        const all = [...phaseList.querySelectorAll(".settings-phase-item")];
        const fromIdx = all.indexOf(draggedItem);
        const toIdx = all.indexOf(item);
        if (fromIdx === -1 || toIdx === -1 || fromIdx === toIdx) return;
        if (fromIdx < toIdx) {
          item.after(draggedItem);
        } else {
          item.before(draggedItem);
        }
      });
    }

    function openSettingsModal() {
      const s = loadProjectSettings() || {};
      const header = loadPageHeader();
      document.getElementById("settingsTitle").value = header.title;
      document.getElementById("settingsDescription").value = header.description;
      const gapEl = document.getElementById("settingsDependencyGap");
      if (gapEl) gapEl.value = String(s.dependencyGapDays ?? 0);
      const dependentTrigger = document.getElementById("settingsDependentTrigger");
      if (dependentTrigger && gapEl?.selectedOptions?.[0]) dependentTrigger.textContent = gapEl.selectedOptions[0].textContent;
      const psEl = document.getElementById("settingsProjectStartDate");
      if (psEl) psEl.value = s.projectStartDate || "";
      const peEl = document.getElementById("settingsProjectEndDate");
      if (peEl) peEl.value = s.projectEndDate || "";
      const snapEl = document.getElementById("settingsSnapToSprint");
      if (snapEl) snapEl.checked = s == null ? true : !!s.snapToSprint;
      const moveTasksEl = document.getElementById("settingsMoveTasksWhenSprintExtended");
      if (moveTasksEl) moveTasksEl.checked = !!s?.moveTasksWhenSprintExtended;
      const indepEl = document.getElementById("settingsIndependentDependencies");
      if (indepEl) indepEl.checked = !!s?.allowIndependentDependencies;
      const showDurationEl = document.getElementById("settingsShowDurationOnBar");
      if (showDurationEl) showDurationEl.checked = !!s?.showDurationOnBar;
      const phaseDurationEl = document.getElementById("settingsPhaseDurationMode");
      const phaseMode = (s?.phaseDurationMode === "dynamic") ? "dynamic" : "fixed";
      if (phaseDurationEl) phaseDurationEl.value = phaseMode;
      const phaseList = document.getElementById("settingsPhaseList");
      if (phaseList) phaseList.dataset.phaseMode = phaseMode;
      const snapWrap = document.getElementById("settingsSnapToSprintWrap");
      if (snapWrap) snapWrap.style.display = phaseMode === "fixed" ? "" : "none";
      phaseList.innerHTML = "";
      const renderPhaseItem = (p, i) => {
        const item = document.createElement("div");
        item.className = "settings-phase-item";
        item.dataset.phaseId = p.id;
        item.draggable = true;
        const inputWrap = document.createElement("div");
        inputWrap.className = "settings-phase-input-wrap";
        const inp = document.createElement("input");
        inp.type = "text";
        inp.value = p.name;
        inp.placeholder = "Phase name";
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "settings-phase-remove";
        removeBtn.textContent = "\u2212";
        removeBtn.title = "Remove phase";
        removeBtn.disabled = phaseList.children.length < 1;
        removeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          item.remove();
          phaseList.querySelectorAll(".settings-phase-remove").forEach(btn => {
            btn.disabled = phaseList.children.length < 2;
          });
        });
        const colorInp = document.createElement("input");
        colorInp.type = "color";
        colorInp.className = "settings-phase-swatch";
        colorInp.value = p.color;
        inputWrap.appendChild(colorInp);
        inputWrap.appendChild(inp);
        inputWrap.appendChild(removeBtn);
        const sprintsWrap = document.createElement("div");
        sprintsWrap.className = "settings-phase-sprints";
        const sprintsInner = document.createElement("div");
        sprintsInner.className = "settings-phase-sprints-inner";
        const sprintsInp = document.createElement("input");
        sprintsInp.type = "number";
        sprintsInp.min = "1";
        sprintsInp.max = "52";
        sprintsInp.value = Math.max(1, Math.min(52, parseInt(p.sprints, 10) || 2));
        const sprintsSuffix = document.createElement("span");
        sprintsSuffix.className = "sprints-suffix";
        sprintsSuffix.textContent = "sprints";
        sprintsInner.appendChild(sprintsInp);
        sprintsInner.appendChild(sprintsSuffix);
        sprintsWrap.appendChild(sprintsInner);
        item.appendChild(inputWrap);
        item.appendChild(sprintsWrap);
        phaseList.appendChild(item);
      };
      PHASES.forEach((p, i) => renderPhaseItem(p, i));
      document.getElementById("settingsAddPhase").onclick = () => {
        const existingIds = [...phaseList.querySelectorAll(".settings-phase-item")].map(it => it.dataset.phaseId);
        let id = "phase-" + (PHASES.length + 1);
        let n = 1;
        while (existingIds.includes(id)) { id = "phase-" + (PHASES.length + n++); }
        const sel = paletteGrid.querySelector(".settings-palette-option.selected");
        let colors = [];
        if (sel?.dataset.colors) { try { colors = JSON.parse(sel.dataset.colors); } catch {} }
        const color = colors[phaseList.children.length] || "#737373";
        renderPhaseItem({ id, name: "New phase", color, sprints: 2 }, phaseList.children.length);
        phaseList.querySelectorAll(".settings-phase-remove").forEach(btn => {
          btn.disabled = phaseList.children.length < 2;
        });
      };
      const partyListEl = document.getElementById("settingsResponsiblePartiesList");
      const partyInputEl = document.getElementById("settingsPartyInput");
      const addPartyBtn = document.getElementById("settingsAddParty");
      if (partyListEl) {
        partyListEl.innerHTML = "";
        const savedParties = Array.isArray(s.responsibleParties) ? s.responsibleParties : [];
        savedParties.forEach((name) => {
          const item = document.createElement("div");
          item.className = "settings-party-item";
          const span = document.createElement("span");
          span.textContent = name;
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => item.remove());
          item.appendChild(span);
          item.appendChild(removeBtn);
          partyListEl.appendChild(item);
        });
      }
      function addResponsibleParty() {
        const name = (partyInputEl && partyInputEl.value || "").trim();
        if (!name || !partyListEl) return;
        partyInputEl.value = "";
        const item = document.createElement("div");
        item.className = "settings-party-item";
        const span = document.createElement("span");
        span.textContent = name;
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.textContent = "Remove";
        removeBtn.addEventListener("click", () => item.remove());
        item.appendChild(span);
        item.appendChild(removeBtn);
        partyListEl.appendChild(item);
      }
      if (addPartyBtn) addPartyBtn.onclick = addResponsibleParty;
      if (partyInputEl) partyInputEl.onkeydown = (e) => { if (e.key === "Enter") { e.preventDefault(); addResponsibleParty(); } };
      const customPalettes = loadCustomPalettes();
      const allPalettes = [...COLOR_PALETTES, ...customPalettes];
      const rowAppearanceEl = document.getElementById("settingsRowAppearance");
      if (rowAppearanceEl) rowAppearanceEl.value = s.rowAppearance === "compact" || s.rowAppearance === "fill" ? s.rowAppearance : "default";
      const barStyleEl = document.getElementById("settingsBarStyle");
      if (barStyleEl) {
        barStyleEl.querySelectorAll(".settings-segmented-option").forEach(opt => {
          opt.classList.toggle("selected", opt.dataset.value === (s.strokeMode ? "stroke" : "fill"));
        });
      }
      const paletteGrid = document.getElementById("settingsPaletteGrid");
      paletteGrid.innerHTML = "";
      let paletteIdx = typeof s.paletteIndex === "number" ? s.paletteIndex : 0;
      if (paletteIdx >= allPalettes.length) paletteIdx = 0;
      allPalettes.forEach((pal, i) => {
        const opt = document.createElement("button");
        opt.type = "button";
        opt.className = "settings-palette-option" + (i === paletteIdx ? " selected" : "");
        opt.dataset.index = String(i);
        opt.dataset.colors = JSON.stringify(pal.colors || []);
        const nameWrap = document.createElement("div");
        nameWrap.className = "settings-palette-name-wrap";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.className = "settings-palette-name-input";
        nameInput.value = pal.name || "Palette " + (i + 1);
        nameInput.readOnly = i < COLOR_PALETTES.length;
        nameInput.addEventListener("click", (e) => e.stopPropagation());
        nameInput.addEventListener("focus", (e) => e.stopPropagation());
        nameWrap.appendChild(nameInput);
        if (i >= COLOR_PALETTES.length) {
          const renameBtn = document.createElement("button");
          renameBtn.type = "button";
          renameBtn.className = "settings-palette-rename-btn";
          renameBtn.textContent = "Rename";
          renameBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const newName = prompt("Palette name", nameInput.value?.trim() || "My palette")?.trim();
            if (newName == null || newName === nameInput.value) return;
            const custom = loadCustomPalettes();
            const customIdx = i - COLOR_PALETTES.length;
            if (customIdx >= 0 && custom[customIdx]) {
              custom[customIdx].name = newName;
              saveCustomPalettes(custom);
              nameInput.value = newName;
            }
          });
          nameWrap.appendChild(renameBtn);
        }
        opt.appendChild(nameWrap);
        const strokePreview = document.querySelector("#settingsBarStyle .settings-segmented-option[data-value='stroke']")?.classList.contains("selected");
        const swatchesEl = document.createElement("div");
        swatchesEl.className = "settings-palette-swatches";
        (pal.colors || []).forEach(c => {
          const span = document.createElement("span");
          applyPaletteSwatchStyle(span, c, strokePreview);
          swatchesEl.appendChild(span);
        });
        opt.appendChild(swatchesEl);
        opt.addEventListener("click", () => {
          paletteGrid.querySelectorAll(".settings-palette-option").forEach(o => o.classList.remove("selected"));
          opt.classList.add("selected");
          const idx = parseInt(opt.dataset.index, 10);
          const p = allPalettes[idx];
          if (p?.colors) {
            document.querySelectorAll(".settings-phase-item").forEach((item, i) => {
              const colorInp = item.querySelector('input[type="color"]');
              if (colorInp && p.colors[i]) colorInp.value = p.colors[i];
            });
          }
        });
        paletteGrid.appendChild(opt);
      });
      document.getElementById("settingsSavePalette").onclick = () => {
        const colors = [...document.querySelectorAll(".settings-phase-item")].map(item => {
          const colorInp = item.querySelector('input[type="color"]');
          return colorInp?.value || "#737373";
        }).filter(Boolean);
        if (colors.length === 0) return;
        const name = prompt("Palette name", "My palette")?.trim() || "My palette";
        const custom = loadCustomPalettes();
        custom.push({ name, colors });
        saveCustomPalettes(custom);
        const newIdx = paletteGrid.querySelectorAll(".settings-palette-option").length;
        const opt = document.createElement("button");
        opt.type = "button";
        opt.className = "settings-palette-option selected";
        opt.dataset.index = String(newIdx);
        opt.dataset.colors = JSON.stringify(colors);
        const nameWrap = document.createElement("div");
        nameWrap.className = "settings-palette-name-wrap";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.className = "settings-palette-name-input";
        nameInput.value = name;
        nameInput.readOnly = false;
        nameInput.addEventListener("click", (e) => e.stopPropagation());
        nameInput.addEventListener("focus", (e) => e.stopPropagation());
        const renameBtn = document.createElement("button");
        renameBtn.type = "button";
        renameBtn.className = "settings-palette-rename-btn";
        renameBtn.textContent = "Rename";
        renameBtn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const newName = prompt("Palette name", nameInput.value?.trim() || "My palette")?.trim();
          if (newName == null || newName === nameInput.value) return;
          const custom = loadCustomPalettes();
          const customIdx = custom.length - 1;
          if (customIdx >= 0 && custom[customIdx]) {
            custom[customIdx].name = newName;
            saveCustomPalettes(custom);
            nameInput.value = newName;
          }
        });
        nameWrap.appendChild(nameInput);
        nameWrap.appendChild(renameBtn);
        opt.appendChild(nameWrap);
        const strokePreview = document.querySelector("#settingsBarStyle .settings-segmented-option[data-value='stroke']")?.classList.contains("selected");
        const swatchesEl = document.createElement("div");
        swatchesEl.className = "settings-palette-swatches";
        colors.forEach(c => {
          const span = document.createElement("span");
          applyPaletteSwatchStyle(span, c, strokePreview);
          swatchesEl.appendChild(span);
        });
        opt.appendChild(swatchesEl);
        opt.addEventListener("click", () => {
          paletteGrid.querySelectorAll(".settings-palette-option").forEach(o => o.classList.remove("selected"));
          opt.classList.add("selected");
          document.querySelectorAll(".settings-phase-item").forEach((item, i) => {
            const colorInp = item.querySelector('input[type="color"]');
            if (colorInp && colors[i]) colorInp.value = colors[i];
          });
        });
        paletteGrid.querySelectorAll(".settings-palette-option").forEach(o => o.classList.remove("selected"));
        paletteGrid.appendChild(opt);
        opt.classList.add("selected");
      };
      document.getElementById("settingsOverlay").classList.add("open");
      const addFab = document.getElementById("addTaskFab");
      if (addFab) addFab.style.display = "none";
      document.getElementById("fabPhaseMenu")?.classList.remove("visible");
    }
    function closeSettingsModal() {
      applyRowAppearance();
      document.getElementById("settingsOverlay").classList.remove("open");
      if (currentProjectId) {
        const addFab = document.getElementById("addTaskFab");
        if (addFab) addFab.style.display = "";
      }
    }
    function saveSettingsFromModal() {
      const title = document.getElementById("settingsTitle").value.trim() || DEFAULT_PAGE_TITLE;
      const desc = document.getElementById("settingsDescription").value.trim() || DEFAULT_PAGE_DESCRIPTION;
      const phases = [];
      const removedIds = PHASES.map(p => p.id).filter(id => !document.querySelector(`.settings-phase-item[data-phase-id="${id}"]`));
      document.querySelectorAll(".settings-phase-item").forEach((item, i) => {
        const inp = item.querySelector('input[type="text"]');
        const colorInp = item.querySelector('input[type="color"]');
        const sprintsInp = item.querySelector('.settings-phase-sprints input[type="number"]');
        const name = (inp?.value || "").trim() || "Phase " + (i + 1);
        const color = colorInp?.value || "#737373";
        const sprints = sprintsInp ? Math.max(1, Math.min(52, parseInt(sprintsInp.value, 10) || 2)) : 2;
        const id = item.dataset.phaseId || name.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "") || "phase-" + (i + 1);
        phases.push({ id, name, color, sprints });
      });
      const firstPhaseId = phases[0]?.id;
      if (firstPhaseId && removedIds.length > 0) {
        tasks.forEach(t => { if (removedIds.includes(t.phase)) t.phase = firstPhaseId; });
        saveTasks();
      }
      const selectedPalette = document.querySelector(".settings-palette-option.selected");
      const paletteIndex = selectedPalette ? parseInt(selectedPalette.dataset.index, 10) : 0;
      const dependencyGapDays = parseInt(document.getElementById("settingsDependencyGap")?.value || "0", 10) || 0;
      const rowAppearance = document.getElementById("settingsRowAppearance")?.value || "default";
      const barStyleSelected = document.querySelector("#settingsBarStyle .settings-segmented-option.selected");
      const strokeMode = barStyleSelected?.dataset.value === "stroke";
      const projectStartDateRaw = document.getElementById("settingsProjectStartDate")?.value?.trim();
      const projectStartDate = projectStartDateRaw || null;
      const projectEndDateRaw = document.getElementById("settingsProjectEndDate")?.value?.trim();
      const projectEndDate = projectEndDateRaw || null;
      const phaseDurationMode = document.getElementById("settingsPhaseDurationMode")?.value === "fixed" ? "fixed" : "dynamic";
      const snapToSprint = !!document.getElementById("settingsSnapToSprint")?.checked;
      const moveTasksWhenSprintExtended = !!document.getElementById("settingsMoveTasksWhenSprintExtended")?.checked;
      const allowIndependentDependencies = !!document.getElementById("settingsIndependentDependencies")?.checked;
      const showDurationOnBar = !!document.getElementById("settingsShowDurationOnBar")?.checked;
      const s = loadProjectSettings() || {};
      if (phaseDurationMode === "fixed" && moveTasksWhenSprintExtended && PHASES.length === phases.length) {
        const base = getProjectStartDate() || WEEK_START;
        const baseMs = new Date(base.getFullYear(), base.getMonth(), base.getDate()).getTime();
        const DAY_MS = 24 * 60 * 60 * 1000;
        const SPRINT_DAYS = 14;
        const oldStartsDays = [];
        let cum = 0;
        for (let i = 0; i < PHASES.length; i++) {
          oldStartsDays.push(cum);
          cum += (Math.max(1, parseInt(PHASES[i].sprints, 10) || 2) * SPRINT_DAYS);
        }
        oldStartsDays.push(cum);
        let anyShifted = false;
        tasks.forEach(t => {
          if (!t.startDate || !t.endDate) return;
          const taskStartDays = (t.startDate.getTime() - baseMs) / DAY_MS;
          let phaseIdx = 0;
          for (let i = 0; i < oldStartsDays.length - 1; i++) {
            if (taskStartDays >= oldStartsDays[i]) phaseIdx = i;
          }
          let shiftDays = 0;
          for (let k = 0; k < phaseIdx; k++) {
            const oldS = Math.max(1, parseInt(PHASES[k].sprints, 10) || 2);
            const newS = Math.max(1, parseInt(phases[k].sprints, 10) || 2);
            shiftDays += Math.max(0, (newS - oldS) * SPRINT_DAYS);
          }
          if (shiftDays > 0) {
            anyShifted = true;
            t.startDate = new Date(t.startDate.getTime() + shiftDays * DAY_MS);
            t.endDate = new Date(t.endDate.getTime() + shiftDays * DAY_MS);
            t.start = formatDate(t.startDate);
            t.end = formatDate(t.endDate);
          }
        });
        if (anyShifted) saveTasks();
      }
      const partyListContainer = document.getElementById("settingsResponsiblePartiesList");
      let responsibleParties = [];
      if (partyListContainer) {
        const spans = partyListContainer.querySelectorAll(".settings-party-item span");
        responsibleParties = [...spans].map(function(sp) { return (sp.textContent || "").trim(); }).filter(Boolean);
      }
      saveProjectSettings({ ...s, title, description: desc, phases, paletteIndex, dependencyGapDays, rowAppearance, strokeMode, showDurationOnBar, projectStartDate, projectEndDate, phaseDurationMode, snapToSprint, moveTasksWhenSprintExtended, allowIndependentDependencies, responsibleParties });
      if (currentProjectId) ensureProjectInList(currentProjectId, title);
      applyRowAppearance();
      PHASES = phases.map(p => ({ ...p, sprints: p.sprints ?? 2 }));
      const allPalettes = [...COLOR_PALETTES, ...loadCustomPalettes()];
      const palette = allPalettes[paletteIndex];
      if (palette?.colors) PHASES.forEach((p, i) => { if (palette.colors[i]) p.color = palette.colors[i]; });
      const titleEl = document.getElementById("pageTitle");
      const descEl = document.getElementById("pageDescription");
      if (titleEl) titleEl.textContent = title;
      if (descEl) descEl.textContent = desc;
      tasks.forEach((_, i) => { if (tasks.some(t => t.dependsOn === i)) propagateDependencyChanges(i); });
      if (typeof renderPhaseHeaders === "function") renderPhaseHeaders();
      if (typeof updateChartRange === "function") updateChartRange();
      closeSettingsModal();
    }

    function getProjectDescription(projectId) {
      if (window.ganttStorage?.isCloudEnabled()) {
        const s = window.ganttStorage.loadSettings(projectId);
        if (s && typeof s.description === "string") return s.description.trim();
      }
      try {
        const raw = localStorage.getItem("gantt-settings-" + projectId);
        if (!raw) return "";
        const s = JSON.parse(raw);
        return (s.description && typeof s.description === "string") ? s.description.trim() : "";
      } catch { return ""; }
    }
    async function saveProjectTitleDescription(projectId, title, description) {
      if (window.ganttStorage?.isCloudEnabled()) {
        await window.ganttStorage.ensureBoardDataLoaded(projectId);
        const s = window.ganttStorage.loadSettings(projectId) || {};
        s.title = title != null ? String(title).trim() : "";
        s.description = description != null ? String(description).trim() : "";
        window.ganttStorage.saveSettings(projectId, s);
        return;
      }
      try {
        const raw = localStorage.getItem("gantt-settings-" + projectId);
        const s = raw ? JSON.parse(raw) : {};
        s.title = title != null ? String(title).trim() : "";
        s.description = description != null ? String(description).trim() : "";
        localStorage.setItem("gantt-settings-" + projectId, JSON.stringify(s));
      } catch (e) { console.warn("Could not save project title/description:", e); }
    }
    function getProjectTaskCount(projectId) {
      if (window.ganttStorage?.isCloudEnabled()) {
        const arr = window.ganttStorage.loadTasks(projectId);
        if (Array.isArray(arr)) return arr.length;
      }
      try {
        const raw = localStorage.getItem("gantt-tasks-" + projectId);
        if (!raw) return 0;
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr.length : 0;
      } catch { return 0; }
    }
    function getProjectCurrentTaskCount(projectId) {
      if (window.ganttStorage?.isCloudEnabled()) {
        const arr = window.ganttStorage.loadTasks(projectId);
        if (!Array.isArray(arr)) return 0;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayMs = today.getTime();
        return arr.filter((t) => {
          if (!t.startDate || !t.endDate) return false;
          const start = new Date(t.startDate);
          const end = new Date(t.endDate);
          start.setHours(0, 0, 0, 0);
          end.setHours(0, 0, 0, 0);
          return todayMs >= start.getTime() && todayMs <= end.getTime();
        }).length;
      }
      try {
        const raw = localStorage.getItem("gantt-tasks-" + projectId);
        if (!raw) return 0;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return 0;
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayMs = today.getTime();
        return arr.filter((t) => {
          if (!t.startDate || !t.endDate) return false;
          const start = new Date(t.startDate);
          const end = new Date(t.endDate);
          start.setHours(0, 0, 0, 0);
          end.setHours(0, 0, 0, 0);
          return todayMs >= start.getTime() && todayMs <= end.getTime();
        }).length;
      } catch { return 0; }
    }
    function toTitleCase(str) {
      if (!str || typeof str !== "string") return str;
      return str.replace(/\w\S*/g, t => t.charAt(0).toUpperCase() + t.slice(1).toLowerCase());
    }
    function parseProjectStartFromSettings(s) {
      const raw = s?.projectStartDate;
      if (!raw || typeof raw !== "string") return null;
      const parts = raw.trim().match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (!parts) return null;
      const d = new Date(parseInt(parts[1], 10), parseInt(parts[2], 10) - 1, parseInt(parts[3], 10));
      return isNaN(d.getTime()) ? null : d;
    }
    function startOfWeek(date) {
      const d = new Date(date);
      d.setDate(d.getDate() - d.getDay());
      d.setHours(0, 0, 0, 0);
      return d;
    }
    function getProjectCurrentPhase(projectId) {
      try {
        const tasksRaw = localStorage.getItem("gantt-tasks-" + projectId);
        const settingsRaw = localStorage.getItem("gantt-settings-" + projectId);
        const taskList = tasksRaw ? JSON.parse(tasksRaw) : [];
        const tasks = Array.isArray(taskList) ? taskList : [];
        const s = settingsRaw ? JSON.parse(settingsRaw) : null;
        const phases = (s?.phases && Array.isArray(s.phases)) ? s.phases : DEFAULT_PHASES.map(p => ({ ...p }));
        if (phases.length === 0) return null;
        const mode = (s?.phaseDurationMode === "dynamic") ? "dynamic" : "fixed";
        const projectStart = parseProjectStartFromSettings(s);
        const WEEK_MS_LOCAL = 7 * 24 * 60 * 60 * 1000;
        let baseDate = null;
        if (mode === "fixed" && projectStart) {
          baseDate = startOfWeek(projectStart);
        } else if (tasks.length > 0) {
          let minStart = null;
          tasks.forEach(t => {
            const start = t.startDate ? new Date(t.startDate) : null;
            if (start && (!minStart || start.getTime() < minStart.getTime())) minStart = start;
          });
          baseDate = minStart ? startOfWeek(minStart) : startOfWeek(new Date());
        } else {
          baseDate = projectStart ? startOfWeek(projectStart) : startOfWeek(new Date());
        }
        const phaseSpansWeeks = [];
        for (let i = 0; i < phases.length; i++) {
          const p = phases[i];
          if (mode === "fixed") {
            const sprints = Math.max(1, parseInt(p.sprints, 10) || 2);
            phaseSpansWeeks.push(sprints * 2);
          } else {
            const inPhase = tasks.filter(t => (t.phase || p.id) === p.id && t.startDate && t.endDate);
            if (inPhase.length === 0) phaseSpansWeeks.push(1);
            else {
              const minS = Math.min(...inPhase.map(t => new Date(t.startDate).getTime()));
              const maxE = Math.max(...inPhase.map(t => new Date(t.endDate).getTime()));
              phaseSpansWeeks.push(Math.max(1, Math.floor((maxE - minS) / WEEK_MS_LOCAL) + 1));
            }
          }
        }
        let cumulative = 0;
        const phaseRanges = phaseSpansWeeks.map((span, i) => {
          const startMs = baseDate.getTime() + cumulative * WEEK_MS_LOCAL;
          cumulative += span;
          const endMs = baseDate.getTime() + cumulative * WEEK_MS_LOCAL;
          return { startMs, endMs };
        });
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayMs = today.getTime();
        let phaseIndex = 0;
        for (let i = 0; i < phaseRanges.length; i++) {
          if (todayMs >= phaseRanges[i].startMs && todayMs < phaseRanges[i].endMs) {
            phaseIndex = i;
            break;
          }
          if (todayMs < phaseRanges[i].startMs) break;
          phaseIndex = i;
        }
        const phase = phases[phaseIndex];
        const name = phase.name ? toTitleCase(phase.name) : toTitleCase(phase.id);
        const color = phase.color || "#737373";
        return { name, color };
      } catch { return null; }
    }
    const HOME_TITLE_KEY = "gantt-home-title";
    const HOME_DESC_KEY = "gantt-home-description";
    const DEFAULT_HOME_TITLE = "Gantt projects";
    const DEFAULT_HOME_DESC = "Create and open project schedules. Each project has its own tasks and settings.";
    let homePageHeaderInited = false;
    function initHomePageHeader() {
      const titleEl = document.getElementById("homePageTitle");
      const descEl = document.getElementById("homePageDescription");
      if (!titleEl || !descEl) return;
      const savedTitle = localStorage.getItem(HOME_TITLE_KEY);
      const savedDesc = localStorage.getItem(HOME_DESC_KEY);
      if (savedTitle != null) titleEl.textContent = savedTitle;
      if (savedDesc != null) descEl.textContent = savedDesc;
      if (!homePageHeaderInited) {
        homePageHeaderInited = true;
        const saveTitle = () => {
          const v = (titleEl.textContent || "").trim() || DEFAULT_HOME_TITLE;
          if (!v) titleEl.textContent = DEFAULT_HOME_TITLE;
          localStorage.setItem(HOME_TITLE_KEY, (titleEl.textContent || "").trim() || DEFAULT_HOME_TITLE);
        };
        const saveDesc = () => {
          localStorage.setItem(HOME_DESC_KEY, (descEl.textContent || "").trim());
        };
        titleEl.addEventListener("blur", saveTitle);
        descEl.addEventListener("blur", saveDesc);
      }
    }
    function renderHomeView() {
      const listEl = document.getElementById("homeProjectList");
      if (!listEl) return;
      initHomePageHeader();
      const projects = loadProjectsList();
      const badgeEl = document.getElementById("homeProjectCountBadge");
      if (badgeEl) badgeEl.textContent = String(projects.length);
      listEl.innerHTML = "";
      projects.forEach(p => {
        const isEditMode = p.id === homeEditProjectId;
        const card = document.createElement("div");
        card.className = "home-project-card" + (isEditMode ? " edit-mode" : "");
        if (!isEditMode) {
          card.addEventListener("click", (e) => {
            if (e.target.closest(".home-project-delete-btn") || e.target.closest(".home-project-duplicate-btn")) return;
            location.hash = getProjectUrl(p);
          });
        }
        if (!isEditMode) {
          const previewWrap = document.createElement("div");
          previewWrap.className = "home-project-timeline-preview";
          if (window.ganttStorage?.isCloudEnabled()) {
            window.ganttStorage.ensureBoardDataLoaded(p.id).then(() => renderHomeTimelinePreview(p.id, previewWrap));
          } else {
            renderHomeTimelinePreview(p.id, previewWrap);
          }
          card.appendChild(previewWrap);
        }
        const body = document.createElement("div");
        body.className = "home-project-card-body";
        const info = document.createElement("div");
        info.className = "home-project-info";
        if (isEditMode) {
          const nameInput = document.createElement("input");
          nameInput.type = "text";
          nameInput.className = "home-project-name-input";
          nameInput.placeholder = "Project name";
          nameInput.value = p.name || "Untitled project";
          nameInput.addEventListener("click", (e) => e.stopPropagation());
          info.appendChild(nameInput);
          const descInput = document.createElement("textarea");
          descInput.className = "home-project-desc-input";
          descInput.placeholder = "Description (optional)";
          descInput.value = getProjectDescription(p.id);
          descInput.addEventListener("click", (e) => e.stopPropagation());
          info.appendChild(descInput);
        } else {
          const name = document.createElement("div");
          name.className = "home-project-name";
          name.textContent = p.name || "Untitled project";
          info.appendChild(name);
          const desc = getProjectDescription(p.id);
          if (desc) {
            const descEl = document.createElement("div");
            descEl.className = "home-project-description";
            descEl.textContent = desc;
            info.appendChild(descEl);
          }
          const countRow = document.createElement("div");
          countRow.className = "home-project-row";
          const total = getProjectTaskCount(p.id);
          const current = getProjectCurrentTaskCount(p.id);
          const countEl = document.createElement("span");
          countEl.className = "home-project-task-count";
          if (total === 0) {
            countEl.textContent = "No tasks";
          } else {
            const taskWord = total === 1 ? "task" : "tasks";
            countEl.textContent = current + " current / " + total + " " + taskWord;
          }
          countRow.appendChild(countEl);
          info.appendChild(countRow);
        }
        body.appendChild(info);
        card.appendChild(body);
        const footer = document.createElement("div");
        footer.className = "home-project-card-footer";
        const isLocal = !window.ganttStorage?.isCloudEnabled();
        if (isLocal && !isEditMode) {
          const localTag = document.createElement("span");
          localTag.className = "home-project-local-tag";
          localTag.textContent = "Local";
          footer.appendChild(localTag);
        }
        const phaseInfo = !isEditMode ? getProjectCurrentPhase(p.id) : null;
        if (phaseInfo) {
          const tag = document.createElement("span");
          tag.className = "home-project-phase-tag";
          tag.textContent = phaseInfo.name;
          tag.style.backgroundColor = hexToRgba(phaseInfo.color, 0.16);
          tag.style.color = phaseInfo.color;
          tag.style.borderColor = phaseInfo.color;
          tag.style.borderWidth = "1px";
          tag.style.borderStyle = "solid";
          footer.appendChild(tag);
        }
        const footerActions = document.createElement("div");
        footerActions.className = "home-project-footer-actions";
        if (isEditMode) {
          const doneBtn = document.createElement("button");
          doneBtn.type = "button";
          doneBtn.className = "home-project-done-btn";
          doneBtn.textContent = "Done";
          doneBtn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const nameVal = card.querySelector(".home-project-name-input").value.trim() || "Untitled project";
            const descVal = card.querySelector(".home-project-desc-input").value.trim();
            if (isProjectNameTaken(nameVal, p.id)) {
              if (typeof showToast === "function") showToast("Duplicate project name. Each project must have a unique nameplease choose a different name.", { type: "error" });
              return;
            }
            ensureProjectInList(p.id, nameVal);
            await saveProjectTitleDescription(p.id, nameVal, descVal);
            homeEditProjectId = null;
            renderHomeView();
          });
          footerActions.appendChild(doneBtn);
        } else {
          const duplicateBtn = document.createElement("button");
          duplicateBtn.type = "button";
          duplicateBtn.className = "home-project-action-btn home-project-duplicate-btn";
          duplicateBtn.title = "Duplicate project";
          duplicateBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
          duplicateBtn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            await duplicateProject(p.id);
          });
          footerActions.appendChild(duplicateBtn);
        }
        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "home-project-delete-btn";
        deleteBtn.title = "Delete this project";
        deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>';
        deleteBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (!confirm("Delete this project? Tasks and settings will be removed. This cannot be undone.")) return;
          pushProjectsListUndo();
          if (p.id === homeEditProjectId) homeEditProjectId = null;
          if (window.ganttStorage?.isCloudEnabled()) {
            await window.ganttStorage.deleteBoard(p.id);
            if (currentProjectId === p.id) { currentProjectId = null; location.hash = "#/"; }
            renderHomeView();
            return;
          }
          const list = loadProjectsList().filter(proj => proj.id !== p.id);
          saveProjectsList(list);
          try {
            localStorage.removeItem("gantt-tasks-" + p.id);
            localStorage.removeItem("gantt-settings-" + p.id);
            localStorage.removeItem("gantt-view-" + p.id);
            localStorage.removeItem("gantt-custom-palettes-" + p.id);
          } catch (err) {}
          renderHomeView();
        });
        footerActions.appendChild(deleteBtn);
        footer.appendChild(footerActions);
        card.appendChild(footer);
        listEl.appendChild(card);
        if (isEditMode) {
          requestAnimationFrame(() => {
            const input = card.querySelector(".home-project-name-input");
            if (input) { input.focus(); input.select(); }
          });
        }
      });
    }
    function isPlaceholderOnlyProject() {
      if (tasks.length === 0) return true;
      if (tasks.length !== 1) return false;
      const name = tasks[0]?.task == null ? "" : String(tasks[0].task).trim();
      return name === "" || name === "my first task";
    }
    function updateEmptyState() {
      const emptyEl = document.getElementById("ganttEmptyState");
      if (!emptyEl) return;
      if (isPlaceholderOnlyProject()) {
        emptyEl.classList.remove("hidden");
      } else {
        emptyEl.classList.add("hidden");
      }
    }
    async function handleRoute() {
      const id = getProjectIdFromHash();
      const homeView = document.getElementById("homeView");
      const ganttView = document.getElementById("ganttView");
      if (!id) {
        currentProjectId = null;
        renderHomeView();
        const addFab = document.getElementById("addTaskFab");
        if (addFab) addFab.style.display = "none";
        document.getElementById("fabPhaseMenu")?.classList.remove("visible");
        const depLineEl = document.getElementById("ganttDependencyLine");
        if (depLineEl) depLineEl.classList.remove("visible");
        const childContainer = document.getElementById("ganttChildConnectorsContainer");
        if (childContainer) childContainer.innerHTML = "";
        const unlinkBtn = document.getElementById("ganttDependencyUnlinkBtn");
        if (unlinkBtn) unlinkBtn.classList.remove("visible");
        document.body.classList.remove("shift-mode");
        if (document._allConnectorsCleanup) {
          document._allConnectorsCleanup();
          document._allConnectorsCleanup = null;
        }
        document.querySelectorAll("body > .gantt-dependency-unlink-btn.connector-unlink-always-visible").forEach(btn => btn.remove());
        const singleLine = document.getElementById("ganttDependencyLine");
        if (singleLine) singleLine.style.visibility = "";
        const allLines = document.getElementById("ganttAllDependencyLines");
        if (allLines) allLines.classList.remove("visible");
        const ganttGrid = document.getElementById("ganttGrid");
        ganttGrid?.querySelectorAll(".gantt-row:not(.gantt-header)").forEach(r => { r.draggable = true; });
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            if (homeView) homeView.classList.add("active");
            if (ganttView) ganttView.classList.remove("active");
          });
        });
        return;
      }
      if (window.ganttStorage?.isCloudEnabled()) await window.ganttStorage.ensureBoardDataLoaded(id);
      const sameProject = currentProjectId === id;
      currentProjectId = id;
      ensureProjectInList(id);
      if (!sameProject) initGantt();
      const addFab = document.getElementById("addTaskFab");
      if (addFab) addFab.style.display = "";
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (homeView) homeView.classList.remove("active");
          if (ganttView) ganttView.classList.add("active");
        });
      });
    }
    function runSamplePopulate() {
      if (PHASES.length === 0) {
        if (typeof showToast === "function") showToast("Add at least one phase in Settings first.");
        openSettingsModal();
        return;
      }
      const baseDate = getProjectStartDate() || WEEK_START;
      const sampleTaskNames = ["Research", "Design", "Review", "Build", "Launch"];
      const n = Math.min(sampleTaskNames.length, Math.max(1, PHASES.length));
      const sampleTasks = [];
      for (let i = 0; i < n; i++) {
        const phaseIdx = Math.min(i, PHASES.length - 1);
        const range = getPhaseDateRange(phaseIdx, baseDate);
        const startDate = range ? range.startDate : new Date(baseDate);
        const endDate = range ? range.endDate : new Date(baseDate.getTime() + 13 * (24 * 60 * 60 * 1000));
        sampleTasks.push({
          task: sampleTaskNames[i],
          phase: PHASES[phaseIdx].id,
          party: "Unassigned",
          star: false,
          overview: "",
          subTasks: [],
          blockers: [],
          links: [],
          dependsOn: i === 0 ? null : i - 1,
          startDate,
          endDate
        });
      }
      sampleTasks.forEach(t => {
        t.start = formatDate(t.startDate);
        t.end = formatDate(t.endDate);
      });
      tasks = sampleTasks;
      tasks.forEach((_, i) => { if (tasks.some(t => t.dependsOn === i)) propagateDependencyChanges(i); });
      saveTasks();
      updateChartRange();
      updateEmptyState();
      renderTasks();
      if (typeof updateWeekWidth === "function") updateWeekWidth();
      if (typeof renderPhaseHeaders === "function") renderPhaseHeaders();
    }
    function initGantt() {
      grid = document.getElementById("ganttGrid");
      if (!grid) {
        console.error("ganttGrid element not found");
        return;
      }
      let guideEl = document.getElementById("ganttDragGuide");
      if (!guideEl) {
        guideEl = document.createElement("div");
        guideEl.id = "ganttDragGuide";
        guideEl.className = "gantt-drag-guide";
        guideEl.setAttribute("aria-hidden", "true");
        document.body.appendChild(guideEl);
      } else {
        document.body.appendChild(guideEl);
      }
      applyProjectSettings();
      const header = loadPageHeader();
      const titleEl = document.getElementById("pageTitle");
      const descEl = document.getElementById("pageDescription");
      if (titleEl) titleEl.textContent = header.title;
      if (descEl) descEl.textContent = header.description;
      if (currentProjectId) ensureProjectInList(currentProjectId, header.title);
      const saveHeader = () => {
        let title = (titleEl?.textContent || "").trim() || DEFAULT_PAGE_TITLE;
        let desc = (descEl?.textContent || "").trim() || DEFAULT_PAGE_DESCRIPTION;
        if (titleEl && !titleEl.textContent.trim()) { titleEl.textContent = title; }
        if (descEl && !descEl.textContent.trim()) { descEl.textContent = desc; }
        savePageHeader(title, desc);
        if (currentProjectId) {
          ensureProjectInList(currentProjectId, title);
          const url = getProjectUrl({ id: currentProjectId, name: title });
          if (typeof history !== "undefined" && history.replaceState) {
            history.replaceState(null, "", url);
          } else {
            location.hash = url;
          }
        }
      };
      if (titleEl) titleEl.addEventListener("blur", saveHeader);
      if (descEl) descEl.addEventListener("blur", saveHeader);
      document.getElementById("settingsBtn")?.addEventListener("click", openSettingsModal);
      document.getElementById("settingsClose")?.addEventListener("click", closeSettingsModal);
      document.getElementById("settingsSave")?.addEventListener("click", saveSettingsFromModal);
      document.getElementById("settingsBarStyle")?.addEventListener("click", (e) => {
        const opt = e.target.closest(".settings-segmented-option");
        if (!opt) return;
        opt.parentElement.querySelectorAll(".settings-segmented-option").forEach(o => o.classList.remove("selected"));
        opt.classList.add("selected");
        updatePaletteSwatchPreviews();
        applySettingsPreviewFromForm();
      });
      document.getElementById("settingsRowAppearance")?.addEventListener("change", applySettingsPreviewFromForm);
      document.getElementById("settingsShowDurationOnBar")?.addEventListener("change", applySettingsPreviewFromForm);
      (function initDependentTasksDropdown() {
        const wrap = document.getElementById("settingsDependentWrap");
        const trigger = document.getElementById("settingsDependentTrigger");
        const panel = document.getElementById("settingsDependentPanel");
        const gapSelect = document.getElementById("settingsDependencyGap");
        if (!wrap || !trigger || !panel || !gapSelect) return;
        trigger.addEventListener("click", (e) => {
          e.stopPropagation();
          const open = wrap.classList.toggle("open");
          trigger.setAttribute("aria-expanded", open);
        });
        panel.querySelectorAll(".settings-dependent-option").forEach(btn => {
          btn.addEventListener("click", () => {
            const val = btn.dataset.value;
            gapSelect.value = val;
            trigger.textContent = btn.textContent;
            wrap.classList.remove("open");
            trigger.setAttribute("aria-expanded", "false");
          });
        });
        panel.querySelector(".settings-dependent-checkbox-wrap")?.addEventListener("click", (e) => e.stopPropagation());
        document.addEventListener("click", (e) => {
          if (wrap.classList.contains("open") && !wrap.contains(e.target)) {
            wrap.classList.remove("open");
            trigger.setAttribute("aria-expanded", "false");
          }
        });
      })();
      document.getElementById("settingsPhaseDurationMode")?.addEventListener("change", () => {
        const el = document.getElementById("settingsPhaseDurationMode");
        const list = document.getElementById("settingsPhaseList");
        const snapWrap = document.getElementById("settingsSnapToSprintWrap");
        if (el && list) list.dataset.phaseMode = el.value === "fixed" ? "fixed" : "dynamic";
        if (snapWrap) snapWrap.style.display = el?.value === "fixed" ? "" : "none";
      });
      document.getElementById("settingsAutoPopulate")?.addEventListener("click", () => {
        const baseDate = getProjectStartDate() || WEEK_START;
        const sampleTaskNames = ["Research", "Design", "Review", "Build", "Launch"];
        const n = Math.min(sampleTaskNames.length, Math.max(1, PHASES.length));
        const sampleTasks = [];
        for (let i = 0; i < n; i++) {
          const phaseIdx = Math.min(i, PHASES.length - 1);
          const range = getPhaseDateRange(phaseIdx, baseDate);
          const startDate = range ? range.startDate : new Date(baseDate);
          const endDate = range ? range.endDate : new Date(baseDate.getTime() + 13 * (24 * 60 * 60 * 1000));
          sampleTasks.push({
            task: sampleTaskNames[i],
            phase: PHASES[phaseIdx].id,
            party: "Unassigned",
            star: false,
            overview: "",
            subTasks: [],
            blockers: [],
            links: [],
            dependsOn: i === 0 ? null : i - 1,
            startDate,
            endDate
          });
        }
        sampleTasks.forEach(t => {
          t.start = formatDate(t.startDate);
          t.end = formatDate(t.endDate);
        });
        tasks = sampleTasks;
        tasks.forEach((_, i) => { if (tasks.some(t => t.dependsOn === i)) propagateDependencyChanges(i); });
        saveTasks();
        updateChartRange();
        closeSettingsModal();
      });
      setupPhaseListDrag(document.getElementById("settingsPhaseList"));
      document.getElementById("settingsOverlay")?.addEventListener("click", (e) => { if (e.target.id === "settingsOverlay") closeSettingsModal(); });
      document.querySelectorAll(".settings-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          const tabId = tab.dataset.tab;
          document.querySelectorAll(".settings-tab").forEach(t => t.classList.remove("active"));
          document.querySelectorAll(".settings-tab-panel").forEach(p => p.classList.remove("active"));
          tab.classList.add("active");
          const panelId = tabId === "function" ? "Function" : tabId === "style" ? "Style" : tabId === "details" ? "Details" : "Function";
          const panel = document.getElementById("settingsTab" + panelId);
          if (panel) panel.classList.add("active");
        });
      });
      document.addEventListener("click", (e) => {
        if (e.target.closest(".task-detail-add-btn") || e.target.closest(".task-detail-list-remove")) return;
        if (!e.target.closest("#ganttGrid")) {
          document.querySelectorAll(".gantt-row.selected").forEach(r => r.classList.remove("selected"));
          collapseDetail(false);
        }
      });
      document.body.appendChild(addBtn);
      tasks = loadTasks();
      addedPlaceholderThisSession = false;
      tasks.forEach((_, i) => { if (tasks.some(t => t.dependsOn === i)) propagateDependencyChanges(i); });
      updateEmptyState();
      const emptyConfigureBtn = document.getElementById("ganttEmptyConfigure");
      if (emptyConfigureBtn) emptyConfigureBtn.onclick = openSettingsModal;
      const emptyPopulateBtn = document.getElementById("ganttEmptyPopulate");
      if (emptyPopulateBtn) emptyPopulateBtn.onclick = runSamplePopulate;
      const viewSelect = document.getElementById("viewMode");
      if (viewSelect) {
        const saved = getSavedView();
        if (saved && VIEW_ORDER.includes(saved)) viewSelect.value = saved;
      }
      document.addEventListener("keydown", (e) => {
        if (e.target.closest("input, select, textarea, [contenteditable]")) return;
        const key = e.key.toLowerCase();
        if (key === "c" || key === "f" || key === "d") {
          e.preventDefault();
          const mode = key === "c" ? "compact" : key === "f" ? "fill" : "default";
          const s = loadProjectSettings() || {};
          saveProjectSettings({ ...s, rowAppearance: mode });
          applyRowAppearance();
          const rowAppearanceEl = document.getElementById("settingsRowAppearance");
          if (rowAppearanceEl) rowAppearanceEl.value = mode;
        }
      });
      updateChartRange();
      requestAnimationFrame(() => {
        updateWeekWidth();
        renderPhaseHeaders();
        restoreScrollPosition();
      });
      const wrapper = document.querySelector(".gantt-wrapper");
      if (wrapper) {
        wrapper.addEventListener("scroll", () => {
          if (scrollSaveTid) clearTimeout(scrollSaveTid);
          scrollSaveTid = setTimeout(saveScrollPosition, 150);
        });
      }
      window.addEventListener("resize", () => { updateWeekWidth(); renderPhaseHeaders(); });

      let shiftHeld = false;
      let shiftModeUnlinkButtons = [];
      const allLinesEl = document.getElementById("ganttAllDependencyLines");
      const singleLineEl = document.getElementById("ganttDependencyLine");
      let connectorDrag = null;
      let connectorUpdateTid = null;

      function updateAllConnectors() {
        if (!allLinesEl || !grid) return;
        allLinesEl.innerHTML = "";
        allLinesEl.classList.remove("visible");
        if (!shiftHeld) return;
        const childCountByPrimary = {};
        tasks.forEach((t) => {
          if (typeof t.dependsOn === "number") childCountByPrimary[t.dependsOn] = (childCountByPrimary[t.dependsOn] || 0) + 1;
        });
        tasks.forEach((t, i) => {
          if (typeof t.dependsOn !== "number" || !tasks[t.dependsOn]) return;
          const primaryIdx = t.dependsOn;
          const primaryBar = grid.querySelector('.gantt-bar[data-index="' + primaryIdx + '"]');
          const dependentBar = grid.querySelector('.gantt-bar[data-index="' + i + '"]');
          if (!primaryBar || !dependentBar) return;
          const pr = primaryBar.getBoundingClientRect();
          const dr = dependentBar.getBoundingClientRect();
          const x1 = pr.left + pr.width / 2;
          const y1 = pr.bottom;
          const x2 = dr.left;
          const y2 = dr.top + dr.height / 2;
          const primaryColor = getPhaseColor(tasks[primaryIdx].phase || PHASES[0]?.id);
          const pathD = connectorPathD(x1, y1, x2, y2);
          const pathHit = document.createElementNS("http://www.w3.org/2000/svg", "path");
          pathHit.setAttribute("d", pathD);
          pathHit.setAttribute("stroke", "transparent");
          pathHit.setAttribute("stroke-width", "5");
          pathHit.setAttribute("fill", "none");
          pathHit.setAttribute("pointer-events", "stroke");
          pathHit.setAttribute("class", "connector-path-hit");
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("d", pathD);
          path.setAttribute("stroke", primaryColor);
          path.setAttribute("stroke-width", "1");
          path.setAttribute("stroke-dasharray", "4 3");
          path.setAttribute("fill", "none");
          path.setAttribute("pointer-events", "none");
          path.setAttribute("class", "connector-path");
          const pathWrap = document.createElementNS("http://www.w3.org/2000/svg", "g");
          pathWrap.setAttribute("class", "connector-path-wrap");
          pathWrap.appendChild(pathHit);
          pathWrap.appendChild(path);
          const dotR = 3;
          const c1 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          c1.setAttribute("transform", `translate(${x1}, ${y1 - dotR})`);
          c1.setAttribute("class", "connector-dot");
          c1.setAttribute("data-dependent-index", i);
          c1.setAttribute("data-primary-index", primaryIdx);
          c1.setAttribute("data-end", "primary");
          const c1Circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          c1Circle.setAttribute("r", "3");
          c1Circle.setAttribute("fill", "white");
          c1Circle.setAttribute("stroke", "#d4d4d4");
          c1Circle.setAttribute("stroke-width", "1");
          const c1Line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
          c1Line1.setAttribute("x1", "-2");
          c1Line1.setAttribute("y1", "0");
          c1Line1.setAttribute("x2", "2");
          c1Line1.setAttribute("y2", "0");
          c1Line1.setAttribute("stroke", "#737373");
          c1Line1.setAttribute("stroke-width", "1");
          c1Line1.setAttribute("stroke-linecap", "round");
          const c1Line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
          c1Line2.setAttribute("x1", "0");
          c1Line2.setAttribute("y1", "-2");
          c1Line2.setAttribute("x2", "0");
          c1Line2.setAttribute("y2", "2");
          c1Line2.setAttribute("stroke", "#737373");
          c1Line2.setAttribute("stroke-width", "1");
          c1Line2.setAttribute("stroke-linecap", "round");
          c1.appendChild(c1Circle);
          c1.appendChild(c1Line1);
          c1.appendChild(c1Line2);
          const childCount = childCountByPrimary[primaryIdx];
          if (childCount > 1) {
            const badgeOffsetY = 24;
            const badgeCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            badgeCircle.setAttribute("cx", "0");
            badgeCircle.setAttribute("cy", String(badgeOffsetY));
            badgeCircle.setAttribute("r", "8");
            badgeCircle.setAttribute("fill", primaryColor);
            badgeCircle.setAttribute("stroke", "#fff");
            badgeCircle.setAttribute("stroke-width", "1");
            const badgeText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            badgeText.setAttribute("x", "0");
            badgeText.setAttribute("y", String(badgeOffsetY));
            badgeText.setAttribute("dy", "0.35em");
            badgeText.setAttribute("text-anchor", "middle");
            badgeText.setAttribute("font-size", "9");
            badgeText.setAttribute("font-weight", "600");
            badgeText.setAttribute("fill", "#fff");
            badgeText.textContent = String(childCount);
            c1.appendChild(badgeCircle);
            c1.appendChild(badgeText);
          }
          
          const c2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          c2.setAttribute("transform", `translate(${x2}, ${y2})`);
          c2.setAttribute("class", "connector-dot");
          c2.setAttribute("data-dependent-index", i);
          c2.setAttribute("data-primary-index", primaryIdx);
          c2.setAttribute("data-end", "dependent");
          const c2Circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          c2Circle.setAttribute("r", "3");
          c2Circle.setAttribute("fill", "white");
          c2Circle.setAttribute("stroke", "#d4d4d4");
          c2Circle.setAttribute("stroke-width", "1");
          const c2Line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
          c2Line1.setAttribute("x1", "-2");
          c2Line1.setAttribute("y1", "0");
          c2Line1.setAttribute("x2", "2");
          c2Line1.setAttribute("y2", "0");
          c2Line1.setAttribute("stroke", "#737373");
          c2Line1.setAttribute("stroke-width", "1");
          c2Line1.setAttribute("stroke-linecap", "round");
          const c2Line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
          c2Line2.setAttribute("x1", "0");
          c2Line2.setAttribute("y1", "-2");
          c2Line2.setAttribute("x2", "0");
          c2Line2.setAttribute("y2", "2");
          c2Line2.setAttribute("stroke", "#737373");
          c2Line2.setAttribute("stroke-width", "1");
          c2Line2.setAttribute("stroke-linecap", "round");
          c2.appendChild(c2Circle);
          c2.appendChild(c2Line1);
          c2.appendChild(c2Line2);
          const addDotHandlers = (circle, fixedX, fixedY, otherX, otherY) => {
            circle.addEventListener("mousedown", (e) => {
              e.preventDefault();
              e.stopPropagation();
              circle.classList.add("connector-dot-dragging");
              path.classList.add("connector-dragging");
              connectorDrag = {
                dependentIdx: parseInt(circle.getAttribute("data-dependent-index"), 10),
                primaryIdx: parseInt(circle.getAttribute("data-primary-index"), 10),
                end: circle.getAttribute("data-end"),
                path, circle, fixedX, fixedY, otherX, otherY
              };
              const onMove = (e2) => {
                e2.preventDefault();
                const cx = e2.clientX;
                const cy = e2.clientY;
                circle.setAttribute("transform", `translate(${cx}, ${cy})`);
                const newD = connectorDrag.end === "primary" ? connectorPathD(cx, cy, otherX, otherY) : connectorPathD(fixedX, fixedY, cx, cy);
                path.setAttribute("d", newD);
                pathHit.setAttribute("d", newD);
                let hoveredIdx = null;
                try {
                  allLinesEl.style.pointerEvents = "none";
                  allLinesEl.style.visibility = "hidden";
                  const ganttWrapper = document.querySelector(".gantt-wrapper");
                  const prevWrapperPE = ganttWrapper?.style.pointerEvents;
                  if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
                  const elements = document.elementsFromPoint(cx, cy);
                  if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
                  for (const el of elements) {
                    const row = el.closest?.(".gantt-row[data-index]");
                    if (row && !row.classList.contains("gantt-header")) {
                      hoveredIdx = parseInt(row.getAttribute("data-index"), 10);
                      break;
                    }
                    const barEl = el.closest?.(".gantt-bar");
                    if (barEl) {
                      hoveredIdx = parseInt(barEl.getAttribute("data-index"), 10);
                      break;
                    }
                  }
                } finally {
                  allLinesEl.style.visibility = "visible";
                  allLinesEl.style.pointerEvents = "auto";
                }
                for (const el of elements) {
                  const row = el.closest?.(".gantt-row[data-index]");
                  if (row && !row.classList.contains("gantt-header")) {
                    hoveredIdx = parseInt(row.getAttribute("data-index"), 10);
                    break;
                  }
                  const barEl = el.closest?.(".gantt-bar");
                  if (barEl) {
                    hoveredIdx = parseInt(barEl.getAttribute("data-index"), 10);
                    break;
                  }
                }
                let previewColor = "#a3a3a3";
                if (hoveredIdx !== null && !isNaN(hoveredIdx)) {
                  if (connectorDrag.end === "primary" && hoveredIdx !== connectorDrag.dependentIdx && !wouldCreateCycle(connectorDrag.dependentIdx, hoveredIdx)) {
                    previewColor = getPhaseColor(tasks[hoveredIdx].phase || PHASES[0]?.id);
                  } else if (connectorDrag.end === "dependent" && hoveredIdx !== connectorDrag.primaryIdx && !wouldCreateCycle(hoveredIdx, connectorDrag.primaryIdx)) {
                    previewColor = getPhaseColor(tasks[hoveredIdx].phase || PHASES[0]?.id);
                  }
                }
                path.setAttribute("stroke", previewColor);
              };
              const onUp = (e2) => {
                e2.preventDefault();
                e2.stopPropagation();
                document.removeEventListener("mousemove", onMove);
                document.removeEventListener("mouseup", onUp);
                try {
                  allLinesEl.style.pointerEvents = "none";
                  allLinesEl.style.visibility = "hidden";
                  const ganttWrapper = document.querySelector(".gantt-wrapper");
                  const prevWrapperPE = ganttWrapper?.style.pointerEvents;
                  if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
                  var elements = document.elementsFromPoint(e2.clientX, e2.clientY);
                  if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
                } finally {
                  allLinesEl.style.visibility = "visible";
                  allLinesEl.style.pointerEvents = "auto";
                }
                let newIdx = null;
                for (const el of elements) {
                  const row = el.closest?.(".gantt-row[data-index]");
                  if (row && !row.classList.contains("gantt-header")) {
                    newIdx = parseInt(row.getAttribute("data-index"), 10);
                    break;
                  }
                  const bar = el.closest?.(".gantt-bar");
                  if (bar) {
                    newIdx = parseInt(bar.getAttribute("data-index"), 10);
                    break;
                  }
                }
                let didUpdate = false;
                let toastMessage = "";
                if (connectorDrag && newIdx !== null && !isNaN(newIdx)) {
                  if (connectorDrag.end === "primary" && newIdx !== connectorDrag.dependentIdx && !wouldCreateCycle(connectorDrag.dependentIdx, newIdx)) {
                    pushTasksUndo();
                    tasks[connectorDrag.dependentIdx].dependsOn = newIdx;
                    propagateDependencyChanges(newIdx);
                    didUpdate = true;
                    const childTask = tasks[connectorDrag.dependentIdx];
                    const newParentTask = tasks[newIdx];
                    const childName = (childTask.star ? " " : "") + (childTask.task || "Task");
                    const parentName = (newParentTask.star ? " " : "") + (newParentTask.task || "Task");
                    toastMessage = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${childName}"  "${parentName}"`;
                  } else if (connectorDrag.end === "dependent" && newIdx !== connectorDrag.primaryIdx && !wouldCreateCycle(newIdx, connectorDrag.primaryIdx)) {
                    pushTasksUndo();
                    tasks[connectorDrag.dependentIdx].dependsOn = null;
                    tasks[newIdx].dependsOn = connectorDrag.primaryIdx;
                    propagateDependencyChanges(connectorDrag.primaryIdx);
                    didUpdate = true;
                    const newChildTask = tasks[newIdx];
                    const parentTask = tasks[connectorDrag.primaryIdx];
                    const childName = (newChildTask.star ? " " : "") + (newChildTask.task || "Task");
                    const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
                    toastMessage = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${childName}"  "${parentName}"`;
                  }
                }
                if (didUpdate) {
                  saveTasks();
                  renderTasks();
                  if (toastMessage) showToast(toastMessage, { onUndo: performUndo });
                }
                circle.classList.remove("connector-dot-dragging");
                path.classList.remove("connector-dragging");
                connectorDrag = null;
              };
              document.addEventListener("mousemove", onMove);
              document.addEventListener("mouseup", onUp, { once: true });
              onMove(e);
            });
          };
          addDotHandlers(c1, x1, y1, x2, y2);
          addDotHandlers(c2, x1, y1, x2, y2);
          allLinesEl.appendChild(pathWrap);
          allLinesEl.appendChild(c1);
          allLinesEl.appendChild(c2);
          
          // Create unlink button for this connector (visible immediately in shift mode)
          const unlinkBtn = document.createElement("button");
          unlinkBtn.className = "gantt-dependency-unlink-btn connector-unlink-always-visible visible";
          unlinkBtn.type = "button";
          unlinkBtn.title = "Unlink tasks";
          unlinkBtn.style.position = "fixed";
          unlinkBtn.style.left = x1 + "px";
          unlinkBtn.style.top = y2 + "px";
          unlinkBtn.style.backgroundColor = primaryColor;
          unlinkBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/>
            <path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/>
            <line x1="8" y1="2" x2="8" y2="5"/>
            <line x1="2" y1="8" x2="5" y2="8"/>
            <line x1="16" y1="19" x2="16" y2="22"/>
            <line x1="19" y1="16" x2="22" y2="16"/>
          </svg>`;
          unlinkBtn.addEventListener("click", () => {
            const childTask = tasks[i];
            const parentTask = tasks[primaryIdx];
            const childName = (childTask.star ? " " : "") + (childTask.task || "Task");
            const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
            pushTasksUndo();
            childTask.dependsOn = null;
            saveTasks();
            renderTasks();
            showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71"/><path d="M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71"/><line x1="8" y1="2" x2="8" y2="5"/><line x1="2" y1="8" x2="5" y2="8"/><line x1="16" y1="19" x2="16" y2="22"/><line x1="19" y1="16" x2="22" y2="16"/></svg> "${childName}" unlinked from "${parentName}"`, { onUndo: performUndo });
          });
          
          // In shift mode unlink button is always visible (no hover-to-show)
          document.body.appendChild(unlinkBtn);
          shiftModeUnlinkButtons.push(unlinkBtn);
        });
        tasks.forEach((t, i) => {
          const bar = grid.querySelector('.gantt-bar[data-index="' + i + '"]');
          if (!bar) return;
          const dr = bar.getBoundingClientRect();
          const hasDep = typeof t.dependsOn === "number" && tasks[t.dependsOn];
          const isPrimary = tasks.some((ot, j) => j !== i && ot.dependsOn === i);
          /* Add standalone dependent dot for every task without a parent so they can attach to one */
          if (!hasDep) {
            const x = dr.left;
            const y = dr.top + dr.height / 2;
            const dot = document.createElementNS("http://www.w3.org/2000/svg", "g");
            dot.setAttribute("transform", `translate(${x}, ${y})`);
            dot.setAttribute("class", "connector-dot connector-dot-standalone");
            dot.setAttribute("data-dependent-index", i);
            dot.setAttribute("data-standalone", "dependent");
            const dotCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            dotCircle.setAttribute("r", "3");
            dotCircle.setAttribute("fill", "white");
            dotCircle.setAttribute("stroke", "#d4d4d4");
            dotCircle.setAttribute("stroke-width", "1");
            const dotLine1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            dotLine1.setAttribute("x1", "-2");
            dotLine1.setAttribute("y1", "0");
            dotLine1.setAttribute("x2", "2");
            dotLine1.setAttribute("y2", "0");
            dotLine1.setAttribute("stroke", "#737373");
            dotLine1.setAttribute("stroke-width", "1");
            dotLine1.setAttribute("stroke-linecap", "round");
            const dotLine2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            dotLine2.setAttribute("x1", "0");
            dotLine2.setAttribute("y1", "-2");
            dotLine2.setAttribute("x2", "0");
            dotLine2.setAttribute("y2", "2");
            dotLine2.setAttribute("stroke", "#737373");
            dotLine2.setAttribute("stroke-width", "1");
            dotLine2.setAttribute("stroke-linecap", "round");
            dot.appendChild(dotCircle);
            dot.appendChild(dotLine1);
            dot.appendChild(dotLine2);
            dot.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            dot.classList.add("connector-dot-dragging");
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("stroke", "#a3a3a3");
            path.setAttribute("stroke-width", "1");
            path.setAttribute("stroke-dasharray", "6 4");
            path.setAttribute("fill", "none");
            path.setAttribute("pointer-events", "stroke");
            path.setAttribute("class", "connector-path connector-dragging");
            allLinesEl.insertBefore(path, allLinesEl.firstChild);
            const onMove = (e2) => {
              e2.preventDefault();
              const cx = e2.clientX;
              const cy = e2.clientY;
              dot.setAttribute("transform", `translate(${cx}, ${cy})`);
              path.setAttribute("d", connectorPathD(x, y, cx, cy));
              // Update preview color based on potential parent task
              allLinesEl.style.pointerEvents = "none";
              allLinesEl.style.visibility = "hidden";
              const ganttWrapper = document.querySelector(".gantt-wrapper");
              const prevWrapperPE = ganttWrapper?.style.pointerEvents;
              if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
              const elements = document.elementsFromPoint(cx, cy);
              if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
              allLinesEl.style.visibility = "";
              allLinesEl.style.pointerEvents = "auto";
              let hoveredIdx = null;
              for (const el of elements) {
                const row = el.closest?.(".gantt-row[data-index]");
                if (row && !row.classList.contains("gantt-header")) {
                  hoveredIdx = parseInt(row.getAttribute("data-index"), 10);
                  break;
                }
                const bar = el.closest?.(".gantt-bar");
                if (bar) {
                  hoveredIdx = parseInt(bar.getAttribute("data-index"), 10);
                  break;
                }
              }
              if (hoveredIdx !== null && !isNaN(hoveredIdx) && hoveredIdx !== i && !wouldCreateCycle(i, hoveredIdx)) {
                const potentialParent = tasks[hoveredIdx];
                const color = getPhaseColor(potentialParent.phase || PHASES[0]?.id);
                path.setAttribute("stroke", color);
              } else {
                path.setAttribute("stroke", "#a3a3a3");
              }
            };
            const onUp = (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
              document.removeEventListener("mousemove", onMove);
              document.removeEventListener("mouseup", onUp);
              allLinesEl.style.pointerEvents = "none";
              allLinesEl.style.visibility = "hidden";
              const ganttWrapper = document.querySelector(".gantt-wrapper");
              const prevWrapperPE = ganttWrapper?.style.pointerEvents;
              if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
              const elements = document.elementsFromPoint(e2.clientX, e2.clientY);
              if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
              allLinesEl.style.visibility = "";
              allLinesEl.style.pointerEvents = "auto";
              let newIdx = null;
              for (const el of elements) {
                const row = el.closest?.(".gantt-row[data-index]");
                if (row && !row.classList.contains("gantt-header")) {
                  newIdx = parseInt(row.getAttribute("data-index"), 10);
                  break;
                }
                const barEl = el.closest?.(".gantt-bar");
                if (barEl) {
                  newIdx = parseInt(barEl.getAttribute("data-index"), 10);
                  break;
                }
              }
              path.remove();
              dot.classList.remove("connector-dot-dragging");
              if (newIdx !== null && !isNaN(newIdx) && newIdx !== i && !wouldCreateCycle(i, newIdx)) {
                const childTask = tasks[i];
                const parentTask = tasks[newIdx];
                const childName = (childTask.star ? " " : "") + (childTask.task || "Task");
                const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
                pushTasksUndo();
                tasks[i].dependsOn = newIdx;
                propagateDependencyChanges(newIdx);
                saveTasks();
                renderTasks();
                showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${childName}"  "${parentName}"`, { onUndo: performUndo });
              }
            };
            document.addEventListener("mousemove", onMove);
            document.addEventListener("mouseup", onUp, { once: true });
            onMove(e);
          });
          allLinesEl.appendChild(dot);
          }
          if (!isPrimary) {
            const x = dr.left + dr.width / 2;
            const y = dr.bottom;
            const primaryColor = getPhaseColor(tasks[i].phase || PHASES[0]?.id);
            const dot = document.createElementNS("http://www.w3.org/2000/svg", "g");
            dot.setAttribute("transform", `translate(${x}, ${y})`);
            dot.setAttribute("class", "connector-dot connector-dot-standalone");
            dot.setAttribute("data-primary-index", i);
            dot.setAttribute("data-standalone", "primary");
            const dotCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            dotCircle.setAttribute("r", "3");
            dotCircle.setAttribute("fill", "white");
            dotCircle.setAttribute("stroke", "#d4d4d4");
            dotCircle.setAttribute("stroke-width", "1");
            const dotLine1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            dotLine1.setAttribute("x1", "-2");
            dotLine1.setAttribute("y1", "0");
            dotLine1.setAttribute("x2", "2");
            dotLine1.setAttribute("y2", "0");
            dotLine1.setAttribute("stroke", "#737373");
            dotLine1.setAttribute("stroke-width", "1");
            dotLine1.setAttribute("stroke-linecap", "round");
            const dotLine2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            dotLine2.setAttribute("x1", "0");
            dotLine2.setAttribute("y1", "-2");
            dotLine2.setAttribute("x2", "0");
            dotLine2.setAttribute("y2", "2");
            dotLine2.setAttribute("stroke", "#737373");
            dotLine2.setAttribute("stroke-width", "1");
            dotLine2.setAttribute("stroke-linecap", "round");
            dot.appendChild(dotCircle);
            dot.appendChild(dotLine1);
            dot.appendChild(dotLine2);
            dot.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            dot.classList.add("connector-dot-dragging");
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("stroke", primaryColor);
            path.setAttribute("stroke-width", "1");
            path.setAttribute("stroke-dasharray", "6 4");
            path.setAttribute("fill", "none");
            path.setAttribute("pointer-events", "stroke");
            path.setAttribute("class", "connector-path connector-dragging");
            allLinesEl.insertBefore(path, allLinesEl.firstChild);
            const onMove = (e2) => {
              e2.preventDefault();
              const cx = e2.clientX;
              const cy = e2.clientY;
              dot.setAttribute("transform", `translate(${cx}, ${cy})`);
              path.setAttribute("d", connectorPathD(x, y, cx, cy));
              allLinesEl.style.pointerEvents = "none";
              allLinesEl.style.visibility = "hidden";
              const ganttWrapper = document.querySelector(".gantt-wrapper");
              const prevWrapperPE = ganttWrapper?.style.pointerEvents;
              if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
              const elements = document.elementsFromPoint(cx, cy);
              if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
              allLinesEl.style.visibility = "";
              allLinesEl.style.pointerEvents = "auto";
              let hoveredIdx = null;
              for (const el of elements) {
                const row = el.closest?.(".gantt-row[data-index]");
                if (row && !row.classList.contains("gantt-header")) {
                  hoveredIdx = parseInt(row.getAttribute("data-index"), 10);
                  break;
                }
                const barEl = el.closest?.(".gantt-bar");
                if (barEl) {
                  hoveredIdx = parseInt(barEl.getAttribute("data-index"), 10);
                  break;
                }
              }
              if (hoveredIdx !== null && !isNaN(hoveredIdx) && hoveredIdx !== i && !wouldCreateCycle(hoveredIdx, i)) {
                path.setAttribute("stroke", getPhaseColor(tasks[hoveredIdx].phase || PHASES[0]?.id));
              } else {
                path.setAttribute("stroke", "#a3a3a3");
              }
            };
            const onUp = (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
              document.removeEventListener("mousemove", onMove);
              document.removeEventListener("mouseup", onUp);
              allLinesEl.style.pointerEvents = "none";
              allLinesEl.style.visibility = "hidden";
              const ganttWrapper = document.querySelector(".gantt-wrapper");
              const prevWrapperPE = ganttWrapper?.style.pointerEvents;
              if (ganttWrapper) ganttWrapper.style.pointerEvents = "auto";
              const elements = document.elementsFromPoint(e2.clientX, e2.clientY);
              if (ganttWrapper) ganttWrapper.style.pointerEvents = prevWrapperPE || "";
              allLinesEl.style.visibility = "";
              allLinesEl.style.pointerEvents = "auto";
              let newIdx = null;
              for (const el of elements) {
                const row = el.closest?.(".gantt-row[data-index]");
                if (row && !row.classList.contains("gantt-header")) {
                  newIdx = parseInt(row.getAttribute("data-index"), 10);
                  break;
                }
                const barEl = el.closest?.(".gantt-bar");
                if (barEl) {
                  newIdx = parseInt(barEl.getAttribute("data-index"), 10);
                  break;
                }
              }
              path.remove();
              dot.classList.remove("connector-dot-dragging");
              if (newIdx !== null && !isNaN(newIdx) && newIdx !== i && !wouldCreateCycle(newIdx, i)) {
                const childTask = tasks[newIdx];
                const parentTask = tasks[i];
                const childName = (childTask.star ? " " : "") + (childTask.task || "Task");
                const parentName = (parentTask.star ? " " : "") + (parentTask.task || "Task");
                pushTasksUndo();
                tasks[newIdx].dependsOn = i;
                propagateDependencyChanges(i);
                saveTasks();
                renderTasks();
                showToast(`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg> "${childName}"  "${parentName}"`, { onUndo: performUndo });
              }
            };
            document.addEventListener("mousemove", onMove);
            document.addEventListener("mouseup", onUp, { once: true });
            onMove(e);
          });
          allLinesEl.appendChild(dot);
          }
        });
        allLinesEl.setAttribute("viewBox", "0 0 " + window.innerWidth + " " + window.innerHeight);
        allLinesEl.setAttribute("width", window.innerWidth);
        allLinesEl.setAttribute("height", window.innerHeight);
        allLinesEl.classList.add("visible");
      }
      const blockChartPointer = (e) => {
        if (!shiftHeld) return;
        if (e.target.closest("#ganttAllDependencyLines")) return;
        if (e.target.closest("input, select, textarea, button, [contenteditable]")) return;
        if (e.target.closest(".gantt-wrapper")) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      function enableShiftMode() {
        if (shiftHeld) return;
        shiftHeld = true;
        shiftModeUnlinkButtons.forEach(btn => btn.remove());
        shiftModeUnlinkButtons = [];
        document.body.classList.add("shift-mode");
        grid?.querySelectorAll(".gantt-row[draggable]").forEach(r => { r.draggable = false; });
        if (singleLineEl) singleLineEl.style.visibility = "hidden";
        updateAllConnectors();
        document.addEventListener("mousedown", blockChartPointer, true);
        document.addEventListener("dragstart", blockChartPointer, true);
        const debouncedUpdate = () => {
          if (connectorUpdateTid) clearTimeout(connectorUpdateTid);
          connectorUpdateTid = setTimeout(() => {
            connectorUpdateTid = null;
            updateAllConnectors();
          }, 80);
        };
        const wrapper = document.querySelector(".gantt-wrapper");
        wrapper?.addEventListener("scroll", debouncedUpdate, true);
        window.addEventListener("scroll", debouncedUpdate, true);
        window.addEventListener("resize", debouncedUpdate);
        document._allConnectorsCleanup = () => {
          document.removeEventListener("mousedown", blockChartPointer, true);
          document.removeEventListener("dragstart", blockChartPointer, true);
          wrapper?.removeEventListener("scroll", debouncedUpdate, true);
          window.removeEventListener("scroll", debouncedUpdate, true);
          window.removeEventListener("resize", debouncedUpdate);
          shiftModeUnlinkButtons.forEach(btn => btn.remove());
          shiftModeUnlinkButtons = [];
        };
      }
      function disableShiftMode() {
        if (!shiftHeld) return;
        shiftHeld = false;
        document.body.classList.remove("shift-mode");
        grid?.querySelectorAll(".gantt-row:not(.gantt-header)").forEach(r => { r.draggable = true; });
        if (singleLineEl) singleLineEl.style.visibility = "";
        shiftModeUnlinkButtons.forEach(btn => btn.remove());
        shiftModeUnlinkButtons.length = 0;
        if (allLinesEl) {
          allLinesEl.classList.remove("visible");
        }
        if (document._allConnectorsCleanup) {
          document._allConnectorsCleanup();
          document._allConnectorsCleanup = null;
        }
        const wrapper = document.querySelector(".gantt-wrapper");
        if (wrapper) wrapper.style.pointerEvents = "";
        document.removeEventListener("mousedown", blockChartPointer, true);
        document.removeEventListener("dragstart", blockChartPointer, true);
      }
      document.addEventListener("keydown", (e) => {
        if (e.getModifierState("CapsLock") && !shiftHeld) enableShiftMode();
        if (e.key === "Escape" && shiftHeld) {
          disableShiftMode();
          return;
        }
        if (e.key === "CapsLock") {
          if (e.getModifierState("CapsLock")) enableShiftMode();
          else disableShiftMode();
          return;
        }
        if (e.key === "Shift" && !shiftHeld) enableShiftMode();
      });
      document.addEventListener("keyup", (e) => {
        if (e.key === "Shift" && shiftHeld && !e.getModifierState("CapsLock")) disableShiftMode();
      });
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && shiftHeld) disableShiftMode();
      });
      window.addEventListener("blur", () => {
        if (shiftHeld) disableShiftMode();
      });
    }

    function migrateLegacySingleProject() {
      const list = loadProjectsList();
      if (list.length > 0) return;
      const legacyTasks = "gantt-chart-tasks-gantt-chart";
      const legacySettings = "gantt-chart-project-settings-gantt-chart";
      const legacyView = "gantt-chart-view-gantt-chart";
      try {
        if (localStorage.getItem(legacyTasks) || localStorage.getItem(legacySettings)) {
          const tasksRaw = localStorage.getItem(legacyTasks);
          const settingsRaw = localStorage.getItem(legacySettings);
          const viewRaw = localStorage.getItem(legacyView);
          if (tasksRaw) localStorage.setItem("gantt-tasks-default", tasksRaw);
          if (settingsRaw) localStorage.setItem("gantt-settings-default", settingsRaw);
          if (viewRaw) localStorage.setItem("gantt-view-default", viewRaw);
          const name = settingsRaw ? (JSON.parse(settingsRaw).title || "My project") : "My project";
          saveProjectsList([{ id: "default", name, createdAt: Date.now() }]);
          if (!location.hash || location.hash === "#" || location.hash === "#/")
            location.hash = "#/project/default";
        }
      } catch (e) { console.warn("Legacy migration skipped:", e); }
    }
    function initAuthUI() {
      if (!window.ganttStorage) return;
      const loginBtn = document.getElementById("ganttAuthLogin");
      const wrap = document.getElementById("ganttAuthWrap");
      const userEmailEl = document.getElementById("ganttAuthUserEmail");
      const userTrigger = document.getElementById("ganttAuthUserTrigger");
      const userDropdown = document.getElementById("ganttAuthUserDropdown");
      const supabaseLink = document.getElementById("ganttAuthSupabaseLink");
      const logoutBtn = document.getElementById("ganttAuthLogout");
      const overlay = document.getElementById("ganttAuthModalOverlay");
      const configSection = document.getElementById("ganttAuthConfigSection");
      const loginSection = document.getElementById("ganttAuthLoginSection");
      const configUrlInput = document.getElementById("ganttAuthConfigUrl");
      const configAnonInput = document.getElementById("ganttAuthConfigAnonKey");
      const configSaveBtn = document.getElementById("ganttAuthConfigSave");
      const cancelConfigBtn = document.getElementById("ganttAuthCancelConfig");
      const showConfigLink = document.getElementById("ganttAuthShowConfig");
      const emailInput = document.getElementById("ganttAuthEmail");
      const passwordInput = document.getElementById("ganttAuthPassword");
      const rememberCheckbox = document.getElementById("ganttAuthRemember");
      const submitBtn = document.getElementById("ganttAuthSubmit");
      const signupSubmitBtn = document.getElementById("ganttAuthSignupSubmit");
      const errorEl = document.getElementById("ganttAuthError");
      const GANTT_AUTH_REMEMBER_EMAIL_KEY = "gantt-auth-remember-email";

      function authErrorMessage(err) {
        if (!err) return "Something went wrong.";
        const msg = typeof err === "string" ? err : (err && err.message ? err.message : String(err));
        if (/aborted|cancelled|canceled|timeout/i.test(msg)) return "Request was cancelled or took too long. Please try again.";
        return msg;
      }

      function showAuthError(msg) {
        if (!errorEl) return;
        errorEl.textContent = authErrorMessage(msg);
        errorEl.style.display = "block";
      }

      function clearAuthError() {
        if (errorEl) { errorEl.textContent = ""; errorEl.style.display = "none"; }
      }

      function setAuthLoading(which) {
        var isLogin = which === "login";
        var isSignup = which === "signup";
        var busy = isLogin || isSignup;
        if (submitBtn) {
          submitBtn.disabled = busy;
          submitBtn.textContent = isLogin ? "Logging in" : "Log in";
        }
        if (signupSubmitBtn) {
          signupSubmitBtn.disabled = busy;
          signupSubmitBtn.textContent = isSignup ? "Signing up" : "Sign up";
        }
      }

      function withTimeout(promise, ms, message) {
        return Promise.race([
          promise,
          new Promise((_, reject) => setTimeout(() => reject(new Error(message)), ms))
        ]);
      }

      function showModalView(view) {
        const isConfig = view === "config";
        if (configSection) configSection.classList.toggle("hidden", !isConfig);
        if (loginSection) loginSection.classList.toggle("hidden", isConfig);
        clearAuthError();
      }

      function fillRememberedEmail() {
        try {
          const saved = localStorage.getItem(GANTT_AUTH_REMEMBER_EMAIL_KEY);
          if (saved && emailInput) emailInput.value = saved;
        } catch (e) {}
      }

      function openModal() {
        overlay?.classList.add("visible");
        if (window.ganttStorage.isCloudEnabled()) {
          showModalView("login");
          fillRememberedEmail();
          emailInput?.focus();
        } else {
          showModalView("config");
          const saved = window.ganttStorage.getSavedConfig();
          if (configUrlInput) configUrlInput.value = saved?.url || "";
          if (configAnonInput) configAnonInput.value = saved?.anonKey || "";
          configUrlInput?.focus();
        }
      }

      var hadSession = false;
      function updateAuthUI(session) {
        const show = !!session;
        if (hadSession && !show && typeof showToast === "function") {
          showToast("You have been logged out.", { type: "error" });
        }
        hadSession = !!session;
        if (wrap) wrap.style.display = show ? "" : "none";
        if (loginBtn) loginBtn.style.display = show ? "none" : "";
        if (userEmailEl) userEmailEl.textContent = show ? (session.user?.email || "Signed in") : "";
        if (supabaseLink && window.ganttStorage) {
          const config = window.ganttStorage.getSavedConfig();
          if (config && config.url) {
            const m = config.url.match(/^https:\/\/([^.]+)\.supabase\.co/);
            supabaseLink.href = m ? "https://supabase.com/dashboard/project/" + m[1] : "https://supabase.com/dashboard";
          } else supabaseLink.href = "https://supabase.com/dashboard";
        }
        wrap?.classList.remove("open");
      }
      window.ganttStorage.onAuthChange(updateAuthUI);

      if (loginBtn) loginBtn.addEventListener("click", openModal);
      if (userTrigger && wrap) {
        userTrigger.addEventListener("click", (e) => {
          e.stopPropagation();
          wrap.classList.toggle("open");
          userTrigger.setAttribute("aria-expanded", wrap.classList.contains("open"));
        });
      }
      document.addEventListener("click", (e) => {
        if (wrap && wrap.classList.contains("open") && !wrap.contains(e.target)) wrap.classList.remove("open");
      });
      if (userDropdown) userDropdown.addEventListener("click", (e) => e.stopPropagation());
      if (supabaseLink) supabaseLink.addEventListener("click", () => wrap?.classList.remove("open"));
      if (logoutBtn) logoutBtn.addEventListener("click", () => { wrap?.classList.remove("open"); window.ganttStorage.signOut(); });
      if (overlay) overlay.addEventListener("click", (e) => { if (e.target === overlay) overlay.classList.remove("visible"); });
      if (cancelConfigBtn) cancelConfigBtn.addEventListener("click", () => overlay?.classList.remove("visible"));

      if (configSaveBtn) configSaveBtn.addEventListener("click", () => {
        try {
          errorEl.style.display = "none";
          errorEl.textContent = "";
          const url = (configUrlInput && configUrlInput.value || "").trim();
          const anonKey = (configAnonInput && configAnonInput.value || "").trim();
          const result = window.ganttStorage.saveConfig({ url, anonKey });
          if (result && result.error) {
            errorEl.textContent = (result.error.message || "Invalid config");
            errorEl.style.display = "block";
            return;
          }
          if (!result || !result.ok) return;
          showModalView("login");
          fillRememberedEmail();
          emailInput?.focus();
        } catch (err) {
          if (errorEl) {
            errorEl.textContent = (err && err.message) || String(err);
            errorEl.style.display = "block";
          }
        }
      });

      if (showConfigLink) showConfigLink.addEventListener("click", () => {
        const saved = window.ganttStorage.getSavedConfig();
        if (configUrlInput) configUrlInput.value = saved?.url || "";
        if (configAnonInput) configAnonInput.value = saved?.anonKey || "";
        showModalView("config");
        configUrlInput?.focus();
      });

      if (submitBtn) submitBtn.addEventListener("click", async () => {
        const email = emailInput?.value?.trim();
        const password = passwordInput?.value;
        clearAuthError();
        if (!email || !password) { showAuthError("Enter email and password."); return; }
        setAuthLoading("login");
        try {
          const result = await withTimeout(
            window.ganttStorage.signIn(email, password),
            45000,
            "Request took too long. Check your connection and Supabase project URL (Dashboard  Settings  API), then try again."
          );
          if (result && result.error) { showAuthError(result.error); return; }
          try {
            if (rememberCheckbox?.checked) localStorage.setItem(GANTT_AUTH_REMEMBER_EMAIL_KEY, email);
            else localStorage.removeItem(GANTT_AUTH_REMEMBER_EMAIL_KEY);
          } catch (e) {}
          overlay.classList.remove("visible");
          if (typeof renderHomeView === "function") renderHomeView();
          if (window.ganttStorage?.refreshAuthUI) await window.ganttStorage.refreshAuthUI();
        } catch (err) {
          var msg = err && err.message ? err.message : "Network or server error. Check your connection and try again.";
          if (typeof console !== "undefined" && console.warn) console.warn("[Login]", msg);
          showAuthError(msg);
        } finally {
          setAuthLoading(false);
        }
      });

      if (signupSubmitBtn) signupSubmitBtn.addEventListener("click", async () => {
        const email = emailInput?.value?.trim();
        const password = passwordInput?.value;
        clearAuthError();
        if (!email || !password) { showAuthError("Enter email and password."); return; }
        setAuthLoading("signup");
        try {
          const result = await withTimeout(
            window.ganttStorage.signUp(email, password),
            45000,
            "Request took too long. Check your connection and Supabase project URL (Dashboard  Settings  API), then try again."
          );
          if (result && result.error) { showAuthError(result.error); return; }
          overlay.classList.remove("visible");
          if (typeof renderHomeView === "function") renderHomeView();
          if (window.ganttStorage?.refreshAuthUI) await window.ganttStorage.refreshAuthUI();
        } catch (err) {
          showAuthError(err && err.message ? err.message : "Network or server error. Check your connection and try again.");
        } finally {
          setAuthLoading(false);
        }
      });
    }

    async function bootstrap() {
      migrateLegacySingleProject();
      initAuthUI();
      if (window.ganttStorage?.isCloudEnabled()) {
        const session = await window.ganttStorage.getSession();
        if (session) await window.ganttStorage.ensureBoardsListLoaded();
        if (window.ganttStorage?.refreshAuthUI) window.ganttStorage.refreshAuthUI();
        setTimeout(function () {
          if (window.ganttStorage?.refreshAuthUI) window.ganttStorage.refreshAuthUI();
        }, 400);
      }
      window.addEventListener("hashchange", () => handleRoute());
      async function createNewProject() {
        if (window.ganttStorage?.isCloudEnabled()) {
          const name = getUniqueProjectName("Untitled project");
          let newId;
          try {
            newId = await window.ganttStorage.createBoard(name);
          } catch (err) {
            if (typeof showToast === "function") showToast("Could not create project. Try again or log out and back in.", { type: "error" });
            return;
          }
          if (newId) {
            ensureProjectInList(newId, name);
            homeEditProjectId = newId;
            renderHomeView();
            requestAnimationFrame(() => {
              const newCard = document.querySelector(".home-project-card.edit-mode");
              if (newCard) newCard.scrollIntoView({ behavior: "smooth", block: "nearest" });
            });
          } else {
            if (typeof showToast === "function") showToast("Could not create project. Check connection or try logging out and back in.", { type: "error" });
          }
          return;
        }
        const newId = "p-" + Date.now();
        ensureProjectInList(newId, getUniqueProjectName("Untitled project"));
        homeEditProjectId = newId;
        renderHomeView();
        requestAnimationFrame(() => {
          const newCard = document.querySelector(".home-project-card.edit-mode");
          if (newCard) newCard.scrollIntoView({ behavior: "smooth", block: "nearest" });
        });
      }
      document.addEventListener("click", async (e) => {
        if (!e.target.closest("#homeFab") && !e.target.closest(".home-new-project-btn")) return;
        const homeView = document.getElementById("homeView");
        if (!homeView?.classList.contains("active")) return;
        e.preventDefault();
        e.stopPropagation();
        try {
          await createNewProject();
        } catch (err) {
          if (typeof showToast === "function") showToast("Could not create project.", { type: "error" });
        }
      });
      (function initViewCycling() {
        const viewSelect = document.getElementById("viewMode");
        if (!viewSelect) return;
        const applyView = () => {
          setSavedView(viewSelect.value);
          if (typeof updateWeekWidth === "function") updateWeekWidth();
          if (typeof renderPhaseHeaders === "function") renderPhaseHeaders();
        };
        viewSelect.addEventListener("change", applyView);
        document.addEventListener("keydown", (e) => {
          if (!currentProjectId) return;
          if (e.target.closest("input, select, textarea, [contenteditable]")) return;
          let idx = VIEW_ORDER.indexOf(viewSelect.value);
          if (idx < 0) idx = 2;
          if (e.key === "=" || e.key === "+") {
            e.preventDefault();
            idx = idx > 0 ? idx - 1 : VIEW_ORDER.length - 1;
            viewSelect.value = VIEW_ORDER[idx];
            applyView();
          } else if (e.key === "-") {
            e.preventDefault();
            idx = idx < VIEW_ORDER.length - 1 ? idx + 1 : 0;
            viewSelect.value = VIEW_ORDER[idx];
            applyView();
          }
        });
      })();
      await handleRoute();
    }
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", bootstrap);
    } else {
      bootstrap();
    }
  </script>
</body>
</html>
